{"config":{"lang":["en","ru","pt"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"Chapter 0 - Getting Started","text":""},{"location":"#welcome","title":"Welcome","text":"<p>Zig is a general-purpose programming language and toolchain for maintaining robust, optimal, and reusable software.</p> <p>Warning: the latest major release is 0.11 - Zig is still pre-1.0; usage in production is still not recommended and you may run into compiler bugs.</p> <p>To follow this guide, we assume you have:</p> <ul> <li>Prior experience programming</li> <li>Some understanding of low-level programming concepts</li> </ul> <p>Knowing a language like C, C++, Rust, Go, Pascal or similar will be helpful for following this guide. You should have an editor, terminal and internet connection available to you. This guide is unofficial and unaffiliated with the Zig Software Foundation, and is designed to be read in order from the start.</p>"},{"location":"#installation","title":"Installation","text":"<p>This guide assumes you're using a master build of Zig as opposed to the latest major release, which means downloading a binary from the site or compiling from source; the version of Zig in your package manager is likely outdated. This guide does not support Zig 0.10.1.</p> <ol> <li> <p>Download and extract a prebuilt master binary of Zig from https://ziglang.org/download/.</p> </li> <li> <p>Add Zig to your path</p> </li> <li> <p>linux, macos, bsd</p> <p>Add the location of your Zig binary to your <code>PATH</code> environment variable. For an installation, add <code>export PATH=$PATH:~/zig</code> or similar to your <code>/etc/profile</code> (system-wide) or <code>$HOME/.profile</code>. If these changes do not apply immediately, run the line from your shell.    - windows</p> <p>a) System wide (admin powershell)</p> <pre><code>[Environment]::SetEnvironmentVariable(\n   \"Path\",\n   [Environment]::GetEnvironmentVariable(\"Path\", \"Machine\") + \";C:\\your-path\\zig-windows-x86_64-your-version\",\n   \"Machine\"\n)\n</code></pre> <p>b) User level (powershell)</p> <pre><code>[Environment]::SetEnvironmentVariable(\n   \"Path\",\n   [Environment]::GetEnvironmentVariable(\"Path\", \"User\") + \";C:\\your-path\\zig-windows-x86_64-your-version\",\n   \"User\"\n)\n</code></pre> <p>Close your terminal and create a new one.</p> </li> <li> <p>Verify your install with <code>zig version</code>. The output should look something like <pre><code>$ zig version\n0.11.0-dev.2777+b95cdf0ae\n</code></pre></p> </li> <li> <p>(optional, third party) For completions and go-to-definition in your editor, install the Zig Language Server from https://github.com/zigtools/zls/.</p> </li> <li> <p>(optional) Join a Zig community.</p> </li> </ol>"},{"location":"#hello-world","title":"Hello World","text":"<p>Create a file called <code>main.zig</code>, with the following contents:</p> <pre><code>const std = @import(\"std\");\n\npub fn main() void {\nstd.debug.print(\"Hello, {s}!\\n\", .{\"World\"});\n}\n</code></pre> <p>note: make sure your file is encoded via UTF-8 encoding!</p> <p>note: If you are using tabs for indentation and/or CRLF line endings in your file, Zig compiler will accept it, but using <code>zig fmt</code> will canonicalize them to spaces and LF line endings!</p> <p>Use <code>zig run main.zig</code> to build and run it. In this example <code>Hello, World!</code> will be written to stderr, and is assumed to never fail.</p>"},{"location":"chapter-1/","title":"Chapter 1 - Basics","text":""},{"location":"chapter-1/#assignment","title":"Assignment","text":"<p>Value assignment has the following syntax: <code>(const|var) identifier[: type] = value</code>.</p> <ul> <li><code>const</code> indicates that <code>identifier</code> is a constant that stores an immutable value.</li> <li><code>var</code> indicates that <code>identifier</code> is a variable that stores a mutable value.</li> <li><code>: type</code> is a type annotation for <code>identifier</code>, and may be omitted if the data type of <code>value</code> can be inferred.</li> </ul> <pre><code>const constant: i32 = 5; // signed 32-bit constant\nvar variable: u32 = 5000; // unsigned 32-bit variable\n\n// @as performs an explicit type coercion\nconst inferred_constant = @as(i32, 5);\nvar inferred_variable = @as(u32, 5000);\n</code></pre> <p>Constants and variables must have a value. If no known value can be given, the <code>undefined</code> value, which coerces to any type, may be used as long as a type annotation is provided.</p> <pre><code>const a: i32 = undefined;\nvar b: u32 = undefined;\n</code></pre> <p>Where possible, <code>const</code> values are preferred over <code>var</code> values.</p>"},{"location":"chapter-1/#arrays-nt","title":"Arrays [N]T","text":"<p>Arrays are denoted by <code>[N]T</code>, where <code>N</code> is the number of elements in the array and <code>T</code> is the type of those elements (i.e., the array's child type).</p> <p>For array literals, <code>N</code> may be replaced by <code>_</code> to infer the size of the array.</p> <pre><code>const a = [5]u8{ 'h', 'e', 'l', 'l', 'o' };\nconst b = [_]u8{ 'w', 'o', 'r', 'l', 'd' };\n</code></pre> <p>To get the size of an array, simply access the array's <code>len</code> field.</p> <pre><code>const array = [_]u8{ 'h', 'e', 'l', 'l', 'o' };\nconst length = array.len; // 5\n</code></pre>"},{"location":"chapter-1/#if","title":"If","text":"<p>Zig's basic if statement is simple in that it only accepts a <code>bool</code> value (of values <code>true</code> or <code>false</code>). There is no concept of truthy or falsy values.</p> <p>Here we will introduce testing. Save the below code and compile + run it with <code>zig test file-name.zig</code>. We will be using the <code>expect</code> function from the standard library, which will cause the test to fail if it's given the value <code>false</code>. When a test fails, the error and stack trace will be shown.</p> <pre><code>const expect = @import(\"std\").testing.expect;\n\ntest \"if statement\" {\nconst a = true;\nvar x: u16 = 0;\nif (a) {\nx += 1;\n} else {\nx += 2;\n}\ntry expect(x == 1);\n}\n</code></pre> <p>If statements also work as expressions.</p> <pre><code>test \"if statement expression\" {\nconst a = true;\nvar x: u16 = 0;\nx += if (a) 1 else 2;\ntry expect(x == 1);\n}\n</code></pre>"},{"location":"chapter-1/#while","title":"While","text":"<p>Zig's while loop has three parts - a condition, a block and a continue expression.</p> <p>Without a continue expression. <pre><code>test \"while\" {\nvar i: u8 = 2;\nwhile (i &lt; 100) {\ni *= 2;\n}\ntry expect(i == 128);\n}\n</code></pre></p> <p>With a continue expression. <pre><code>test \"while with continue expression\" {\nvar sum: u8 = 0;\nvar i: u8 = 1;\nwhile (i &lt;= 10) : (i += 1) {\nsum += i;\n}\ntry expect(sum == 55);\n}\n</code></pre></p> <p>With a <code>continue</code>.</p> <pre><code>test \"while with continue\" {\nvar sum: u8 = 0;\nvar i: u8 = 0;\nwhile (i &lt;= 3) : (i += 1) {\nif (i == 2) continue;\nsum += i;\n}\ntry expect(sum == 4);\n}\n</code></pre> <p>With a <code>break</code>.</p> <pre><code>test \"while with break\" {\nvar sum: u8 = 0;\nvar i: u8 = 0;\nwhile (i &lt;= 3) : (i += 1) {\nif (i == 2) break;\nsum += i;\n}\ntry expect(sum == 1);\n}\n</code></pre>"},{"location":"chapter-1/#for","title":"For","text":"<p>For loops are used to iterate over arrays (and other types, to be discussed later). For loops follow this syntax. Like while, for loops can use <code>break</code> and <code>continue</code>. Here we've had to assign values to <code>_</code>, as Zig does not allow us to have unused values.</p> <pre><code>test \"for\" {\n//character literals are equivalent to integer literals\nconst string = [_]u8{ 'a', 'b', 'c' };\n\nfor (string, 0..) |character, index| {\n_ = character;\n_ = index;\n}\n\nfor (string) |character| {\n_ = character;\n}\n\nfor (string, 0..) |_, index| {\n_ = index;\n}\n\nfor (string) |_| {}\n}\n</code></pre>"},{"location":"chapter-1/#functions","title":"Functions","text":"<p>All function arguments are immutable - if a copy is desired the user must explicitly make one. Unlike variables which are snake_case, functions are camelCase. Here's an example of declaring and calling a simple function.</p> <pre><code>fn addFive(x: u32) u32 {\nreturn x + 5;\n}\n\ntest \"function\" {\nconst y = addFive(0);\ntry expect(@TypeOf(y) == u32);\ntry expect(y == 5);\n}\n</code></pre> <p>Recursion is allowed:</p> <p><pre><code>fn fibonacci(n: u16) u16 {\nif (n == 0 or n == 1) return n;\nreturn fibonacci(n - 1) + fibonacci(n - 2);\n}\n\ntest \"function recursion\" {\nconst x = fibonacci(10);\ntry expect(x == 55);\n}\n</code></pre> When recursion happens, the compiler is no longer able to work out the maximum stack size. This may result in unsafe behaviour - a stack overflow. Details on how to achieve safe recursion will be covered in future.</p> <p>Values can be ignored by using <code>_</code> in place of a variable or const declaration. This does not work at the global scope (i.e. it only works inside functions and blocks), and is useful for ignoring the values returned from functions if you do not need them.</p> <pre><code>_ = 10;\n</code></pre>"},{"location":"chapter-1/#defer","title":"Defer","text":"<p>Defer is used to execute a statement while exiting the current block.</p> <pre><code>test \"defer\" {\nvar x: i16 = 5;\n{\ndefer x += 2;\ntry expect(x == 5);\n}\ntry expect(x == 7);\n}\n</code></pre> <p>When there are multiple defers in a single block, they are executed in reverse order.</p> <pre><code>test \"multi defer\" {\nvar x: f32 = 5;\n{\ndefer x += 2;\ndefer x /= 2;\n}\ntry expect(x == 4.5);\n}\n</code></pre>"},{"location":"chapter-1/#errors","title":"Errors","text":"<p>An error set is like an enum (details on Zig's enums later), where each error in the set is a value. There are no exceptions in Zig; errors are values. Let's create an error set.</p> <p><pre><code>const FileOpenError = error{\nAccessDenied,\nOutOfMemory,\nFileNotFound,\n};\n</code></pre> Error sets coerce to their supersets.</p> <pre><code>const AllocationError = error{OutOfMemory};\n\ntest \"coerce error from a subset to a superset\" {\nconst err: FileOpenError = AllocationError.OutOfMemory;\ntry expect(err == FileOpenError.OutOfMemory);\n}\n</code></pre> <p>An error set type and a normal type can be combined with the <code>!</code> operator to form an error union type. Values of these types may be an error value, or a value of the normal type.</p> <p>Let's create a value of an error union type. Here <code>catch</code> is used, which is followed by an expression which is evaluated when the value before it is an error. The catch here is used to provide a fallback value, but could instead be a <code>noreturn</code> - the type of <code>return</code>, <code>while (true)</code> and others.</p> <pre><code>test \"error union\" {\nconst maybe_error: AllocationError!u16 = 10;\nconst no_error = maybe_error catch 0;\n\ntry expect(@TypeOf(no_error) == u16);\ntry expect(no_error == 10);\n}\n</code></pre> <p>Functions often return error unions. Here's one using a catch, where the <code>|err|</code> syntax receives the value of the error. This is called payload capturing, and is used similarly in many places. We'll talk about it in more detail later in the chapter. Side note: some languages use similar syntax for lambdas - this is not the case for Zig.</p> <pre><code>fn failingFunction() error{Oops}!void {\nreturn error.Oops;\n}\n\ntest \"returning an error\" {\nfailingFunction() catch |err| {\ntry expect(err == error.Oops);\nreturn;\n};\n}\n</code></pre> <p><code>try x</code> is a shortcut for <code>x catch |err| return err</code>, and is commonly used in places where handling an error isn't appropriate. Zig's <code>try</code> and <code>catch</code> are unrelated to try-catch in other languages.</p> <pre><code>fn failFn() error{Oops}!i32 {\ntry failingFunction();\nreturn 12;\n}\n\ntest \"try\" {\nvar v = failFn() catch |err| {\ntry expect(err == error.Oops);\nreturn;\n};\ntry expect(v == 12); // is never reached\n}\n</code></pre> <p><code>errdefer</code> works like <code>defer</code>, but only executing when the function is returned from with an error inside of the <code>errdefer</code>'s block.</p> <pre><code>var problems: u32 = 98;\n\nfn failFnCounter() error{Oops}!void {\nerrdefer problems += 1;\ntry failingFunction();\n}\n\ntest \"errdefer\" {\nfailFnCounter() catch |err| {\ntry expect(err == error.Oops);\ntry expect(problems == 99);\nreturn;\n};\n}\n</code></pre> <p>Error unions returned from a function can have their error sets inferred by not having an explicit error set. This inferred error set contains all possible errors which the function may return.</p> <pre><code>fn createFile() !void {\nreturn error.AccessDenied;\n}\n\ntest \"inferred error set\" {\n//type coercion successfully takes place\nconst x: error{AccessDenied}!void = createFile();\n\n//Zig does not let us ignore error unions via _ = x;\n//we must unwrap it with \"try\", \"catch\", or \"if\" by any means\n_ = x catch {};\n}\n</code></pre> <p>Error sets can be merged.</p> <pre><code>const A = error{ NotDir, PathNotFound };\nconst B = error{ OutOfMemory, PathNotFound };\nconst C = A || B;\n</code></pre> <p><code>anyerror</code> is the global error set which due to being the superset of all error sets, can have an error from any set coerce to a value of it. Its usage should be generally avoided.</p>"},{"location":"chapter-1/#switch","title":"Switch","text":"<p>Zig's <code>switch</code> works as both a statement and an expression. The types of all branches must coerce to the type which is being switched upon. All possible values must have an associated branch - values cannot be left out. Cases cannot fall through to other branches.</p> <p>An example of a switch statement. The else is required to satisfy the exhaustiveness of this switch.</p> <pre><code>test \"switch statement\" {\nvar x: i8 = 10;\nswitch (x) {\n-1...1 =&gt; {\nx = -x;\n},\n10, 100 =&gt; {\n//special considerations must be made\n//when dividing signed integers\nx = @divExact(x, 10);\n},\nelse =&gt; {},\n}\ntry expect(x == 1);\n}\n</code></pre> <p>Here is the former, but as a switch expression. <pre><code>test \"switch expression\" {\nvar x: i8 = 10;\nx = switch (x) {\n-1...1 =&gt; -x,\n10, 100 =&gt; @divExact(x, 10),\nelse =&gt; x,\n};\ntry expect(x == 1);\n}\n</code></pre></p>"},{"location":"chapter-1/#runtime-safety","title":"Runtime Safety","text":"<p>Zig provides a level of safety, where problems may be found during execution. Safety can be left on, or turned off. Zig has many cases of so-called detectable illegal behaviour, meaning that illegal behaviour will be caught (causing a panic) with safety on, but will result in undefined behaviour with safety off. Users are strongly recommended to develop and test their software with safety on, despite its speed penalties.</p> <p>For example, runtime safety protects you from out of bounds indices.</p> <p><pre><code>test \"out of bounds\" {\nconst a = [3]u8{ 1, 2, 3 };\nvar index: u8 = 5;\nconst b = a[index];\n_ = b;\n}\n</code></pre> <pre><code>test \"out of bounds\"...index out of bounds\n.\\tests.zig:43:14: 0x7ff698cc1b82 in test \"out of bounds\" (test.obj)\n    const b = a[index];\n             ^\n</code></pre></p> <p>The user may choose to disable runtime safety for the current block by using the built-in function <code>@setRuntimeSafety</code>.</p> <pre><code>test \"out of bounds, no safety\" {\n@setRuntimeSafety(false);\nconst a = [3]u8{ 1, 2, 3 };\nvar index: u8 = 5;\nconst b = a[index];\n_ = b;\n}\n</code></pre> <p>Safety is off for some build modes (to be discussed later).</p>"},{"location":"chapter-1/#unreachable","title":"Unreachable","text":"<p><code>unreachable</code> is an assertion to the compiler that this statement will not be reached. It can be used to tell the compiler that a branch is impossible, which the optimiser can then take advantage of. Reaching an <code>unreachable</code> is detectable illegal behaviour.</p> <p>As it is of the type <code>noreturn</code>, it is compatible with all other types. Here it coerces to u32.</p> <p><pre><code>test \"unreachable\" {\nconst x: i32 = 1;\nconst y: u32 = if (x == 2) 5 else unreachable;\n_ = y;\n}\n</code></pre> <pre><code>test \"unreachable\"...reached unreachable code\n.\\tests.zig:211:39: 0x7ff7e29b2049 in test \"unreachable\" (test.obj)\n    const y: u32 = if (x == 2) 5 else unreachable;\n                                      ^\n</code></pre></p> <p>Here is an unreachable being used in a switch. <pre><code>fn asciiToUpper(x: u8) u8 {\nreturn switch (x) {\n'a'...'z' =&gt; x + 'A' - 'a',\n'A'...'Z' =&gt; x,\nelse =&gt; unreachable,\n};\n}\n\ntest \"unreachable switch\" {\ntry expect(asciiToUpper('a') == 'A');\ntry expect(asciiToUpper('A') == 'A');\n}\n</code></pre></p>"},{"location":"chapter-1/#pointers-t","title":"Pointers <code>*T</code>","text":"<p>Normal pointers in Zig aren't allowed to have 0 or null as a value. They follow the syntax <code>*T</code>, where <code>T</code> is the child type.</p> <p>Referencing is done with <code>&amp;variable</code>, and dereferencing is done with <code>variable.*</code>.</p> <pre><code>fn increment(num: *u8) void {\nnum.* += 1;\n}\n\ntest \"pointers\" {\nvar x: u8 = 1;\nincrement(&amp;x);\ntry expect(x == 2);\n}\n</code></pre> <p>Trying to set a <code>*T</code> to the value 0 is detectable illegal behaviour.</p> <p><pre><code>test \"naughty pointer\" {\nvar x: u16 = 0;\nvar y: *u8 = @intToPtr(*u8, x);\n_ = y;\n}\n</code></pre> <pre><code>test \"naughty pointer\"...cast causes pointer to be null\n.\\tests.zig:241:18: 0x7ff69ebb22bd in test \"naughty pointer\" (test.obj)\n    var y: *u8 = @intToPtr(*u8, x);\n                 ^\n</code></pre></p> <p>Zig also has const pointers, which cannot be used to modify the referenced data. Referencing a const variable will yield a const pointer.</p> <p><pre><code>test \"const pointers\" {\nconst x: u8 = 1;\nvar y = &amp;x;\ny.* += 1;\n}\n</code></pre> <pre><code>error: cannot assign to constant\n    y.* += 1;\n    ~~~~^~~~\n</code></pre></p> <p>A <code>*T</code> coerces to a <code>*const T</code>.</p>"},{"location":"chapter-1/#pointer-sized-integers-usize-and-isize","title":"Pointer sized integers: <code>usize</code> and <code>isize</code>","text":"<p><code>usize</code> and <code>isize</code> are given as unsigned and signed integers which are the same size as pointers.</p> <pre><code>test \"usize\" {\ntry expect(@sizeOf(usize) == @sizeOf(*u8));\ntry expect(@sizeOf(isize) == @sizeOf(*u8));\n}\n</code></pre>"},{"location":"chapter-1/#many-item-pointers-t","title":"Many-Item Pointers <code>[*]T</code>","text":"<p>Sometimes you may have a pointer to an unknown amount of elements. <code>[*]T</code> is the solution for this, which works like <code>*T</code> but also supports indexing syntax, pointer arithmetic, and slicing. Unlike <code>*T</code>, it cannot point to a type which does not have a known size. <code>*T</code> coerces to <code>[*]T</code>.</p> <p>These many pointers may point to any amount of elements, including 0 and 1.</p>"},{"location":"chapter-1/#slices-t","title":"Slices <code>[]T</code>","text":"<p>Slices can be thought of as a pair of <code>[*]T</code> (the pointer to the data) and a <code>usize</code> (the element count). Their syntax is given as <code>[]T</code>, with <code>T</code> being the child type. Slices are used heavily throughout Zig for when you need to operate on arbitrary amounts of data. Slices have the same attributes as pointers, meaning that there also exists const slices. For loops also operate over slices. String literals in Zig coerce to <code>[]const u8</code>.</p> <p>Here, the syntax <code>x[n..m]</code> is used to create a slice from an array. This is called slicing, and creates a slice of the elements starting at <code>x[n]</code> and ending at <code>x[m - 1]</code>. This example uses a const slice as the values which the slice points to do not need to be modified.</p> <pre><code>fn total(values: []const u8) usize {\nvar sum: usize = 0;\nfor (values) |v| sum += v;\nreturn sum;\n}\ntest \"slices\" {\nconst array = [_]u8{ 1, 2, 3, 4, 5 };\nconst slice = array[0..3];\ntry expect(total(slice) == 6);\n}\n</code></pre> <p>When these <code>n</code> and <code>m</code> values are both known at compile time, slicing will actually produce a pointer to an array. This is not an issue as a pointer to an array i.e. <code>*[N]T</code> will coerce to a <code>[]T</code>.</p> <pre><code>test \"slices 2\" {\nconst array = [_]u8{ 1, 2, 3, 4, 5 };\nconst slice = array[0..3];\ntry expect(@TypeOf(slice) == *const [3]u8);\n}\n</code></pre> <p>The syntax <code>x[n..]</code> can also be used for when you want to slice to the end.</p> <pre><code>test \"slices 3\" {\nvar array = [_]u8{ 1, 2, 3, 4, 5 };\nvar slice = array[0..];\n_ = slice;\n}\n</code></pre> <p>Types that may be sliced are: arrays, many pointers and slices.</p>"},{"location":"chapter-1/#enums","title":"Enums","text":"<p>Zig's enums allow you to define types which have a restricted set of named values.</p> <p>Let's declare an enum. <pre><code>const Direction = enum { north, south, east, west };\n</code></pre></p> <p>Enums types may have specified (integer) tag types. <pre><code>const Value = enum(u2) { zero, one, two };\n</code></pre></p> <p>Enum's ordinal values start at 0. They can be accessed with the built-in function <code>@intFromEnum</code>. <pre><code>test \"enum ordinal value\" {\ntry expect(@intFromEnum(Value.zero) == 0);\ntry expect(@intFromEnum(Value.one) == 1);\ntry expect(@intFromEnum(Value.two) == 2);\n}\n</code></pre></p> <p>Values can be overridden, with the next values continuing from there. <pre><code>const Value2 = enum(u32) {\nhundred = 100,\nthousand = 1000,\nmillion = 1000000,\nnext,\n};\n\ntest \"set enum ordinal value\" {\ntry expect(@intFromEnum(Value2.hundred) == 100);\ntry expect(@intFromEnum(Value2.thousand) == 1000);\ntry expect(@intFromEnum(Value2.million) == 1000000);\ntry expect(@intFromEnum(Value2.next) == 1000001);\n}\n</code></pre></p> <p>Methods can be given to enums. These act as namespaced functions that can be called with dot syntax.</p> <pre><code>const Suit = enum {\nclubs,\nspades,\ndiamonds,\nhearts,\npub fn isClubs(self: Suit) bool {\nreturn self == Suit.clubs;\n}\n};\n\ntest \"enum method\" {\ntry expect(Suit.spades.isClubs() == Suit.isClubs(.spades));\n}\n</code></pre> <p>Enums can also be given <code>var</code> and <code>const</code> declarations. These act as namespaced globals, and their values are unrelated and unattached to instances of the enum type.</p> <pre><code>const Mode = enum {\nvar count: u32 = 0;\non,\noff,\n};\n\ntest \"hmm\" {\nMode.count += 1;\ntry expect(Mode.count == 1);\n}\n</code></pre>"},{"location":"chapter-1/#structs","title":"Structs","text":"<p>Structs are Zig's most common kind of composite data type, allowing you to define types that can store a fixed set of named fields. Zig gives no guarantees about the in-memory order of fields in a struct, or its size. Like arrays, structs are also neatly constructed with <code>T{}</code> syntax. Here is an example of declaring and filling a struct. <pre><code>const Vec3 = struct { x: f32, y: f32, z: f32 };\n\ntest \"struct usage\" {\nconst my_vector = Vec3{\n.x = 0,\n.y = 100,\n.z = 50,\n};\n_ = my_vector;\n}\n</code></pre></p> <p>All fields must be given a value.</p> <p><pre><code>test \"missing struct field\" {\nconst my_vector = Vec3{\n.x = 0,\n.z = 50,\n};\n_ = my_vector;\n}\n</code></pre> <pre><code>error: missing field: 'y'\n    const my_vector = Vec3{\n                        ^\n</code></pre></p> <p>Fields may be given defaults: <pre><code>const Vec4 = struct { x: f32, y: f32, z: f32 = 0, w: f32 = undefined };\n\ntest \"struct defaults\" {\nconst my_vector = Vec4{\n.x = 25,\n.y = -50,\n};\n_ = my_vector;\n}\n</code></pre></p> <p>Like enums, structs may also contain functions and declarations.</p> <p>Structs have the unique property that when given a pointer to a struct, one level of dereferencing is done automatically when accessing fields. Notice how in this example, self.x and self.y are accessed in the swap function without needing to dereference the self pointer.</p> <pre><code>const Stuff = struct {\nx: i32,\ny: i32,\nfn swap(self: *Stuff) void {\nconst tmp = self.x;\nself.x = self.y;\nself.y = tmp;\n}\n};\n\ntest \"automatic dereference\" {\nvar thing = Stuff{ .x = 10, .y = 20 };\nthing.swap();\ntry expect(thing.x == 20);\ntry expect(thing.y == 10);\n}\n</code></pre>"},{"location":"chapter-1/#unions","title":"Unions","text":"<p>Zig's unions allow you to define types which store one value of many possible typed fields; only one field may be active at one time.</p> <p>Bare union types do not have a guaranteed memory layout. Because of this, bare unions cannot be used to reinterpret memory. Accessing a field in a union which is not active is detectable illegal behaviour.</p> <p><pre><code>const Result = union {\nint: i64,\nfloat: f64,\nbool: bool,\n};\n\ntest \"simple union\" {\nvar result = Result{ .int = 1234 };\nresult.float = 12.34;\n}\n</code></pre> <pre><code>Test [1/1] test.simple union... thread 6604310 panic: access of union field 'float' while field 'int' is active\n./tests.zig:9:11: 0x10487c807 in test.simple union (test)\n    result.float = 12.34;\n</code></pre></p> <p>Tagged unions are unions which use an enum to detect which field is active. Here we make use of payload capturing again, to switch on the tag type of a union while also capturing the value it contains. Here we use a pointer capture; captured values are immutable, but with the <code>|*value|</code> syntax we can capture a pointer to the values instead of the values themselves. This allows us to use dereferencing to mutate the original value.</p> <pre><code>const Tag = enum { a, b, c };\n\nconst Tagged = union(Tag) { a: u8, b: f32, c: bool };\n\ntest \"switch on tagged union\" {\nvar value = Tagged{ .b = 1.5 };\nswitch (value) {\n.a =&gt; |*byte| byte.* += 1,\n.b =&gt; |*float| float.* *= 2,\n.c =&gt; |*b| b.* = !b.*,\n}\ntry expect(value.b == 3);\n}\n</code></pre> <p>The tag type of a tagged union can also be inferred. This is equivalent to the Tagged type above.</p> <pre><code>const Tagged = union(enum) { a: u8, b: f32, c: bool };\n</code></pre> <p><code>void</code> member types can have their type omitted from the syntax. Here, none is of type <code>void</code>.</p> <pre><code>const Tagged2 = union(enum) { a: u8, b: f32, c: bool, none };\n</code></pre>"},{"location":"chapter-1/#integer-rules","title":"Integer Rules","text":"<p>Zig supports hex, octal and binary integer literals. <pre><code>const decimal_int: i32 = 98222;\nconst hex_int: u8 = 0xff;\nconst another_hex_int: u8 = 0xFF;\nconst octal_int: u16 = 0o755;\nconst binary_int: u8 = 0b11110000;\n</code></pre> Underscores may also be placed between digits as a visual separator. <pre><code>const one_billion: u64 = 1_000_000_000;\nconst binary_mask: u64 = 0b1_1111_1111;\nconst permissions: u64 = 0o7_5_5;\nconst big_address: u64 = 0xFF80_0000_0000_0000;\n</code></pre></p> <p>\"Integer Widening\" is allowed, which means that integers of a type may coerce to an integer of another type, providing that the new type can fit all of the values that the old type can.</p> <pre><code>test \"integer widening\" {\nconst a: u8 = 250;\nconst b: u16 = a;\nconst c: u32 = b;\ntry expect(c == a);\n}\n</code></pre> <p>If you have a value stored in an integer that cannot coerce to the type that you want, <code>@intCast</code> may be used to explicitly convert from one type to the other. If the value given is out of the range of the destination type, this is detectable illegal behaviour.</p> <pre><code>test \"@intCast\" {\nconst x: u64 = 200;\nconst y = @as(u8, @intCast(x));\ntry expect(@TypeOf(y) == u8);\n}\n</code></pre> <p>Integers by default are not allowed to overflow. Overflows are detectable illegal behaviour. Sometimes being able to overflow integers in a well defined manner is wanted behaviour. For this use case, Zig provides overflow operators.</p> Normal Operator Wrapping Operator + +% - -% * *% += +%= -= -%= *= *%= <pre><code>test \"well defined overflow\" {\nvar a: u8 = 255;\na +%= 1;\ntry expect(a == 0);\n}\n</code></pre>"},{"location":"chapter-1/#floats","title":"Floats","text":"<p>Zig's floats are strictly IEEE compliant unless <code>@setFloatMode(.Optimized)</code> is used, which is equivalent to GCC's <code>-ffast-math</code>. Floats coerce to larger float types.</p> <pre><code>test \"float widening\" {\nconst a: f16 = 0;\nconst b: f32 = a;\nconst c: f128 = b;\ntry expect(c == @as(f128, a));\n}\n</code></pre> <p>Floats support multiple kinds of literal. <pre><code>const floating_point: f64 = 123.0E+77;\nconst another_float: f64 = 123.0;\nconst yet_another: f64 = 123.0e+77;\n\nconst hex_floating_point: f64 = 0x103.70p-5;\nconst another_hex_float: f64 = 0x103.70;\nconst yet_another_hex_float: f64 = 0x103.70P-5;\n</code></pre> Underscores may also be placed between digits. <pre><code>const lightspeed: f64 = 299_792_458.000_000;\nconst nanosecond: f64 = 0.000_000_001;\nconst more_hex: f64 = 0x1234_5678.9ABC_CDEFp-10;\n</code></pre></p> <p>Integers and floats may be converted using the built-in functions <code>@floatFromInt</code> and <code>@intFromFloat</code>. <code>@floatFromInt</code> is always safe, whereas <code>@intFromFloat</code> is detectable illegal behaviour if the float value cannot fit in the integer destination type.</p> <pre><code>test \"int-float conversion\" {\nconst a: i32 = 0;\nconst b = @as(f32, @floatFromInt(a));\nconst c = @as(i32, @intFromFloat(b));\ntry expect(c == a);\n}\n</code></pre>"},{"location":"chapter-1/#labelled-blocks-blk","title":"Labelled Blocks <code>:blk {}</code>","text":"<p>Blocks in Zig are expressions and can be given labels, which are used to yield values. Here, we are using a label called blk. Blocks yield values, meaning that they can be used in place of a value. The value of an empty block <code>{}</code> is a value of the type <code>void</code>.</p> <pre><code>test \"labelled blocks\" {\nconst count = blk: {\nvar sum: u32 = 0;\nvar i: u32 = 0;\nwhile (i &lt; 10) : (i += 1) sum += i;\nbreak :blk sum;\n};\ntry expect(count == 45);\ntry expect(@TypeOf(count) == u32);\n}\n</code></pre> <p>This can be seen as being equivalent to C's <code>i++</code>.</p> <pre><code>blk: {\nconst tmp = i;\ni += 1;\nbreak :blk tmp;\n}\n</code></pre>"},{"location":"chapter-1/#labelled-loops","title":"Labelled Loops","text":"<p>Loops can be given labels, allowing you to <code>break</code> and <code>continue</code> to outer loops.</p> <pre><code>test \"nested continue\" {\nvar count: usize = 0;\nouter: for ([_]i32{ 1, 2, 3, 4, 5, 6, 7, 8 }) |_| {\nfor ([_]i32{ 1, 2, 3, 4, 5 }) |_| {\ncount += 1;\ncontinue :outer;\n}\n}\ntry expect(count == 8);\n}\n</code></pre>"},{"location":"chapter-1/#loops-as-expressions","title":"Loops as expressions","text":"<p>Like <code>return</code>, <code>break</code> accepts a value. This can be used to yield a value from a loop. Loops in Zig also have an <code>else</code> branch on loops, which is evaluated when the loop is not exited from with a <code>break</code>.</p> <pre><code>fn rangeHasNumber(begin: usize, end: usize, number: usize) bool {\nvar i = begin;\nreturn while (i &lt; end) : (i += 1) {\nif (i == number) {\nbreak true;\n}\n} else false;\n}\n\ntest \"while loop expression\" {\ntry expect(rangeHasNumber(0, 10, 3));\n}\n</code></pre>"},{"location":"chapter-1/#optionals-t","title":"Optionals <code>?T</code>","text":"<p>Optionals use the syntax <code>?T</code> and are used to store the data <code>null</code>, or a value of type <code>T</code>.</p> <pre><code>test \"optional\" {\nvar found_index: ?usize = null;\nconst data = [_]i32{ 1, 2, 3, 4, 5, 6, 7, 8, 12 };\nfor (data, 0..) |v, i| {\nif (v == 10) found_index = i;\n}\ntry expect(found_index == null);\n}\n</code></pre> <p>Optionals support the <code>orelse</code> expression, which acts when the optional is <code>null</code>. This unwraps the optional to its child type.</p> <pre><code>test \"orelse\" {\nvar a: ?f32 = null;\nvar b = a orelse 0;\ntry expect(b == 0);\ntry expect(@TypeOf(b) == f32);\n}\n</code></pre> <p><code>.?</code> is a shorthand for <code>orelse unreachable</code>. This is used for when you know it is impossible for an optional value to be null, and using this to unwrap a <code>null</code> value is detectable illegal behaviour.</p> <pre><code>test \"orelse unreachable\" {\nconst a: ?f32 = 5;\nconst b = a orelse unreachable;\nconst c = a.?;\ntry expect(b == c);\ntry expect(@TypeOf(c) == f32);\n}\n</code></pre> <p>Payload capturing works in many places for optionals, meaning that in the event that it is non-null we can \"capture\" its non-null value.</p> <p>Here we use an <code>if</code> optional payload capture; a and b are equivalent here. <code>if (b) |value|</code> captures the value of <code>b</code> (in the cases where <code>b</code> is not null), and makes it available as <code>value</code>. As in the union example, the captured value is immutable, but we can still use a pointer capture to modify the value stored in <code>b</code>.</p> <pre><code>test \"if optional payload capture\" {\nconst a: ?i32 = 5;\nif (a != null) {\nconst value = a.?;\n_ = value;\n}\n\nvar b: ?i32 = 5;\nif (b) |*value| {\nvalue.* += 1;\n}\ntry expect(b.? == 6);\n}\n</code></pre> <p>And with <code>while</code>: <pre><code>var numbers_left: u32 = 4;\nfn eventuallyNullSequence() ?u32 {\nif (numbers_left == 0) return null;\nnumbers_left -= 1;\nreturn numbers_left;\n}\n\ntest \"while null capture\" {\nvar sum: u32 = 0;\nwhile (eventuallyNullSequence()) |value| {\nsum += value;\n}\ntry expect(sum == 6); // 3 + 2 + 1\n}\n</code></pre></p> <p>Optional pointer and optional slice types do not take up any extra memory, compared to non-optional ones. This is because internally they use the 0 value of the pointer for <code>null</code>.</p> <p>This is how null pointers in Zig work - they must be unwrapped to a non-optional before dereferencing, which stops null pointer dereferences from happening accidentally.</p>"},{"location":"chapter-1/#comptime","title":"Comptime","text":"<p>Blocks of code may be forcibly executed at compile time using the <code>comptime</code> keyword. In this example, the variables x and y are equivalent.</p> <pre><code>test \"comptime blocks\" {\nvar x = comptime fibonacci(10);\n_ = x;\n\nvar y = comptime blk: {\nbreak :blk fibonacci(10);\n};\n_ = y;\n}\n</code></pre> <p>Integer literals are of the type <code>comptime_int</code>. These are special in that they have no size (they cannot be used at runtime!), and they have arbitrary precision. <code>comptime_int</code> values coerce to any integer type that can hold them. They also coerce to floats. Character literals are of this type.</p> <pre><code>test \"comptime_int\" {\nconst a = 12;\nconst b = a + 10;\n\nconst c: u4 = a;\n_ = c;\nconst d: f32 = b;\n_ = d;\n}\n</code></pre> <p><code>comptime_float</code> is also available, which internally is an <code>f128</code>. These cannot be coerced to integers, even if they hold an integer value.</p> <p>Types in Zig are values of the type <code>type</code>. These are available at compile time. We have previously encountered them by checking <code>@TypeOf</code> and comparing with other types, but we can do more.</p> <pre><code>test \"branching on types\" {\nconst a = 5;\nconst b: if (a &lt; 10) f32 else i32 = 5;\n_ = b;\n}\n</code></pre> <p>Function parameters in Zig can be tagged as being <code>comptime</code>. This means that the value passed to that function parameter must be known at compile time. Let's make a function that returns a type. Notice how this function is PascalCase, as it returns a type.</p> <pre><code>fn Matrix(\ncomptime T: type,\ncomptime width: comptime_int,\ncomptime height: comptime_int,\n) type {\nreturn [height][width]T;\n}\n\ntest \"returning a type\" {\ntry expect(Matrix(f32, 4, 4) == [4][4]f32);\n}\n</code></pre> <p>We can reflect upon types using the built-in <code>@typeInfo</code>, which takes in a <code>type</code> and returns a tagged union. This tagged union type can be found in <code>std.builtin.Type</code> (info on how to make use of imports and std later).</p> <pre><code>fn addSmallInts(comptime T: type, a: T, b: T) T {\nreturn switch (@typeInfo(T)) {\n.ComptimeInt =&gt; a + b,\n.Int =&gt; |info| if (info.bits &lt;= 16)\na + b\nelse\n@compileError(\"ints too large\"),\nelse =&gt; @compileError(\"only ints accepted\"),\n};\n}\n\ntest \"typeinfo switch\" {\nconst x = addSmallInts(u16, 20, 30);\ntry expect(@TypeOf(x) == u16);\ntry expect(x == 50);\n}\n</code></pre> <p>We can use the <code>@Type</code> function to create a type from a <code>@typeInfo</code>.</p> <p>Here anonymous struct syntax is used with <code>.{}</code>, because the <code>T</code> in <code>T{}</code> can be inferred. Anonymous structs will be covered in detail later. In this example we will get a compile error if the <code>Int</code> tag isn't set.</p> <pre><code>fn GetBiggerInt(comptime T: type) type {\nreturn @Type(.{\n.Int = .{\n.bits = @typeInfo(T).Int.bits + 1,\n.signedness = @typeInfo(T).Int.signedness,\n},\n});\n}\n\ntest \"@Type\" {\ntry expect(GetBiggerInt(u8) == u9);\ntry expect(GetBiggerInt(i31) == i32);\n}\n</code></pre> <p>Returning a struct type is how you make generic data structures in Zig. The usage of <code>@This</code> is required here, which gets the type of the innermost struct, union, or enum. Here <code>std.mem.eql</code> is also used which compares two slices.</p> <pre><code>fn Vec(\ncomptime count: comptime_int,\ncomptime T: type,\n) type {\nreturn struct {\ndata: [count]T,\nconst Self = @This();\n\nfn abs(self: Self) Self {\nvar tmp = Self{ .data = undefined };\nfor (self.data, 0..) |elem, i| {\ntmp.data[i] = if (elem &lt; 0)\n-elem\nelse\nelem;\n}\nreturn tmp;\n}\n\nfn init(data: [count]T) Self {\nreturn Self{ .data = data };\n}\n};\n}\n\nconst eql = @import(\"std\").mem.eql;\n\ntest \"generic vector\" {\nconst x = Vec(3, f32).init([_]f32{ 10, -10, 5 });\nconst y = x.abs();\ntry expect(eql(f32, &amp;y.data, &amp;[_]f32{ 10, 10, 5 }));\n}\n</code></pre> <p>The types of function parameters can also be inferred by using <code>anytype</code> in place of a type. <code>@TypeOf</code> can then be used on the parameter.</p> <pre><code>fn plusOne(x: anytype) @TypeOf(x) {\nreturn x + 1;\n}\n\ntest \"inferred function parameter\" {\ntry expect(plusOne(@as(u32, 1)) == 2);\n}\n</code></pre> <p>Comptime also introduces the operators <code>++</code> and <code>**</code> for concatenating and repeating arrays and slices. These operators do not work at runtime.</p> <pre><code>test \"++\" {\nconst x: [4]u8 = undefined;\nconst y = x[0..];\n\nconst a: [6]u8 = undefined;\nconst b = a[0..];\n\nconst new = y ++ b;\ntry expect(new.len == 10);\n}\n\ntest \"**\" {\nconst pattern = [_]u8{ 0xCC, 0xAA };\nconst memory = pattern ** 3;\ntry expect(eql(u8, &amp;memory, &amp;[_]u8{ 0xCC, 0xAA, 0xCC, 0xAA, 0xCC, 0xAA }));\n}\n</code></pre>"},{"location":"chapter-1/#payload-captures-n","title":"Payload Captures <code>|n|</code>","text":"<p>Payload captures use the syntax <code>|value|</code> and appear in many places, some of which we've seen already. Wherever they appear, they are used to \"capture\" the value from something.</p> <p>With if statements and optionals. <pre><code>test \"optional-if\" {\nvar maybe_num: ?usize = 10;\nif (maybe_num) |n| {\ntry expect(@TypeOf(n) == usize);\ntry expect(n == 10);\n} else {\nunreachable;\n}\n}\n</code></pre></p> <p>With if statements and error unions. The else with the error capture is required here. <pre><code>test \"error union if\" {\nvar ent_num: error{UnknownEntity}!u32 = 5;\nif (ent_num) |entity| {\ntry expect(@TypeOf(entity) == u32);\ntry expect(entity == 5);\n} else |err| {\n_ = err catch {};\nunreachable;\n}\n}\n</code></pre></p> <p>With while loops and optionals. This may have an else block. <pre><code>test \"while optional\" {\nvar i: ?u32 = 10;\nwhile (i) |num| : (i.? -= 1) {\ntry expect(@TypeOf(num) == u32);\nif (num == 1) {\ni = null;\nbreak;\n}\n}\ntry expect(i == null);\n}\n</code></pre></p> <p>With while loops and error unions. The else with the error capture is required here.</p> <pre><code>var numbers_left2: u32 = undefined;\n\nfn eventuallyErrorSequence() !u32 {\nreturn if (numbers_left2 == 0) error.ReachedZero else blk: {\nnumbers_left2 -= 1;\nbreak :blk numbers_left2;\n};\n}\n\ntest \"while error union capture\" {\nvar sum: u32 = 0;\nnumbers_left2 = 3;\nwhile (eventuallyErrorSequence()) |value| {\nsum += value;\n} else |err| {\ntry expect(err == error.ReachedZero);\n}\n}\n</code></pre> <p>For loops. <pre><code>test \"for capture\" {\nconst x = [_]i8{ 1, 5, 120, -5 };\nfor (x) |v| try expect(@TypeOf(v) == i8);\n}\n</code></pre></p> <p>Switch cases on tagged unions. <pre><code>const Info = union(enum) {\na: u32,\nb: []const u8,\nc,\nd: u32,\n};\n\ntest \"switch capture\" {\nvar b = Info{ .a = 10 };\nconst x = switch (b) {\n.b =&gt; |str| blk: {\ntry expect(@TypeOf(str) == []const u8);\nbreak :blk 1;\n},\n.c =&gt; 2,\n//if these are of the same type, they\n//may be inside the same capture group\n.a, .d =&gt; |num| blk: {\ntry expect(@TypeOf(num) == u32);\nbreak :blk num * 2;\n},\n};\ntry expect(x == 20);\n}\n</code></pre></p> <p>As we saw in the Union and Optional sections above, values captured with the <code>|val|</code> syntax are immutable (similar to function arguments), but we can use pointer capture to modify the original values. This captures the values as pointers that are themselves still immutable, but because the value is now a pointer, we can modify the original value by dereferencing it:</p> <pre><code>test \"for with pointer capture\" {\nvar data = [_]u8{ 1, 2, 3 };\nfor (&amp;data) |*byte| byte.* += 1;\ntry expect(eql(u8, &amp;data, &amp;[_]u8{ 2, 3, 4 }));\n}\n</code></pre>"},{"location":"chapter-1/#inline-loops","title":"Inline Loops","text":"<p><code>inline</code> loops are unrolled, and allow some things to happen which only work at compile time. Here we use a <code>for</code>, but a <code>while</code> works similarly. <pre><code>test \"inline for\" {\nconst types = [_]type{ i32, f32, u8, bool };\nvar sum: usize = 0;\ninline for (types) |T| sum += @sizeOf(T);\ntry expect(sum == 10);\n}\n</code></pre></p> <p>Using these for performance reasons is inadvisable unless you've tested that explicitly unrolling is faster; the compiler tends to make better decisions here than you.</p>"},{"location":"chapter-1/#opaque","title":"Opaque","text":"<p><code>opaque</code> types in Zig have an unknown (albeit non-zero) size and alignment. Because of this these data types cannot be stored directly. These are used to maintain type safety with pointers to types that we don't have information about.</p> <p><pre><code>const Window = opaque {};\nconst Button = opaque {};\n\nextern fn show_window(*Window) callconv(.C) void;\n\ntest \"opaque\" {\nvar main_window: *Window = undefined;\nshow_window(main_window);\n\nvar ok_button: *Button = undefined;\nshow_window(ok_button);\n}\n</code></pre> <pre><code>tests.zig:11:17: error: expected type '*tests.Window', found '*tests.Button'\n    show_window(ok_button);\n                ^~~~~~~~~\ntests.zig:11:17: note: pointer type child 'tests.Button' cannot cast into pointer type child 'tests.Window'\ntests.zig:2:16: note: opaque declared here\nconst Button = opaque {};\n               ^~~~~~~~~\ntests.zig:1:16: note: opaque declared here\nconst Window = opaque {};\n               ^~~~~~~~~\ntests.zig:4:23: note: parameter type declared here\nextern fn show_window(*Window) callconv(.C) void;\n                      ^~~~~~~\n</code></pre></p> <p>Opaque types may have declarations in their definitions (the same as structs, enums and unions).</p> <pre><code>const Window = opaque {\nfn show(self: *Window) void {\nshow_window(self);\n}\n};\n\nextern fn show_window(*Window) callconv(.C) void;\n\ntest \"opaque with declarations\" {\nvar main_window: *Window = undefined;\nmain_window.show();\n}\n</code></pre> <p>The typical usecase of opaque is to maintain type safety when interoperating with C code that does not expose complete type information.</p>"},{"location":"chapter-1/#anonymous-structs","title":"Anonymous Structs <code>.{}</code>","text":"<p>The struct type may be omitted from a struct literal. These literals may coerce to other struct types.</p> <pre><code>test \"anonymous struct literal\" {\nconst Point = struct { x: i32, y: i32 };\n\nvar pt: Point = .{\n.x = 13,\n.y = 67,\n};\ntry expect(pt.x == 13);\ntry expect(pt.y == 67);\n}\n</code></pre> <p>Anonymous structs may be completely anonymous i.e. without being coerced to another struct type.</p> <pre><code>test \"fully anonymous struct\" {\ntry dump(.{\n.int = @as(u32, 1234),\n.float = @as(f64, 12.34),\n.b = true,\n.s = \"hi\",\n});\n}\n\nfn dump(args: anytype) !void {\ntry expect(args.int == 1234);\ntry expect(args.float == 12.34);\ntry expect(args.b);\ntry expect(args.s[0] == 'h');\ntry expect(args.s[1] == 'i');\n}\n</code></pre> <p>Anonymous structs without field names may be created, and are referred to as tuples. These have many of the properties that arrays do; tuples can be iterated over, indexed, can be used with the <code>++</code> and <code>**</code> operators, and have a len field. Internally, these have numbered field names starting at <code>\"0\"</code>, which may be accessed with the special syntax <code>@\"0\"</code> which acts as an escape for the syntax - things inside <code>@\"\"</code> are always recognised as identifiers.</p> <p>An <code>inline</code> loop must be used to iterate over the tuple here, as the type of each tuple field may differ.</p> <pre><code>test \"tuple\" {\nconst values = .{\n@as(u32, 1234),\n@as(f64, 12.34),\ntrue,\n\"hi\",\n} ++ .{false} ** 2;\ntry expect(values[0] == 1234);\ntry expect(values[4] == false);\ninline for (values, 0..) |v, i| {\nif (i != 2) continue;\ntry expect(v);\n}\ntry expect(values.len == 6);\ntry expect(values.@\"3\"[0] == 'h');\n}\n</code></pre>"},{"location":"chapter-1/#sentinel-termination-ntt-tt-and-tt","title":"Sentinel Termination: <code>[N:t]T</code>, <code>[:t]T</code>, and <code>[*:t]T</code>","text":"<p>Arrays, slices and many pointers may be terminated by a value of their child type. This is known as sentinel termination. These follow the syntax <code>[N:t]T</code>, <code>[:t]T</code>, and <code>[*:t]T</code>, where <code>t</code> is a value of the child type <code>T</code>.</p> <p>An example of a sentinel terminated array. The built-in <code>@bitCast</code> is used to perform an unsafe bitwise type conversion. This shows us that the last element of the array is followed by a 0 byte.</p> <pre><code>test \"sentinel termination\" {\nconst terminated = [3:0]u8{ 3, 2, 1 };\ntry expect(terminated.len == 3);\ntry expect(@as(*const [4]u8, @ptrCast(&amp;terminated))[3] == 0);\n}\n</code></pre> <p>The types of string literals is <code>*const [N:0]u8</code>, where N is the length of the string. This allows string literals to coerce to sentinel terminated slices, and sentinel terminated many pointers. Note: string literals are UTF-8 encoded.</p> <pre><code>test \"string literal\" {\ntry expect(@TypeOf(\"hello\") == *const [5:0]u8);\n}\n</code></pre> <p><code>[*:0]u8</code> and <code>[*:0]const u8</code> perfectly model C's strings.</p> <pre><code>test \"C string\" {\nconst c_string: [*:0]const u8 = \"hello\";\nvar array: [5]u8 = undefined;\n\nvar i: usize = 0;\nwhile (c_string[i] != 0) : (i += 1) {\narray[i] = c_string[i];\n}\n}\n</code></pre> <p>Sentinel terminated types coerce to their non-sentinel-terminated counterparts.</p> <pre><code>test \"coercion\" {\nvar a: [*:0]u8 = undefined;\nconst b: [*]u8 = a;\n_ = b;\n\nvar c: [5:0]u8 = undefined;\nconst d: [5]u8 = c;\n_ = d;\n\nvar e: [:10]f32 = undefined;\nconst f = e;\n_ = f;\n}\n</code></pre> <p>Sentinel terminated slicing is provided which can be used to create a sentinel terminated slice with the syntax <code>x[n..m:t]</code>, where <code>t</code> is the terminator value. Doing this is an assertion from the programmer that the memory is terminated where it should be - getting this wrong is detectable illegal behaviour.</p> <pre><code>test \"sentinel terminated slicing\" {\nvar x = [_:0]u8{255} ** 3;\nconst y = x[0..3 :0];\n_ = y;\n}\n</code></pre>"},{"location":"chapter-1/#vectors","title":"Vectors","text":"<p>Zig provides vector types for SIMD. These are not to be conflated with vectors in a mathematical sense, or vectors like C++'s std::vector (for this, see \"Arraylist\" in chapter 2). Vector types are created with the builtin function @Vector.</p> <p>A vector is a group of booleans, Integers, Floats, or Pointers which are operated on in parallel, using SIMD instructions if possible.</p> <p>Operations between vectors with the same child type and length can take place. These operations are performed on each of the values in the vector.<code>std.meta.eql</code> is used here to check for equality between two vectors (also useful for other types like structs).</p> <pre><code>const meta = @import(\"std\").meta;\n\ntest \"vector add\" {\nconst x: @Vector(4, f32) = .{ 1, -10, 20, -1 };\nconst y: @Vector(4, f32) = .{ 2, 10, 0, 1 };\nconst z = x + y;\ntry expect(meta.eql(z, @Vector(4, f32){ 3, 0, 20, 0 }));\n}\n</code></pre> <p>Vectors are indexable. <pre><code>test \"vector indexing\" {\nconst x: @Vector(4, u8) = .{ 255, 0, 255, 0 };\ntry expect(x[0] == 255);\n}\n</code></pre></p> <p>The built-in function <code>@splat</code> may be used to construct a vector where all of the values are the same. Here we use it to multiply a vector by a scalar.</p> <pre><code>test \"vector * scalar\" {\nconst x: @Vector(3, f32) = .{ 12.5, 37.5, 2.5 };\nconst vec: @Vector(3, f32) = @splat(2);\nconst y = x * vec;\ntry expect(meta.eql(y, @Vector(3, f32){ 25, 75, 5 }));\n}\n</code></pre> <p>Vectors do not have a <code>len</code> field like arrays, but may still be looped over. Here, <code>std.mem.len</code> is used as a shortcut for <code>@typeInfo(@TypeOf(x)).Vector.len</code>.</p> <pre><code>const len = @import(\"std\").mem.len;\n\ntest \"vector looping\" {\nconst x = @Vector(4, u8){ 255, 0, 255, 0 };\nvar sum = blk: {\nvar tmp: u10 = 0;\nvar i: u8 = 0;\nwhile (i &lt; 4) : (i += 1) tmp += x[i];\nbreak :blk tmp;\n};\ntry expect(sum == 510);\n}\n</code></pre> <p>Vectors coerce to their respective arrays.</p> <pre><code>const arr: [4]f32 = @Vector(4, f32){ 1, 2, 3, 4 };\n</code></pre> <p>It is worth noting that using explicit vectors may result in slower software if you do not make the right decisions - the compiler's auto-vectorisation is fairly smart as-is.</p>"},{"location":"chapter-1/#imports","title":"Imports","text":"<p>The built-in function <code>@import</code> takes in a file, and gives you a struct type based on that file. All declarations labelled as <code>pub</code> (for public) will end up in this struct type, ready for use.</p> <p><code>@import(\"std\")</code> is a special case in the compiler, and gives you access to the standard library. Other <code>@import</code>s will take in a file path, or a package name (more on packages in a later chapter).</p> <p>We will explore more of the standard library in later chapters.</p>"},{"location":"chapter-1/#end-of-chapter-1","title":"End Of Chapter 1","text":"<p>In the next chapter we will cover standard patterns, including many useful areas of the standard library.</p> <p>Feedback and PRs are welcome.</p>"},{"location":"chapter-2/","title":"Chapter 2 - Standard Patterns","text":"<p>Automatically generated standard library documentation can be found here. Installing ZLS may also help you explore the standard library, which provides completions for it.</p>"},{"location":"chapter-2/#allocators","title":"Allocators","text":"<p>The Zig standard library provides a pattern for allocating memory, which allows the programmer to choose exactly how memory allocations are done within the standard library - no allocations happen behind your back in the standard library.</p> <p>The most basic allocator is <code>std.heap.page_allocator</code>. Whenever this allocator makes an allocation it will ask your OS for entire pages of memory; an allocation of a single byte will likely reserve multiple kibibytes. As asking the OS for memory requires a system call this is also extremely inefficient for speed.</p> <p>Here, we allocate 100 bytes as a <code>[]u8</code>. Notice how defer is used in conjunction with a free - this is a common pattern for memory management in Zig.</p> <pre><code>const std = @import(\"std\");\nconst expect = std.testing.expect;\n\ntest \"allocation\" {\nconst allocator = std.heap.page_allocator;\n\nconst memory = try allocator.alloc(u8, 100);\ndefer allocator.free(memory);\n\ntry expect(memory.len == 100);\ntry expect(@TypeOf(memory) == []u8);\n}\n</code></pre> <p>The <code>std.heap.FixedBufferAllocator</code> is an allocator that allocates memory into a fixed buffer, and does not make any heap allocations. This is useful when heap usage is not wanted, for example when writing a kernel. It may also be considered for performance reasons. It will give you the error <code>OutOfMemory</code> if it has run out of bytes.</p> <pre><code>test \"fixed buffer allocator\" {\nvar buffer: [1000]u8 = undefined;\nvar fba = std.heap.FixedBufferAllocator.init(&amp;buffer);\nconst allocator = fba.allocator();\n\nconst memory = try allocator.alloc(u8, 100);\ndefer allocator.free(memory);\n\ntry expect(memory.len == 100);\ntry expect(@TypeOf(memory) == []u8);\n}\n</code></pre> <p><code>std.heap.ArenaAllocator</code> takes in a child allocator, and allows you to allocate many times and only free once. Here, <code>.deinit()</code> is called on the arena which frees all memory. Using <code>allocator.free</code> in this example would be a no-op (i.e. does nothing).</p> <pre><code>test \"arena allocator\" {\nvar arena = std.heap.ArenaAllocator.init(std.heap.page_allocator);\ndefer arena.deinit();\nconst allocator = arena.allocator();\n\n_ = try allocator.alloc(u8, 1);\n_ = try allocator.alloc(u8, 10);\n_ = try allocator.alloc(u8, 100);\n}\n</code></pre> <p><code>alloc</code> and <code>free</code> are used for slices. For single items, consider using <code>create</code> and <code>destroy</code>.</p> <pre><code>test \"allocator create/destroy\" {\nconst byte = try std.heap.page_allocator.create(u8);\ndefer std.heap.page_allocator.destroy(byte);\nbyte.* = 128;\n}\n</code></pre> <p>The Zig standard library also has a general purpose allocator. This is a safe allocator which can prevent double-free, use-after-free and can detect leaks. Safety checks and thread safety can be turned off via its configuration struct (left empty below). Zig's GPA is designed for safety over performance, but may still be many times faster than page_allocator.</p> <pre><code>test \"GPA\" {\nvar gpa = std.heap.GeneralPurposeAllocator(.{}){};\nconst allocator = gpa.allocator();\ndefer {\nconst deinit_status = gpa.deinit();\n//fail test; can't try in defer as defer is executed after we return\nif (deinit_status == .leak) expect(false) catch @panic(\"TEST FAIL\");\n}\n\nconst bytes = try allocator.alloc(u8, 100);\ndefer allocator.free(bytes);\n}\n</code></pre> <p>For high performance (but very few safety features!), <code>std.heap.c_allocator</code> may be considered. This however has the disadvantage of requiring linking Libc, which can be done with <code>-lc</code>.</p> <p>Benjamin Feng's talk What's a Memory Allocator Anyway? goes into more detail on this topic, and covers the implementation of allocators.</p>"},{"location":"chapter-2/#arraylist","title":"Arraylist","text":"<p>The <code>std.ArrayList</code> is commonly used throughout Zig, and serves as a buffer which can change in size. <code>std.ArrayList(T)</code> is similar to C++'s <code>std::vector&lt;T&gt;</code> and Rust's <code>Vec&lt;T&gt;</code>. The <code>deinit()</code> method frees all of the ArrayList's memory. The memory can be read from and written to via its slice field - <code>.items</code>.</p> <p>Here we will introduce the usage of the testing allocator. This is a special allocator that only works in tests, and can detect memory leaks. In your code, use whatever allocator is appropriate.</p> <pre><code>const expectEqualSlices = std.testing.expectEqualSlices;\nconst ArrayList = std.ArrayList;\nconst test_allocator = std.testing.allocator;\n\ntest \"arraylist\" {\nvar list = ArrayList(u8).init(test_allocator);\ndefer list.deinit();\ntry list.append('H');\ntry list.append('e');\ntry list.append('l');\ntry list.append('l');\ntry list.append('o');\ntry list.appendSlice(\" World!\");\n\ntry expectEqualSlices(u8, list.items, \"Hello World!\");\n}\n</code></pre>"},{"location":"chapter-2/#filesystem","title":"Filesystem","text":"<p>Let's create and open a file in our current working directory, write to it, and then read from it. Here we have to use <code>.seekTo</code> in order to go back to the start of the file before reading what we have written.</p> <pre><code>test \"createFile, write, seekTo, read\" {\nconst file = try std.fs.cwd().createFile(\n\"junk_file.txt\",\n.{ .read = true },\n);\ndefer file.close();\n\nconst bytes_written = try file.writeAll(\"Hello File!\");\n_ = bytes_written;\n\nvar buffer: [100]u8 = undefined;\ntry file.seekTo(0);\nconst bytes_read = try file.readAll(&amp;buffer);\n\ntry expectEqualSlices(u8, buffer[0..bytes_read], \"Hello File!\");\n}\n</code></pre> <p>The functions <code>std.fs.openFileAbsolute</code> and similar absolute functions exist, but we will not test them here.</p> <p>We can get various information about files by using <code>.stat()</code> on them. <code>Stat</code> also contains fields for .inode and .mode, but they are not tested here as they rely on the current OS' types.</p> <pre><code>test \"file stat\" {\nconst file = try std.fs.cwd().createFile(\n\"junk_file2.txt\",\n.{ .read = true },\n);\ndefer file.close();\nconst stat = try file.stat();\ntry expect(stat.size == 0);\ntry expect(stat.kind == .file);\ntry expect(stat.ctime &lt;= std.time.nanoTimestamp());\ntry expect(stat.mtime &lt;= std.time.nanoTimestamp());\ntry expect(stat.atime &lt;= std.time.nanoTimestamp());\n}\n</code></pre> <p>We can make directories and iterate over their contents. Here we will use an iterator (discussed later). This directory (and its contents) will be deleted after this test finishes.</p> <pre><code>test \"make dir\" {\ntry std.fs.cwd().makeDir(\"test-tmp\");\nconst iter_dir = try std.fs.cwd().openIterableDir(\n\"test-tmp\",\n.{},\n);\ndefer {\nstd.fs.cwd().deleteTree(\"test-tmp\") catch unreachable;\n}\n\n_ = try iter_dir.dir.createFile(\"x\", .{});\n_ = try iter_dir.dir.createFile(\"y\", .{});\n_ = try iter_dir.dir.createFile(\"z\", .{});\n\nvar file_count: usize = 0;\nvar iter = iter_dir.iterate();\nwhile (try iter.next()) |entry| {\nif (entry.kind == .file) file_count += 1;\n}\n\ntry expect(file_count == 3);\n}\n</code></pre>"},{"location":"chapter-2/#readers-and-writers","title":"Readers and Writers","text":"<p><code>std.io.Writer</code> and <code>std.io.Reader</code> provide standard ways of making use of IO. <code>std.ArrayList(u8)</code> has a <code>writer</code> method which gives us a writer. Let's use it.</p> <pre><code>test \"io writer usage\" {\nvar list = ArrayList(u8).init(test_allocator);\ndefer list.deinit();\nconst bytes_written = try list.writer().write(\n\"Hello World!\",\n);\ntry expect(bytes_written == 12);\ntry expectEqualSlices(u8, list.items, \"Hello World!\");\n}\n</code></pre> <p>Here we will use a reader to copy the file's contents into an allocated buffer. The second argument of <code>readAllAlloc</code> is the maximum size that it may allocate; if the file is larger than this, it will return <code>error.StreamTooLong</code>.</p> <pre><code>test \"io reader usage\" {\nconst message = \"Hello File!\";\n\nconst file = try std.fs.cwd().createFile(\n\"junk_file2.txt\",\n.{ .read = true },\n);\ndefer file.close();\n\ntry file.writeAll(message);\ntry file.seekTo(0);\n\nconst contents = try file.reader().readAllAlloc(\ntest_allocator,\nmessage.len,\n);\ndefer test_allocator.free(contents);\n\ntry expectEqualSlices(u8, contents, message);\n}\n</code></pre> <p>A common usecase for readers is to read until the next line (e.g. for user input). Here we will do this with the <code>std.io.getStdIn()</code> file.</p> <pre><code>fn nextLine(reader: anytype, buffer: []u8) !?[]const u8 {\nvar line = (try reader.readUntilDelimiterOrEof(\nbuffer,\n'\\n',\n)) orelse return null;\n// trim annoying windows-only carriage return character\nif (@import(\"builtin\").os.tag == .windows) {\nreturn std.mem.trimRight(u8, line, \"\\r\");\n} else {\nreturn line;\n}\n}\n\ntest \"read until next line\" {\nconst stdout = std.io.getStdOut();\nconst stdin = std.io.getStdIn();\n\ntry stdout.writeAll(\n\\\\ Enter your name:\n);\n\nvar buffer: [100]u8 = undefined;\nconst input = (try nextLine(stdin.reader(), &amp;buffer)).?;\ntry stdout.writer().print(\n\"Your name is: \\\"{s}\\\"\\n\",\n.{input},\n);\n}\n</code></pre> <p>An <code>std.io.Writer</code> type consists of a context type, error set, and a write function. The write function must take in the context type and a byte slice. The write function must also return an error union of the Writer type's error set and the amount of bytes written. Let's create a type that implements a writer.</p> <pre><code>// Don't create a type like this! Use an\n// arraylist with a fixed buffer allocator\nconst MyByteList = struct {\ndata: [100]u8 = undefined,\nitems: []u8 = &amp;[_]u8{},\n\nconst Writer = std.io.Writer(\n*MyByteList,\nerror{EndOfBuffer},\nappendWrite,\n);\n\nfn appendWrite(\nself: *MyByteList,\ndata: []const u8,\n) error{EndOfBuffer}!usize {\nif (self.items.len + data.len &gt; self.data.len) {\nreturn error.EndOfBuffer;\n}\nstd.mem.copy(\nu8,\nself.data[self.items.len..],\ndata,\n);\nself.items = self.data[0 .. self.items.len + data.len];\nreturn data.len;\n}\n\nfn writer(self: *MyByteList) Writer {\nreturn .{ .context = self };\n}\n};\n\ntest \"custom writer\" {\nvar bytes = MyByteList{};\n_ = try bytes.writer().write(\"Hello\");\n_ = try bytes.writer().write(\" Writer!\");\ntry expectEqualSlices(u8, bytes.items, \"Hello Writer!\");\n}\n</code></pre>"},{"location":"chapter-2/#formatting","title":"Formatting","text":"<p><code>std.fmt</code> provides ways to format data to and from strings.</p> <p>A basic example of creating a formatted string. The format string must be compile time known. The <code>d</code> here denotes that we want a decimal number.</p> <pre><code>test \"fmt\" {\nconst string = try std.fmt.allocPrint(\ntest_allocator,\n\"{d} + {d} = {d}\",\n.{ 9, 10, 19 },\n);\ndefer test_allocator.free(string);\n\ntry expectEqualSlices(u8, string, \"9 + 10 = 19\");\n}\n</code></pre> <p>Writers conveniently have a <code>print</code> method, which works similarly.</p> <pre><code>test \"print\" {\nvar list = std.ArrayList(u8).init(test_allocator);\ndefer list.deinit();\ntry list.writer().print(\n\"{} + {} = {}\",\n.{ 9, 10, 19 },\n);\ntry expectEqualSlices(u8, list.items, \"9 + 10 = 19\");\n}\n</code></pre> <p>Take a moment to appreciate that you now know from top to bottom how printing hello world works. <code>std.debug.print</code> works the same, except it writes to stderr and is protected by a mutex.</p> <pre><code>test \"hello world\" {\nconst out_file = std.io.getStdOut();\ntry out_file.writer().print(\n\"Hello, {s}!\\n\",\n.{\"World\"},\n);\n}\n</code></pre> <p>We have used the <code>{s}</code> format specifier up until this point to print strings. Here we will use <code>{any}</code>, which gives us the default formatting.</p> <pre><code>test \"array printing\" {\nconst string = try std.fmt.allocPrint(\ntest_allocator,\n\"{any} + {any} = {any}\",\n.{\n@as([]const u8, &amp;[_]u8{ 1, 4 }),\n@as([]const u8, &amp;[_]u8{ 2, 5 }),\n@as([]const u8, &amp;[_]u8{ 3, 9 }),\n},\n);\ndefer test_allocator.free(string);\n\ntry expectEqualSlices(\nu8,\nstring,\n\"{ 1, 4 } + { 2, 5 } = { 3, 9 }\",\n);\n}\n</code></pre> <p>Let's create a type with custom formatting by giving it a <code>format</code> function. This function must be marked as <code>pub</code> so that std.fmt can access it (more on packages later). You may notice the usage of <code>{s}</code> instead of <code>{}</code> - this is the format specifier for strings (more on format specifiers later). This is used here as <code>{}</code> defaults to array printing over string printing.</p> <pre><code>const Person = struct {\nname: []const u8,\nbirth_year: i32,\ndeath_year: ?i32,\npub fn format(\nself: Person,\ncomptime fmt: []const u8,\noptions: std.fmt.FormatOptions,\nwriter: anytype,\n) !void {\n_ = fmt;\n_ = options;\n\ntry writer.print(\"{s} ({}-\", .{\nself.name, self.birth_year,\n});\n\nif (self.death_year) |year| {\ntry writer.print(\"{}\", .{year});\n}\n\ntry writer.writeAll(\")\");\n}\n};\n\ntest \"custom fmt\" {\nconst john = Person{\n.name = \"John Carmack\",\n.birth_year = 1970,\n.death_year = null,\n};\n\nconst john_string = try std.fmt.allocPrint(\ntest_allocator,\n\"{s}\",\n.{john},\n);\ndefer test_allocator.free(john_string);\n\ntry expectEqualSlices(\nu8,\njohn_string,\n\"John Carmack (1970-)\",\n);\n\nconst claude = Person{\n.name = \"Claude Shannon\",\n.birth_year = 1916,\n.death_year = 2001,\n};\n\nconst claude_string = try std.fmt.allocPrint(\ntest_allocator,\n\"{s}\",\n.{claude},\n);\ndefer test_allocator.free(claude_string);\n\ntry expectEqualSlices(\nu8,\nclaude_string,\n\"Claude Shannon (1916-2001)\",\n);\n}\n</code></pre>"},{"location":"chapter-2/#json","title":"JSON","text":"<p>Let's parse a json string into a struct type, using the streaming parser.</p> <pre><code>const Place = struct { lat: f32, long: f32 };\n\ntest \"json parse\" {\nconst parsed = try std.json.parseFromSlice(Place, test_allocator,\n\\\\{ \"lat\": 40.684540, \"long\": -74.401422 }\n, .{});\ndefer parsed.deinit();\nconst x = parsed.value;\n\ntry expect(x.lat == 40.684540);\ntry expect(x.long == -74.401422);\n}\n</code></pre> <p>And using stringify to turn arbitrary data into a string.</p> <pre><code>test \"json stringify\" {\nconst x = Place{\n.lat = 51.997664,\n.long = -0.740687,\n};\n\nvar buf: [100]u8 = undefined;\nvar fba = std.heap.FixedBufferAllocator.init(&amp;buf);\nvar string = std.ArrayList(u8).init(fba.allocator());\ntry std.json.stringify(x, .{}, string.writer());\n\n// TODO: Remove? @dec05eba: You cant compare floating point numbers exactly\ntry expectEqualSlices(u8, string.items,\n\\\\{\"lat\":5.199766540527344e+01,\"long\":-7.406870126724243e-01}\n);\n}\n</code></pre> <p>The json parser requires an allocator for javascript's string, array, and map types. This memory may be freed using <code>std.json.parseFree</code>.</p> <pre><code>test \"json parse with strings\" {\nconst User = struct { name: []u8, age: u16 };\n// TODO: Use leaky?\nconst parsed = try std.json.parseFromSlice(User, test_allocator,\n\\\\{ \"name\": \"Joe\", \"age\": 25 }\n, .{});\ndefer parsed.deinit();\nconst x = parsed.value;\n\ntry expectEqualSlices(u8, x.name, \"Joe\");\ntry expect(x.age == 25);\n}\n</code></pre>"},{"location":"chapter-2/#random-numbers","title":"Random Numbers","text":"<p>Here we create a new prng using a 64 bit random seed. a, b, c, and d are given random values via this prng. The expressions giving c and d values are equivalent. <code>DefaultPrng</code> is <code>Xoshiro256</code>; there are other prngs available in std.rand.</p> <pre><code>test \"random numbers\" {\nvar prng = std.rand.DefaultPrng.init(blk: {\nvar seed: u64 = undefined;\ntry std.os.getrandom(std.mem.asBytes(&amp;seed));\nbreak :blk seed;\n});\nconst rand = prng.random();\n\nconst a = rand.float(f32);\nconst b = rand.boolean();\nconst c = rand.int(u8);\nconst d = rand.intRangeAtMost(u8, 0, 255);\n\n//suppress unused constant compile error\n_ = .{ a, b, c, d };\n}\n</code></pre> <p>Cryptographically secure random is also available.</p> <pre><code>test \"crypto random numbers\" {\nconst rand = std.crypto.random;\n\nconst a = rand.float(f32);\nconst b = rand.boolean();\nconst c = rand.int(u8);\nconst d = rand.intRangeAtMost(u8, 0, 255);\n\n//suppress unused constant compile error\n_ = .{ a, b, c, d };\n}\n</code></pre>"},{"location":"chapter-2/#crypto","title":"Crypto","text":"<p><code>std.crypto</code> includes many cryptographic utilities, including: -  AES (Aes128, Aes256) -  Diffie-Hellman key exchange (x25519) -  Elliptic-curve arithmetic (curve25519, edwards25519, ristretto255) -  Crypto secure hashing (blake2, Blake3, Gimli, Md5, sha1, sha2, sha3) -  MAC functions (Ghash, Poly1305) -  Stream ciphers (ChaCha20IETF, ChaCha20With64BitNonce, XChaCha20IETF, Salsa20, XSalsa20)</p> <p>This list is inexhaustive. For more in-depth information, try A tour of std.crypto in Zig 0.7.0 - Frank Denis.</p>"},{"location":"chapter-2/#threads","title":"Threads","text":"<p>While Zig provides more advanced ways of writing concurrent and parallel code, <code>std.Thread</code> is available for making use of OS threads. Let's make use of an OS thread.</p> <pre><code>fn ticker(step: u8) void {\nwhile (true) {\nstd.time.sleep(1 * std.time.ns_per_s);\ntick += @as(isize, step);\n}\n}\n\nvar tick: isize = 0;\n\ntest \"threading\" {\nvar thread = try std.Thread.spawn(.{}, ticker, .{@as(u8, 1)});\n_ = thread;\ntry expect(tick == 0);\nstd.time.sleep(3 * std.time.ns_per_s / 2);\ntry expect(tick == 1);\n}\n</code></pre> <p>Threads, however, aren't particularly useful without strategies for thread safety.</p>"},{"location":"chapter-2/#hash-maps","title":"Hash Maps","text":"<p>The standard library provides <code>std.AutoHashMap</code>, which lets you easily create a hash map type from a key type and a value type. These must be initiated with an allocator.</p> <p>Let's put some values in a hash map.</p> <pre><code>test \"hashing\" {\nconst Point = struct { x: i32, y: i32 };\n\nvar map = std.AutoHashMap(u32, Point).init(\ntest_allocator,\n);\ndefer map.deinit();\n\ntry map.put(1525, .{ .x = 1, .y = -4 });\ntry map.put(1550, .{ .x = 2, .y = -3 });\ntry map.put(1575, .{ .x = 3, .y = -2 });\ntry map.put(1600, .{ .x = 4, .y = -1 });\n\ntry expect(map.count() == 4);\n\nvar sum = Point{ .x = 0, .y = 0 };\nvar iterator = map.iterator();\n\nwhile (iterator.next()) |entry| {\nsum.x += entry.value_ptr.x;\nsum.y += entry.value_ptr.y;\n}\n\ntry expect(sum.x == 10);\ntry expect(sum.y == -10);\n}\n</code></pre> <p><code>.fetchPut</code> puts a value in the hash map, returning a value if there was previously a value for that key.</p> <pre><code>test \"fetchPut\" {\nvar map = std.AutoHashMap(u8, f32).init(\ntest_allocator,\n);\ndefer map.deinit();\n\ntry map.put(255, 10);\nconst old = try map.fetchPut(255, 100);\n\ntry expect(old.?.value == 10);\ntry expect(map.get(255).? == 100);\n}\n</code></pre> <p><code>std.StringHashMap</code> is also provided for when you need strings as keys.</p> <pre><code>test \"string hashmap\" {\nvar map = std.StringHashMap(enum { cool, uncool }).init(\ntest_allocator,\n);\ndefer map.deinit();\n\ntry map.put(\"loris\", .uncool);\ntry map.put(\"me\", .cool);\n\ntry expect(map.get(\"me\").? == .cool);\ntry expect(map.get(\"loris\").? == .uncool);\n}\n</code></pre> <p><code>std.StringHashMap</code> and <code>std.AutoHashMap</code> are just wrappers for <code>std.HashMap</code>. If these two do not fulfil your needs, using <code>std.HashMap</code> directly gives you much more control.</p> <p>If having your elements backed by an array is wanted behaviour, try <code>std.ArrayHashMap</code> and its wrapper <code>std.AutoArrayHashMap</code>.</p>"},{"location":"chapter-2/#stacks","title":"Stacks","text":"<p><code>std.ArrayList</code> provides the methods necessary to use it as a stack. Here's an example of creating a list of matched brackets.</p> <pre><code>test \"stack\" {\nconst string = \"(()())\";\nvar stack = std.ArrayList(usize).init(\ntest_allocator,\n);\ndefer stack.deinit();\n\nconst Pair = struct { open: usize, close: usize };\nvar pairs = std.ArrayList(Pair).init(\ntest_allocator,\n);\ndefer pairs.deinit();\n\nfor (string, 0..) |char, i| {\nif (char == '(') try stack.append(i);\nif (char == ')')\ntry pairs.append(.{\n.open = stack.pop(),\n.close = i,\n});\n}\n\nfor (pairs.items, 0..) |pair, i| {\ntry expect(std.meta.eql(pair, switch (i) {\n0 =&gt; Pair{ .open = 1, .close = 2 },\n1 =&gt; Pair{ .open = 3, .close = 4 },\n2 =&gt; Pair{ .open = 0, .close = 5 },\nelse =&gt; unreachable,\n}));\n}\n}\n</code></pre>"},{"location":"chapter-2/#sorting","title":"Sorting","text":"<p>The standard library provides utilities for in-place sorting slices. Its basic usage is as follows.</p> <pre><code>test \"sorting\" {\nvar data = [_]u8{ 10, 240, 0, 0, 10, 5 };\nstd.mem.sort(u8, &amp;data, {}, comptime std.sort.asc(u8));\ntry expectEqualSlices(u8, &amp;data, &amp;[_]u8{ 0, 0, 5, 10, 10, 240 });\nstd.mem.sort(u8, &amp;data, {}, comptime std.sort.desc(u8));\ntry expectEqualSlices(u8, &amp;data, &amp;[_]u8{ 240, 10, 10, 5, 0, 0 });\n}\n</code></pre> <p><code>std.sort.asc</code> and <code>.desc</code> create a comparison function for the given type at comptime; if non-numerical types should be sorted, the user must provide their own comparison function.</p> <p><code>std.mem.sort</code> has a best case of O(n), and an average and worst case of O(n*log(n)).</p>"},{"location":"chapter-2/#iterators","title":"Iterators","text":"<p>It is a common idiom to have a struct type with a <code>next</code> function with an optional in its return type, so that the function may return a null to indicate that iteration is finished.</p> <p><code>std.mem.SplitIterator</code> (and the subtly different <code>std.mem.TokenIterator</code>) is an example of this pattern. <pre><code>test \"split iterator\" {\nconst text = \"robust, optimal, reusable, maintainable, \";\nvar iter = std.mem.split(u8, text, \", \");\ntry expectEqualSlices(u8, iter.next().?, \"robust\");\ntry expectEqualSlices(u8, iter.next().?, \"optimal\");\ntry expectEqualSlices(u8, iter.next().?, \"reusable\");\ntry expectEqualSlices(u8, iter.next().?, \"maintainable\");\ntry expectEqualSlices(u8, iter.next().?, \"\");\ntry expect(iter.next() == null);\n}\n</code></pre></p> <p>Some iterators have a <code>!?T</code> return type, as opposed to ?T. <code>!?T</code> requires that we unpack the error union before the optional, meaning that the work done to get to the next iteration may error. Here is an example of doing this with a loop. <code>cwd</code> has to be opened with iterate permissions in order for the directory iterator to work.</p> <pre><code>test \"iterator looping\" {\nvar iter = (try std.fs.cwd().openIterableDir(\n\".\",\n.{},\n)).iterate();\n\nvar file_count: usize = 0;\nwhile (try iter.next()) |entry| {\nif (entry.kind == .file) file_count += 1;\n}\n\ntry expect(file_count &gt; 0);\n}\n</code></pre> <p>Here we will implement a custom iterator. This will iterate over a slice of strings, yielding the strings which contain a given string.</p> <pre><code>const ContainsIterator = struct {\nstrings: []const []const u8,\nneedle: []const u8,\nindex: usize = 0,\nfn next(self: *ContainsIterator) ?[]const u8 {\nconst index = self.index;\nfor (self.strings[index..]) |string| {\nself.index += 1;\nif (std.mem.indexOf(u8, string, self.needle)) |_| {\nreturn string;\n}\n}\nreturn null;\n}\n};\n\ntest \"custom iterator\" {\nvar iter = ContainsIterator{\n.strings = &amp;[_][]const u8{ \"one\", \"two\", \"three\" },\n.needle = \"e\",\n};\n\ntry expectEqualSlices(u8, iter.next().?, \"one\");\ntry expectEqualSlices(u8, iter.next().?, \"three\");\ntry expect(iter.next() == null);\n}\n</code></pre>"},{"location":"chapter-2/#formatting-specifiers","title":"Formatting specifiers","text":"<p><code>std.fmt</code> provides options for formatting various data types.</p> <p><code>std.fmt.fmtSliceHexLower</code> and <code>std.fmt.fmtSliceHexUpper</code> provide hex formatting for strings as well as <code>{x}</code> and <code>{X}</code> for ints. <pre><code>const bufPrint = std.fmt.bufPrint;\n\ntest \"hex\" {\nvar b: [8]u8 = undefined;\n\n_ = try bufPrint(&amp;b, \"{X}\", .{4294967294});\ntry expectEqualSlices(u8, &amp;b, \"FFFFFFFE\");\n\n_ = try bufPrint(&amp;b, \"{x}\", .{4294967294});\ntry expectEqualSlices(u8, &amp;b, \"fffffffe\");\n\n_ = try bufPrint(&amp;b, \"{}\", .{std.fmt.fmtSliceHexLower(\"Zig!\")});\ntry expectEqualSlices(u8, &amp;b, \"5a696721\");\n}\n</code></pre></p> <p><code>{d}</code> performs decimal formatting for numeric types.</p> <pre><code>test \"decimal float\" {\nvar b: [4]u8 = undefined;\ntry expectEqualSlices(\nu8,\ntry bufPrint(&amp;b, \"{d}\", .{16.5}),\n\"16.5\",\n);\n}\n</code></pre> <p><code>{c}</code> formats a byte into an ascii character. <pre><code>test \"ascii fmt\" {\nvar b: [1]u8 = undefined;\n_ = try bufPrint(&amp;b, \"{c}\", .{66});\ntry expectEqualSlices(u8, &amp;b, \"B\");\n}\n</code></pre></p> <p><code>std.fmt.fmtIntSizeDec</code> and <code>std.fmt.fmtIntSizeBin</code> output memory sizes in metric (1000) and power-of-two (1024) based notation.</p> <pre><code>test \"B Bi\" {\nvar b: [32]u8 = undefined;\n\ntry expectEqualSlices(u8, try bufPrint(&amp;b, \"{}\", .{std.fmt.fmtIntSizeDec(1)}), \"1B\");\ntry expectEqualSlices(u8, try bufPrint(&amp;b, \"{}\", .{std.fmt.fmtIntSizeBin(1)}), \"1B\");\n\ntry expectEqualSlices(u8, try bufPrint(&amp;b, \"{}\", .{std.fmt.fmtIntSizeDec(1024)}), \"1.024kB\");\ntry expectEqualSlices(u8, try bufPrint(&amp;b, \"{}\", .{std.fmt.fmtIntSizeBin(1024)}), \"1KiB\");\n\ntry expectEqualSlices(\nu8,\ntry bufPrint(&amp;b, \"{}\", .{std.fmt.fmtIntSizeDec(1024 * 1024 * 1024)}),\n\"1.073741824GB\",\n);\ntry expectEqualSlices(\nu8,\ntry bufPrint(&amp;b, \"{}\", .{std.fmt.fmtIntSizeBin(1024 * 1024 * 1024)}),\n\"1GiB\",\n);\n}\n</code></pre> <p><code>{b}</code> and <code>{o}</code> output integers in binary and octal format.</p> <pre><code>test \"binary, octal fmt\" {\nvar b: [8]u8 = undefined;\n\ntry expectEqualSlices(\nu8,\ntry bufPrint(&amp;b, \"{b}\", .{254}),\n\"11111110\",\n);\n\ntry expectEqualSlices(\nu8,\ntry bufPrint(&amp;b, \"{o}\", .{254}),\n\"376\",\n);\n}\n</code></pre> <p><code>{*}</code> performs pointer formatting, printing the address rather than the value. <pre><code>test \"pointer fmt\" {\nvar b: [16]u8 = undefined;\ntry expectEqualSlices(\nu8,\ntry bufPrint(&amp;b, \"{*}\", .{@as(*u8, @ptrFromInt(0xDEADBEEF))}),\n\"u8@deadbeef\",\n);\n}\n</code></pre></p> <p><code>{e}</code> outputs floats in scientific notation. <pre><code>test \"scientific\" {\nvar b: [16]u8 = undefined;\n\ntry expectEqualSlices(\nu8,\ntry bufPrint(&amp;b, \"{e}\", .{3.14159}),\n\"3.14159e+00\",\n);\n}\n</code></pre></p> <p><code>{s}</code> outputs strings. <pre><code>test \"string fmt\" {\nvar b: [6]u8 = undefined;\nconst hello: [*:0]const u8 = \"hello!\";\n\ntry expectEqualSlices(\nu8,\ntry bufPrint(&amp;b, \"{s}\", .{hello}),\n\"hello!\",\n);\n}\n</code></pre></p> <p>This list is non-exhaustive.</p>"},{"location":"chapter-2/#advanced-formatting","title":"Advanced Formatting","text":"<p>So far we have only covered formatting specifiers. Format strings actually follow this format, where between each pair of square brackets is a parameter you have to replace with something.</p> <p><code>{[position][specifier]:[fill][alignment][width].[precision]}</code></p> Name Meaning Position The index of the argument that should be inserted Specifier A type-dependent formatting option Fill A single character used for padding Alignment One of three characters '&lt;', '^' or '&gt;'; these are for left, middle and right alignment Width The total width of the field (characters) Precision How many decimals a formatted number should have <p>Position usage. <pre><code>test \"position\" {\nvar b: [3]u8 = undefined;\ntry expectEqualSlices(\nu8,\ntry bufPrint(&amp;b, \"{0s}{0s}{1s}\", .{ \"a\", \"b\" }),\n\"aab\",\n);\n}\n</code></pre></p> <p>Fill, alignment and width being used. <pre><code>test \"fill, alignment, width\" {\nvar b: [6]u8 = undefined;\n\ntry expectEqualSlices(\nu8,\ntry bufPrint(&amp;b, \"{s: &lt;5}\", .{\"hi!\"}),\n\"hi!  \",\n);\n\ntry expectEqualSlices(\nu8,\ntry bufPrint(&amp;b, \"{s:_^6}\", .{\"hi!\"}),\n\"_hi!__\",\n);\n\ntry expectEqualSlices(\nu8,\ntry bufPrint(&amp;b, \"{s:!&gt;4}\", .{\"hi!\"}),\n\"!hi!\",\n);\n}\n</code></pre></p> <p>Using a specifier with precision. <pre><code>test \"precision\" {\nvar b: [4]u8 = undefined;\ntry expectEqualSlices(\nu8,\ntry bufPrint(&amp;b, \"{d:.2}\", .{3.14159}),\n\"3.14\",\n);\n}\n</code></pre></p>"},{"location":"chapter-2/#end-of-chapter-2","title":"End of Chapter 2","text":"<p>This chapter is incomplete. In the future it will contain things such as:</p> <ul> <li>Arbitrary Precision Maths</li> <li>Linked Lists</li> <li>Queues</li> <li>Mutexes</li> <li>Atomics</li> <li>Searching</li> <li>Logging</li> </ul> <p>Feedback and PRs are welcome.</p>"},{"location":"chapter-3/","title":"Chapter 3 - Build system","text":""},{"location":"chapter-3/#build-modes","title":"Build Modes","text":"<p>Zig provides four build modes, with debug being the default as it produces the shortest compile times.</p> Runtime Safety Optimizations Debug Yes No ReleaseSafe Yes Yes, Speed ReleaseSmall No Yes, Size ReleaseFast No Yes, Speed <p>These may be enabled in <code>zig run</code> and <code>zig test</code> with the arguments <code>-O ReleaseSafe</code>, <code>-O ReleaseSmall</code> and <code>-O ReleaseFast</code>.</p> <p>Users are recommended to develop their software with runtime safety enabled, despite its small speed disadvantage.</p>"},{"location":"chapter-3/#outputting-an-executable","title":"Outputting an Executable","text":"<p>The commands <code>zig build-exe</code>, <code>zig build-lib</code>, and <code>zig build-obj</code> can be used to output executables, libraries and objects, respectively. These commands take in a source file and arguments.</p> <p>Some common arguments: - <code>-fsingle-threaded</code>, which asserts the binary is single-threaded. This will turn thread safety measures such as mutexes into no-ops. - <code>-fstrip</code>, which removes debug info from the binary. - <code>--dynamic</code>, which is used in conjunction with <code>zig build-lib</code> to output a dynamic/shared library.</p> <p>Let's create a tiny hello world. Save this as <code>tiny-hello.zig</code>, and run <code>zig build-exe .\\tiny-hello.zig -O ReleaseSmall -fstrip -fsingle-threaded</code>. Currently for <code>x86_64-windows</code>, this produces a 2.5KiB executable.</p> <pre><code>const std = @import(\"std\");\n\npub fn main() void {\nstd.io.getStdOut().writeAll(\n\"Hello World!\",\n) catch unreachable;\n}\n</code></pre>"},{"location":"chapter-3/#cross-compilation","title":"Cross compilation","text":"<p>By default, Zig will compile for your combination of CPU and OS. This can be overridden by <code>-target</code>. Let's compile our tiny hello world to a 64 bit arm linux platform.</p> <p><code>zig build-exe .\\tiny-hello.zig -O ReleaseSmall -fstrip -fsingle-threaded -target aarch64-linux</code></p> <p>QEMU or similar may be used to conveniently test executables made for foreign platforms.</p> <p>Some CPU architectures that you can cross-compile for: - <code>x86_64</code> - <code>arm</code> - <code>aarch64</code> - <code>i386</code> - <code>riscv64</code> - <code>wasm32</code></p> <p>Some operating systems you can cross-compile for: - <code>linux</code> - <code>macos</code> - <code>windows</code> - <code>freebsd</code> - <code>netbsd</code> - <code>dragonfly</code> - <code>UEFI</code></p> <p>Many other targets are available for compilation, but aren't as well tested as of now. See Zig's support table for more information; the list of well tested targets is slowly expanding.</p> <p>As Zig compiles for your specific CPU by default, these binaries may not run on other computers with slightly different CPU architectures. It may be useful to instead specify a specific baseline CPU model for greater compatibility. Note: choosing an older CPU architecture will bring greater compatibility, but means you also miss out on newer CPU instructions; there is an efficiency/speed versus compatibility trade-off here.</p> <p>Let's compile a binary for a sandybridge CPU (Intel x86_64, circa 2011), so we can be reasonably sure that someone with an x86_64 CPU can run our binary. Here we can use <code>native</code> in place of our CPU or OS, to use our system's.</p> <p><code>zig build-exe .\\tiny-hello.zig -target x86_64-native -mcpu sandybridge</code></p> <p>Details on what architectures, OSes, CPUs and ABIs (details on ABIs in the next chapter) are available can be found by running <code>zig targets</code>. Note: the output is long, and you may want to pipe it to a file, e.g. <code>zig targets &gt; targets.json</code>.</p>"},{"location":"chapter-3/#zig-build","title":"Zig Build","text":"<p>The <code>zig build</code> command allows users to compile based on a <code>build.zig</code> file. <code>zig init-exe</code> and <code>zig init-lib</code> can be used to give you a baseline project.</p> <p>Let's use <code>zig init-exe</code> inside a new folder. This is what you will find. <pre><code>.\n\u251c\u2500\u2500 build.zig\n\u2514\u2500\u2500 src\n    \u2514\u2500\u2500 main.zig\n</code></pre> <code>build.zig</code> contains our build script. The build runner will use this <code>pub fn build</code> function as its entry point - this is what is executed when you run <code>zig build</code>.</p> <pre><code>const Builder = @import(\"std\").build.Builder;\n\npub fn build(b: *Builder) void {\n// Standard target options allows the person running `zig build` to choose\n// what target to build for. Here we do not override the defaults, which\n// means any target is allowed, and the default is native. Other options\n// for restricting supported target set are available.\nconst target = b.standardTargetOptions(.{});\n\n// Standard optimization options allow the person running `zig build` to select\n// between Debug, ReleaseSafe, ReleaseFast, and ReleaseSmall. Here we do not\n// set a preferred release mode, allowing the user to decide how to optimize.\nconst optimize = b.standardOptimizeOption(.{});\n\nconst exe = b.addExecutable(.{\n.name = \"init-exe\",\n.root_source_file = .{ .path = \"src/main.zig\" },\n.target = target,\n.optimize = optimize,\n});\n\n// This declares intent for the executable to be installed into the\n// standard location when the user invokes the \"install\" step (the default\n// step when running `zig build`).\nb.installArtifact(exe);\n\nconst run_cmd = exe.run();\nrun_cmd.step.dependOn(b.getInstallStep());\n\nconst run_step = b.step(\"run\", \"Run the app\");\nrun_step.dependOn(&amp;run_cmd.step);\n}\n</code></pre> <p><code>main.zig</code> contains our executable's entry point.</p> <pre><code>const std = @import(\"std\");\n\npub fn main() anyerror!void {\nstd.log.info(\"All your codebase are belong to us.\", .{});\n}\n</code></pre> <p>Upon using the <code>zig build</code> command, the executable will appear in the install path. Here we have not specified an install path, so the executable will be saved in <code>./zig-out/bin</code>.</p>"},{"location":"chapter-3/#builder","title":"Builder","text":"<p>Zig's <code>std.Build</code> type contains the information used by the build runner. This includes information such as:</p> <ul> <li>the build target</li> <li>the release mode</li> <li>locations of libraries</li> <li>the install path</li> <li>build steps</li> </ul>"},{"location":"chapter-3/#compilestep","title":"CompileStep","text":"<p>The <code>std.build.CompileStep</code> type contains information required to build a library, executable, object, or test.</p> <p>Let's make use of our <code>Builder</code> and create a <code>CompileStep</code> using <code>Builder.addExecutable</code>, which takes in a name and a path to the root of the source.</p> <pre><code>const Builder = @import(\"std\").build.Builder;\n\npub fn build(b: *Builder) void {\nconst exe = b.addExecutable(.{\n.name = \"init-exe\",\n.root_source_file = .{ .path = \"src/main.zig\" },\n});\nb.installArtifact(exe);\n}\n</code></pre>"},{"location":"chapter-3/#modules","title":"Modules","text":"<p>The Zig build system has the concept of modules, which are other source files written in Zig. Let's make use of a module.</p> <p>From a new folder, run the following commands. <pre><code>zig init-exe\nmkdir libs\ncd libs\ngit clone https://github.com/Sobeston/table-helper.git\n</code></pre></p> <p>Your directory structure should be as follows.</p> <pre><code>.\n\u251c\u2500\u2500 build.zig\n\u251c\u2500\u2500 libs\n\u2502   \u2514\u2500\u2500 table-helper\n\u2502       \u251c\u2500\u2500 example-test.zig\n\u2502       \u251c\u2500\u2500 README.md\n\u2502       \u251c\u2500\u2500 table-helper.zig\n\u2502       \u2514\u2500\u2500 zig.mod\n\u2514\u2500\u2500 src\n    \u2514\u2500\u2500 main.zig\n</code></pre> <p>To your newly made <code>build.zig</code>, add the following lines.</p> <pre><code>    const table_helper = b.addModule(\"table-helper\", .{\n.source_file = .{ .path = \"libs/table-helper/table-helper.zig\" }\n});\nexe.addModule(\"table-helper\", table_helper);\n</code></pre> <p>Now when run via <code>zig build</code>, <code>@import</code> inside your <code>main.zig</code> will work with the string \"table-helper\". This means that main has the table-helper package. Packages (type <code>std.build.Pkg</code>) also have a field for dependencies of type <code>?[]const Pkg</code>, which is defaulted to null. This allows you to have packages which rely on other packages. </p> <p>Place the following inside your <code>main.zig</code> and run <code>zig build run</code>. </p> <pre><code>const std = @import(\"std\");\nconst Table = @import(\"table-helper\").Table;\n\npub fn main() !void {\ntry std.io.getStdOut().writer().print(\"{}\\n\", .{\nTable(&amp;[_][]const u8{ \"Version\", \"Date\" }){\n.data = &amp;[_][2][]const u8{\n.{ \"0.7.1\", \"2020-12-13\" },\n.{ \"0.7.0\", \"2020-11-08\" },\n.{ \"0.6.0\", \"2020-04-13\" },\n.{ \"0.5.0\", \"2019-09-30\" },\n},\n},\n});\n}\n</code></pre> <p>This should print this table to your console.</p> <pre><code>Version Date       \n------- ---------- \n0.7.1   2020-12-13 \n0.7.0   2020-11-08 \n0.6.0   2020-04-13 \n0.5.0   2019-09-30 \n</code></pre> <p>Zig does not yet have an official package manager. Some unofficial experimental package managers however do exist, namely gyro and zigmod. The <code>table-helper</code> package is designed to support both of them.</p> <p>Some good places to find packages include: astrolabe.pm, zpm, awesome-zig, and the zig tag on GitHub.</p>"},{"location":"chapter-3/#build-steps","title":"Build steps","text":"<p>Build steps are a way of providing tasks for the build runner to  execute. Let's create a build step, and make it the default. When you run <code>zig build</code> this will output <code>Hello!</code>. </p> <pre><code>const std = @import(\"std\");\n\npub fn build(b: *std.build.Builder) void {\nconst step = b.step(\"task\", \"do something\");\nstep.makeFn = myTask;\nb.default_step = step;\n}\n\nfn myTask(self: *std.build.Step, progress: *std.Progress.Node) !void {\nstd.debug.print(\"Hello!\\n\", .{});\n_ = progress;\n_ = self;\n}\n</code></pre> <p>We called <code>b.installArtifact(exe)</code> earlier - this adds a build step which tells the builder to build the executable.</p>"},{"location":"chapter-3/#generating-documentation","title":"Generating Documentation","text":"<p>The Zig compiler comes with automatic documentation generation. This can be invoked by adding <code>-femit-docs</code> to your <code>zig build-{exe, lib, obj}</code> or <code>zig run</code> command. This documentation is saved into <code>./docs</code>, as a small static website.</p> <p>Zig's documentation generation makes use of doc comments which are similar to comments, using <code>///</code> instead of <code>//</code>, and preceding globals.</p> <p>Here we will save this as <code>x.zig</code> and build documentation for it with <code>zig build-lib -femit-docs x.zig -target native-windows</code>. There are some things to take away here: -  Only things that are public with a doc comment will appear -  Blank doc comments may be used -  Doc comments can make use of subset of markdown -  Things will only appear inside generated documentation if the compiler analyses them; you may need to force analysis to happen to get things to appear.</p> <pre><code>const std = @import(\"std\");\nconst w = std.os.windows;\n\n///**Opens a process**, giving you a handle to it. \n///[MSDN](https://docs.microsoft.com/en-us/windows/win32/api/processthreadsapi/nf-processthreadsapi-openprocess)\npub extern \"kernel32\" fn OpenProcess(\n///[The desired process access rights](https://docs.microsoft.com/en-us/windows/win32/procthread/process-security-and-access-rights)\ndwDesiredAccess: w.DWORD,\n///\nbInheritHandle: w.BOOL,\ndwProcessId: w.DWORD,\n) callconv(w.WINAPI) ?w.HANDLE;\n\n///spreadsheet position\npub const Pos = struct{\n///row\nx: u32,\n///column\ny: u32,\n};\n\npub const message = \"hello!\";\n\n//used to force analysis, as these things aren't otherwise referenced.\ncomptime {\n_ = OpenProcess;\n_ = Pos;\n_ = message;\n}\n\n//Alternate method to force analysis of everything automatically, but only in a test build:\ntest \"Force analysis\" {\ncomptime {\nstd.testing.refAllDecls(@This());\n}\n}\n</code></pre> <p>When using a <code>build.zig</code> this may be invoked by setting the <code>emit_docs</code> field to <code>.emit</code> on a <code>CompileStep</code>. We can create a build step to generate docs as follows and invoke it with <code>$ zig build docs</code>.</p> <pre><code>const std = @import(\"std\");\n\npub fn build(b: *std.build.Builder) void {\nconst mode = b.standardReleaseOptions();\n\nconst lib = b.addStaticLibrary(\"x\", \"src/x.zig\");\nlib.setBuildMode(mode);\nlib.install();\n\nconst tests = b.addTest(\"src/x.zig\");\ntests.setBuildMode(mode);\n\nconst test_step = b.step(\"test\", \"Run library tests\");\ntest_step.dependOn(&amp;tests.step);\n\n//Build step to generate docs:\nconst docs = b.addTest(\"src/x.zig\");\ndocs.setBuildMode(mode);\ndocs.emit_docs = .emit;\n\nconst docs_step = b.step(\"docs\", \"Generate docs\");\ndocs_step.dependOn(&amp;docs.step);\n}\n</code></pre> <p>This generation is experimental, and often fails with complex examples. This is used by the standard library documentation.</p> <p>When merging error sets, the left-most error set's documentation strings take priority over the right. In this case, the doc comment for <code>C.PathNotFound</code> is the doc comment provided in <code>A</code>.</p> <pre><code>const A = error{\nNotDir,\n\n/// A doc comment\nPathNotFound,\n};\nconst B = error{\nOutOfMemory,\n\n/// B doc comment\nPathNotFound,\n};\n\nconst C = A || B;\n</code></pre>"},{"location":"chapter-3/#end-of-chapter-3","title":"End of Chapter 3","text":"<p>This chapter is incomplete. In the future it will contain advanced usage of <code>zig build</code>.</p> <p>Feedback and PRs are welcome.</p>"},{"location":"chapter-4/","title":"Chapter 4 - Working with C","text":"<p>Zig has been designed from the ground up with C interop as a first class feature. In this section we will go over how this works.</p>"},{"location":"chapter-4/#abi","title":"ABI","text":"<p>An ABI (application binary interface) is a standard, pertaining to:</p> <ul> <li>The in-memory layout of types (i.e. a type's size, alignment, offsets, and the layouts of its fields)</li> <li>The in-linker naming of symbols (e.g. name mangling)</li> <li>The calling conventions of functions (i.e. how a function call works at a binary level)</li> </ul> <p>By defining these rules and not breaking them an ABI is said to be stable and this can be used to, for example, reliably link together multiple libraries, executables, or objects which were compiled separately (potentially on different machines, or using different compilers). This allows for FFI (foreign function interface) to take place, where we can share code between programming languages.</p> <p>Zig natively supports C ABIs for <code>extern</code> things; which C ABI is used is dependant on the target which you are compiling for (e.g. CPU architecture, operating system). This allows for near-seamless interoperation with code that was not written in Zig; the usage of C ABIs is standard amongst programming languages.</p> <p>Zig internally does not make use of an ABI, meaning code should explicitly conform to a C ABI where reproducible and defined binary-level behaviour is needed.</p>"},{"location":"chapter-4/#c-primitive-types","title":"C Primitive Types","text":"<p>Zig provides special <code>c_</code> prefixed types for conforming to the C ABI. These do not have fixed sizes, but rather change in size depending on the ABI being used.</p> Type C Equivalent Minimum Size (bits) c_short short 16 c_ushort unsigned short 16 c_int int 16 c_uint unsigned int 16 c_long long 32 c_ulong unsigned long 32 c_longlong long long 64 c_ulonglong unsigned longlong 64 c_longdouble long double N/A c_void void N/A <p>Note: C's void (and Zig's <code>c_void</code>) has an unknown non-zero size. Zig's <code>void</code> is a true zero-sized type.</p>"},{"location":"chapter-4/#calling-conventions","title":"Calling conventions","text":"<p>Calling conventions describe how functions are called. This includes how arguments are supplied to the function (i.e. where they go - in registers or on the stack, and how), and how the return value is received.</p> <p>In Zig, the attribute <code>callconv</code> may be given to a function. The calling conventions available may be found in std.builtin.CallingConvention. Here we make use of the cdecl calling convention. <pre><code>fn add(a: u32, b: u32) callconv(.C) u32 {\nreturn a + b;\n}\n</code></pre></p> <p>Marking your functions with the C calling convention is crucial when you're calling Zig from C.</p>"},{"location":"chapter-4/#extern-structs","title":"Extern Structs","text":"<p>Normal structs in Zig do not have a defined layout; <code>extern</code> structs are required for when you want the layout of your struct to match the layout of your C ABI.</p> <p>Let's create an extern struct. This test should be run with <code>x86_64</code> with a <code>gnu</code> ABI, which can be done with <code>-target x86_64-native-gnu</code>.</p> <pre><code>const expect = @import(\"std\").testing.expect;\n\nconst Data = extern struct { a: i32, b: u8, c: f32, d: bool, e: bool };\n\ntest \"hmm\" {\nconst x = Data{\n.a = 10005,\n.b = 42,\n.c = -10.5,\n.d = false,\n.e = true,\n};\nconst z = @as([*]const u8, @ptrCast(&amp;x));\n\ntry expect(@as(*const i32, @ptrCast(@alignCast(z))).* == 10005);\ntry expect(@as(*const u8, @ptrCast(z + 4)).* == 42);\ntry expect(@as(*const f32, @ptrCast(@alignCast(z + 8))).* == -10.5);\ntry expect(@as(*const bool, @ptrCast(z + 12)).* == false);\ntry expect(@as(*const bool, @ptrCast(z + 13)).* == true);\n}\n</code></pre> <p>This is what the memory inside our <code>x</code> value looks like.</p> Field a a a a b c c c c d e Bytes 15 27 00 00 2A 00 00 00 00 00 28 C1 00 01 00 00 <p>Note how there are gaps in the middle and at the end - this is called \"padding\". The data in this padding is undefined memory, and won't always be zero.</p> <p>As our <code>x</code> value is that of an extern struct, we could safely pass it into a C function expecting a <code>Data</code>, providing the C function was also compiled with the same <code>gnu</code> ABI and CPU arch.</p>"},{"location":"chapter-4/#alignment","title":"Alignment","text":"<p>For circuitry reasons, CPUs access primitive values at certain multiples in memory. This could mean for example that the address of an <code>f32</code> value must be a multiple of 4, meaning <code>f32</code> has an alignment of 4. This so-called \"natural alignment\" of primitive data types is dependent on CPU architecture. All alignments are powers of 2.</p> <p>Data of a larger alignment also has the alignment of every smaller alignment; for example, a value which has an alignment of 16 also has an alignment of 8, 4, 2 and 1.</p> <p>We can make specially aligned data by using the <code>align(x)</code> property. Here we are making data with a greater alignment. <pre><code>const a1: u8 align(8) = 100;\nconst a2 align(8) = @as(u8, 100);\n</code></pre> And making data with a lesser alignment. Note: Creating data of a lesser alignment isn't particularly useful. <pre><code>const b1: u64 align(1) = 100;\nconst b2 align(1) = @as(u64, 100);\n</code></pre></p> <p>Like <code>const</code>, <code>align</code> is also a property of pointers. <pre><code>test \"aligned pointers\" {\nconst a: u32 align(8) = 5;\ntry expect(@TypeOf(&amp;a) == *align(8) const u32);\n}\n</code></pre></p> <p>Let's make use of a function expecting an aligned pointer.</p> <pre><code>fn total(a: *align(64) const [64]u8) u32 {\nvar sum: u32 = 0;\nfor (a) |elem| sum += elem;\nreturn sum;\n}\n\ntest \"passing aligned data\" {\nconst x align(64) = [_]u8{10} ** 64;\ntry expect(total(&amp;x) == 640);\n}\n</code></pre>"},{"location":"chapter-4/#packed-structs","title":"Packed Structs","text":"<p>By default all struct fields in Zig are naturally aligned to that of <code>@alignOf(FieldType)</code> (the ABI size), but without a defined layout. Sometimes you may want to have struct fields with a defined layout that do not conform to your C ABI. <code>packed</code> structs allow you to have extremely precise control of your struct fields, allowing you to place your fields on a bit-by-bit basis.</p> <p>Inside packed structs, Zig's integers take their bit-width in space (i.e. a <code>u12</code> has an <code>@bitSizeOf</code> of 12, meaning it will take up 12 bits in the packed struct). Bools also take up 1 bit, meaning you can implement bit flags easily.</p> <pre><code>const MovementState = packed struct {\nrunning: bool,\ncrouching: bool,\njumping: bool,\nin_air: bool,\n};\n\ntest \"packed struct size\" {\ntry expect(@sizeOf(MovementState) == 1);\ntry expect(@bitSizeOf(MovementState) == 4);\nconst state = MovementState{\n.running = true,\n.crouching = true,\n.jumping = true,\n.in_air = true,\n};\n_ = state;\n}\n</code></pre> <p>Currently Zig's packed structs have some long withstanding compiler bugs, and do not currently work for many use cases.</p>"},{"location":"chapter-4/#bit-aligned-pointers","title":"Bit Aligned Pointers","text":"<p>Similar to aligned pointers, bit aligned pointers have extra information in their type which informs how to access the data. These are necessary when the data is not byte-aligned. Bit alignment information is often needed to address fields inside of packed structs.</p> <pre><code>test \"bit aligned pointers\" {\nvar x = MovementState{\n.running = false,\n.crouching = false,\n.jumping = false,\n.in_air = false,\n};\n\nconst running = &amp;x.running;\nrunning.* = true;\n\nconst crouching = &amp;x.crouching;\ncrouching.* = true;\n\ntry expect(@TypeOf(running) == *align(1:0:1) bool);\ntry expect(@TypeOf(crouching) == *align(1:1:1) bool);\n\ntry expect(@import(\"std\").meta.eql(x, .{\n.running = true,\n.crouching = true,\n.jumping = false,\n.in_air = false,\n}));\n}\n</code></pre>"},{"location":"chapter-4/#c-pointers","title":"C Pointers","text":"<p>Up until now we have used the following kinds of pointers:</p> <ul> <li>single item pointers - <code>*T</code></li> <li>many item pointers - <code>[*]T</code></li> <li>slices - <code>[]T</code></li> </ul> <p>Unlike the aforementioned pointers, C pointers cannot deal with specially aligned data, and may point to the address <code>0</code>. C pointers coerce back and forth between integers, and also coerce to single and multi item pointers. When a C pointer of value <code>0</code> is coerced to a non-optional pointer, this is detectable illegal behaviour.</p> <p>Outside of automatically translated C code, the usage of <code>[*c]</code> is almost always a bad idea, and should almost never be used.</p>"},{"location":"chapter-4/#translate-c","title":"Translate-C","text":"<p>Zig provides the command <code>zig translate-c</code> for automatic translation from C source code.</p> <p>Create the file <code>main.c</code> with the following contents. <pre><code>#include &lt;stddef.h&gt;\n\nvoid int_sort(int* array, size_t count) {\nfor (int i = 0; i &lt; count - 1; i++) {\nfor (int j = 0; j &lt; count - i - 1; j++) {\nif (array[j] &gt; array[j+1]) {\nint temp = array[j];\narray[j] = array[j+1];\narray[j+1] = temp;\n}\n}\n}\n}\n</code></pre> Run the command <code>zig translate-c main.c</code> to get the equivalent Zig code output to your console (stdout). You may wish to pipe this into a file with <code>zig translate-c main.c &gt; int_sort.zig</code> (warning for windows users: piping in powershell will produce a file with the incorrect encoding - use your editor to correct this).</p> <p>In another file you could use <code>@import(\"int_sort.zig\")</code> to make use of this function.</p> <p>Currently the code produced may be unnecessarily verbose, though translate-c successfully translates most C code into Zig. You may wish to use translate-c to produce Zig code before editing it into more idiomatic code; a gradual transfer from C to Zig within a codebase is a supported use case.</p>"},{"location":"chapter-4/#cimport","title":"cImport","text":"<p>Zig's <code>@cImport</code> builtin is unique in that it takes in an expression, which can only take in <code>@cInclude</code>, <code>@cDefine</code>, and <code>@cUndef</code>. This works similarly to translate-c, translating C code to Zig under the hood.</p> <p><code>@cInclude</code> takes in a path string, can adds the path to the includes list.</p> <p><code>@cDefine</code> and <code>@cUndef</code> define and undefine things for the import.</p> <p>These three functions work exactly as you'd expect them to work within C code.</p> <p>Similar to <code>@import</code> this returns a struct type with declarations. It is typically recommended to only use one instance of <code>@cImport</code> in an application to avoid symbol collisions; the types generated within one cImport will not be equivalent to those generated in another.</p> <p>cImport is only available when linking libc.</p>"},{"location":"chapter-4/#linking-libc","title":"Linking libc","text":"<p>Linking libc can be done via the command line via <code>-lc</code>, or via <code>build.zig</code> using <code>exe.linkLibC();</code>. The libc used is that of the compilation's target; Zig provides libc for many targets.</p>"},{"location":"chapter-4/#zig-cc-zig-c","title":"Zig cc, Zig c++","text":"<p>The Zig executable comes with Clang embedded inside it alongside libraries and headers required to cross compile for other operating systems and architectures.</p> <p>This means that not only can <code>zig cc</code> and <code>zig c++</code> compile C and C++ code (with Clang-compatible arguments), but it can also do so while respecting Zig's target triple argument; the single Zig binary that you have installed has the power to compile for several different targets without the need to install multiple versions of the compiler or any addons. Using <code>zig cc</code> and <code>zig c++</code> also makes use of Zig's caching system to speed up your workflow.</p> <p>Using Zig, one can easily construct a cross-compiling toolchain for languages which make use of a C and/or C++ compiler.</p> <p>Some examples in the wild:</p> <ul> <li> <p>Using zig cc to cross compile LuaJIT to aarch64-linux from x86_64-linux</p> </li> <li> <p>Using zig cc and zig c++ in combination with cgo to cross compile hugo from aarch64-macos to x86_64-linux, with full static linking</p> </li> </ul>"},{"location":"chapter-4/#end-of-chapter-4","title":"End of Chapter 4","text":"<p>This chapter is incomplete. In the future it will contain things such as: - Calling C code from Zig and vice versa - Using <code>zig build</code> with a mixture of C and Zig code</p> <p>Feedback and PRs are welcome.</p>"},{"location":"chapter-5/","title":"Chapter 5 - Async","text":"<p>Warning: The current version of the compiler does not yet support async</p>"},{"location":"chapter-5/#async","title":"Async","text":"<p>A functioning understanding of Zig's async requires familiarity with the concept of the call stack. If you have not heard of this before, check out the wikipedia page.</p> <p>A traditional function call comprises of three things: 1. Initiate the called function with its arguments, pushing the function's stack frame 2. Transfer control to the function 3. Upon function completion, hand control back to the caller, retrieving the function's return value and popping the function's stack frame</p> <p>With Zig's async functions we can do more than this, with the transfer of control being an ongoing two-way conversation (i.e. we can give control to the function and take it back multiple times). Because of this, special considerations must be made when calling a function in an async context; we can no longer push and pop the stack frame as normal (as the stack is volatile, and things \"above\" the current stack frame may be overwritten), instead explicitly storing the async function's frame. While most people won't make use of its full feature set, this style of async is useful for creating more powerful constructs such as event loops.</p> <p>The style of Zig's async may be described as suspendible stackless coroutines. Zig's async is very different to something like an OS thread which has a stack, and can only be suspended by the kernel. Furthermore, Zig's async is there to provide you with control flow structures and code generation; async does not imply parallelism or the usage of threads.</p>"},{"location":"chapter-5/#suspend-resume","title":"Suspend / Resume","text":"<p>In the previous section we talked of how async functions can give control back to the caller, and how the async function can later take control back. This functionality is provided by the keywords <code>suspend</code>, and <code>resume</code>. When a function suspends, control flow returns to wherever it was last resumed; when a function is called via an <code>async</code> invocation, this is an implicit resume.</p> <p>The comments in these examples indicate the order of execution. There are a few things to take in here: *  The <code>async</code> keyword is used to invoke functions in an async context. *  <code>async func()</code> returns the function's frame. *  We must store this frame. *  The <code>resume</code> keyword is used on the frame, whereas <code>suspend</code> is used from the called function.</p> <p>This example has a suspend, but no matching resume. <pre><code>const expect = @import(\"std\").testing.expect;\n\nvar foo: i32 = 1;\n\ntest \"suspend with no resume\" {\nvar frame = async func(); //1\n_ = frame;\ntry expect(foo == 2); //4\n}\n\nfn func() void {\nfoo += 1; //2\nsuspend {} //3\nfoo += 1; //never reached!\n}\n</code></pre></p> <p>In well formed code, each suspend is matched with a resume.</p> <pre><code>var bar: i32 = 1;\n\ntest \"suspend with resume\" {\nvar frame = async func2(); //1\nresume frame; //4\ntry expect(bar == 3); //6\n}\n\nfn func2() void {\nbar += 1; //2\nsuspend {} //3\nbar += 1; //5\n}\n</code></pre>"},{"location":"chapter-5/#async-await","title":"Async / Await","text":"<p>Similar to how well formed code has a suspend for every resume, each <code>async</code> function invocation with a return value must be matched with an <code>await</code>. The value yielded by <code>await</code> on the async frame corresponds to the function's return.</p> <p>You may notice that <code>func3</code> here is a normal function (i.e. it has no suspend points - it is not an async function). Despite this, <code>func3</code> can work as an async function when called from an async invocation; the calling convention of <code>func3</code> doesn't have to be changed to async - <code>func3</code> can be of any calling convention.</p> <pre><code>fn func3() u32 {\nreturn 5;\n}\n\ntest \"async / await\" {\nvar frame = async func3();\ntry expect(await frame == 5);\n}\n</code></pre> <p>Using <code>await</code> on an async frame of a function which may suspend is only possible from async functions. As such, functions that use <code>await</code> on the frame of an async function are also considered async functions. If you can be sure that the potential suspend doesn't happen, <code>nosuspend await</code> will stop this from happening.</p>"},{"location":"chapter-5/#nosuspend","title":"Nosuspend","text":"<p>When calling a function which is determined to be async (i.e. it may suspend) without an <code>async</code> invocation, the function which called it is also treated as being async. When a function of a concrete (non-async) calling convention is determined to have suspend points, this is a compile error as async requires its own calling convention. This means, for example, that main cannot be async.</p> <p><pre><code>pub fn main() !void {\nsuspend {}\n}\n</code></pre> (compiled from windows) <pre><code>C:\\zig\\lib\\zig\\std\\start.zig:165:1: error: function with calling convention 'Stdcall' cannot be async\nfn WinStartup() callconv(.Stdcall) noreturn {\n^\nC:\\zig\\lib\\zig\\std\\start.zig:173:65: note: async function call here\n    std.os.windows.kernel32.ExitProcess(initEventLoopAndCallMain());\n                                                                ^\nC:\\zig\\lib\\zig\\std\\start.zig:276:12: note: async function call here\n    return @call(.{ .modifier = .always_inline }, callMain, .{});\n           ^\nC:\\zig\\lib\\zig\\std\\start.zig:334:37: note: async function call here\n            const result = root.main() catch |err| {\n                                    ^\n.\\main.zig:12:5: note: suspends here\n    suspend {}\n    ^\n</code></pre></p> <p>If you want to call an async function without using an <code>async</code> invocation, and without the caller of the function also being async, the <code>nosuspend</code> keyword comes in handy. This allows the caller of the async function to not also be async, by asserting that the potential suspends do not happen.</p> <pre><code>const std = @import(\"std\");\n\nfn doTicksDuration(ticker: *u32) i64 {\nconst start = std.time.milliTimestamp();\n\nwhile (ticker.* &gt; 0) {\nsuspend {}\nticker.* -= 1;\n}\n\nreturn std.time.milliTimestamp() - start;\n}\n\npub fn main() !void {\nvar ticker: u32 = 0;\nconst duration = nosuspend doTicksDuration(&amp;ticker);\n}\n</code></pre> <p>In the above code if we change the value of <code>ticker</code> to be above 0, this is detectable illegal behaviour. If we run that code, we will have an error like this in safe build modes. Similar to other illegal behaviours in Zig, having these happen in unsafe modes will result in undefined behaviour.</p> <pre><code>async function called in nosuspend scope suspended\n.\\main.zig:16:47: 0x7ff661dd3414 in main (main.obj)\n    const duration = nosuspend doTicksDuration(&amp;ticker);\n                                              ^\nC:\\zig\\lib\\zig\\std\\start.zig:173:65: 0x7ff661dd18ce in std.start.WinStartup (main.obj)\n    std.os.windows.kernel32.ExitProcess(initEventLoopAndCallMain());\n                                                                ^\n</code></pre>"},{"location":"chapter-5/#async-frames-suspend-blocks","title":"Async Frames, Suspend Blocks","text":"<p><code>@Frame(function)</code> returns the frame type of the function. This works for async functions, and functions without a specific calling convention.</p> <pre><code>fn add(a: i32, b: i32) i64 {\nreturn a + b;\n}\n\ntest \"@Frame\" {\nvar frame: @Frame(add) = async add(1, 2);\ntry expect(await frame == 3);\n}\n</code></pre> <p><code>@frame()</code> returns a pointer to the frame of the current function. Similar to <code>suspend</code> points, if this call is found in a function then it is inferred as being async. All pointers to frames coerce to the special type <code>anyframe</code>, which you can use <code>resume</code> upon.</p> <p>This allows us to, for example, write a function that resumes itself. <pre><code>fn double(value: u8) u9 {\nsuspend {\nresume @frame();\n}\nreturn value * 2;\n}\n\ntest \"@frame 1\" {\nvar f = async double(1);\ntry expect(nosuspend await f == 2);\n}\n</code></pre></p> <p>Or, more interestingly, we can use it to tell other functions to resume us. Here we're introducing suspend blocks. Upon entering a suspend block, the async function is already considered suspended (i.e. it can be resumed). This means that we can have our function resumed by something other than the last resumer.</p> <pre><code>const std = @import(\"std\");\n\nfn callLater(comptime laterFn: fn () void, ms: u64) void {\nsuspend {\nwakeupLater(@frame(), ms);\n}\nlaterFn();\n}\n\nfn wakeupLater(frame: anyframe, ms: u64) void {\nstd.time.sleep(ms * std.time.ns_per_ms);\nresume frame;\n}\n\nfn alarm() void {\nstd.debug.print(\"Time's Up!\\n\", .{});\n}\n\ntest \"@frame 2\" {\nnosuspend callLater(alarm, 1000);\n}\n</code></pre> <p>Using the <code>anyframe</code> data type can be thought of as a kind of type erasure, in that we are no longer sure of the concrete type of the function or the function frame. This is useful as it still allows us to resume the frame - in a lot of code we will not care about the details and will just want to resume it. This gives us a single concrete type which we can use for our async logic.</p> <p>The natural drawback of <code>anyframe</code> is that we have lost type information, and we no longer know what the return type of the function is. This means we cannot await an <code>anyframe</code>. Zig's solution to this is the <code>anyframe-&gt;T</code> types, where the <code>T</code> is the return type of the frame.</p> <pre><code>fn zero(comptime x: anytype) x {\nreturn 0;\n}\n\nfn awaiter(x: anyframe-&gt;f32) f32 {\nreturn nosuspend await x;\n}\n\ntest \"anyframe-&gt;T\" {\nvar frame = async zero(f32);\ntry expect(awaiter(&amp;frame) == 0);\n}\n</code></pre>"},{"location":"chapter-5/#basic-event-loop-implementation","title":"Basic Event Loop Implementation","text":"<p>An event loop is a design pattern in which events are dispatched and/or waited upon. This will mean some kind of service or runtime that resumes suspended async frames when conditions are met. This is the most powerful and useful use case of Zig's async.</p> <p>Here we will implement a basic event loop. This one will allow us to submit tasks to be executed in a given amount of time. We will use this to submit pairs of tasks which will print the time since the program's start. Here is an example of the output.</p> <pre><code>[task-pair b] it is now 499 ms since start!\n[task-pair a] it is now 1000 ms since start!\n[task-pair b] it is now 1819 ms since start!\n[task-pair a] it is now 2201 ms since start!\n</code></pre> <p>Here is the implementation.</p> <pre><code>const std = @import(\"std\");\n\n// used to get monotonic time, as opposed to wall-clock time\nvar timer: ?std.time.Timer = null;\nfn nanotime() u64 {\nif (timer == null) {\ntimer = std.time.Timer.start() catch unreachable;\n}\nreturn timer.?.read();\n}\n\n// holds the frame, and the nanotime of\n// when the frame should be resumed\nconst Delay = struct {\nframe: anyframe,\nexpires: u64,\n};\n\n// suspend the caller, to be resumed later by the event loop\nfn waitForTime(time_ms: u64) void {\nsuspend timer_queue.add(Delay{\n.frame = @frame(),\n.expires = nanotime() + (time_ms * std.time.ns_per_ms),\n}) catch unreachable;\n}\n\nfn waitUntilAndPrint(\ntime1: u64,\ntime2: u64,\nname: []const u8,\n) void {\nconst start = nanotime();\n\n// suspend self, to be woken up when time1 has passed\nwaitForTime(time1);\nstd.debug.print(\n\"[{s}] it is now {} ms since start!\\n\",\n.{ name, (nanotime() - start) / std.time.ns_per_ms },\n);\n\n// suspend self, to be woken up when time2 has passed\nwaitForTime(time2);\nstd.debug.print(\n\"[{s}] it is now {} ms since start!\\n\",\n.{ name, (nanotime() - start) / std.time.ns_per_ms },\n);\n}\n\nfn asyncMain() void {\n// stores the async frames of our tasks\nvar tasks = [_]@Frame(waitUntilAndPrint){\nasync waitUntilAndPrint(1000, 1200, \"task-pair a\"),\nasync waitUntilAndPrint(500, 1300, \"task-pair b\"),\n};\n// |*t| is used, as |t| would be a *const @Frame(...)\n// which cannot be awaited upon\nfor (tasks) |*t| await t;\n}\n\n// priority queue of tasks\n// lower .expires =&gt; higher priority =&gt; to be executed before\nvar timer_queue: std.PriorityQueue(Delay, void, cmp) = undefined;\nfn cmp(context: void, a: Delay, b: Delay) std.math.Order {\n_ = context;\nreturn std.math.order(a.expires, b.expires);\n}\n\npub fn main() !void {\ntimer_queue = std.PriorityQueue(Delay, void, cmp).init(\nstd.heap.page_allocator, undefined\n);\ndefer timer_queue.deinit();\n\nvar main_task = async asyncMain();\n\n// the body of the event loop\n// pops the task which is to be next executed\nwhile (timer_queue.removeOrNull()) |delay| {\n// wait until it is time to execute next task\nconst now = nanotime();\nif (now &lt; delay.expires) {\nstd.time.sleep(delay.expires - now);\n}\n// execute next task\nresume delay.frame;\n}\n\nnosuspend await main_task;\n}\n</code></pre>"},{"location":"chapter-5/#end-of-chapter-5","title":"End of Chapter 5","text":"<p>This chapter is incomplete and in future should contain usage of <code>std.event.Loop</code>, and evented IO.</p> <p>Feedback and PRs are welcome.</p>"},{"location":"ru/","title":"\u0413\u043b\u0430\u0432\u0430 0 \u2014 \u041d\u0430\u0447\u0430\u043b\u043e \u0440\u0430\u0431\u043e\u0442\u044b","text":""},{"location":"ru/#_1","title":"\u0414\u043e\u0431\u0440\u043e \u043f\u043e\u0436\u0430\u043b\u043e\u0432\u0430\u0442\u044c","text":"<p>Zig \u2014 \u044d\u0442\u043e \u044f\u0437\u044b\u043a \u043f\u0440\u043e\u0433\u0440\u0430\u043c\u043c\u0438\u0440\u043e\u0432\u0430\u043d\u0438\u044f \u043e\u0431\u0449\u0435\u0433\u043e \u043d\u0430\u0437\u043d\u0430\u0447\u0435\u043d\u0438\u044f \u0438 \u0438\u043d\u0441\u0442\u0440\u0443\u043c\u0435\u043d\u0442 \u0434\u043b\u044f \u0441\u043e\u0437\u0434\u0430\u043d\u0438\u044f \u043d\u0430\u0434\u0451\u0436\u043d\u043e\u0433\u043e, \u043e\u043f\u0442\u0438\u043c\u0430\u043b\u044c\u043d\u043e\u0433\u043e \u0438 \u043f\u0435\u0440\u0435\u0438\u0441\u043f\u043e\u043b\u044c\u0437\u0443\u0435\u043c\u043e\u0433\u043e \u041f\u041e.</p> <p>\u0412\u043d\u0438\u043c\u0430\u043d\u0438\u0435: \u043f\u043e\u0441\u043b\u0435\u0434\u043d\u044f\u044f \u0437\u043d\u0430\u0447\u0438\u0442\u0435\u043b\u044c\u043d\u0430\u044f \u0432\u0435\u0440\u0441\u0438\u044f 0.11 \u2014 Zig \u0432\u0441\u0451 \u0435\u0449\u0451 \u043d\u0435 \u0434\u043e\u0448\u0451\u043b \u0434\u043e 1.0; \u0412\u044b \u043c\u043e\u0436\u0435\u0442\u0435 \u0441\u0442\u043e\u043b\u043a\u043d\u0443\u0442\u044c\u0441\u044f \u0441 \u0431\u0430\u0433\u0430\u043c\u0438 \u043a\u043e\u043c\u043f\u0438\u043b\u044f\u0442\u043e\u0440\u0430, \u043d\u0435 \u0440\u0435\u043a\u043e\u043c\u0435\u043d\u0434\u0443\u0435\u043c \u0438\u0441\u043f\u043e\u043b\u044c\u0437\u043e\u0432\u0430\u0442\u044c \u0435\u0433\u043e \u0432 \u043f\u0440\u043e\u0438\u0437\u0432\u043e\u0434\u0441\u0442\u0432\u0435.</p> <p>\u0414\u043b\u044f \u0441\u043b\u0435\u0434\u043e\u0432\u0430\u043d\u0438\u044f \u044d\u0442\u043e\u043c\u0443 \u0440\u0443\u043a\u043e\u0432\u043e\u0434\u0441\u0442\u0432\u0443 \u0436\u0435\u043b\u0430\u0442\u0435\u043b\u044c\u043d\u043e:</p> <ul> <li>\u0418\u043c\u0435\u0442\u044c \u043f\u0440\u0435\u0434\u044b\u0434\u0443\u0449\u0438\u0439 \u043e\u043f\u044b\u0442 \u0440\u0430\u0437\u0440\u0430\u0431\u043e\u0442\u043a\u0438</li> <li>\u0425\u043e\u0442\u044f \u0431\u044b \u043d\u0435\u043c\u043d\u043e\u0433\u043e \u043f\u043e\u043d\u0438\u043c\u0430\u0442\u044c \u043d\u0435\u043a\u043e\u0442\u043e\u0440\u044b\u0435 \u043d\u0438\u0437\u043a\u043e\u0443\u0440\u043e\u0432\u043d\u0435\u0432\u044b\u0435 \u043a\u043e\u043d\u0446\u0435\u043f\u0446\u0438\u0438</li> </ul> <p>\u0417\u043d\u0430\u043d\u0438\u0435 \u044f\u0437\u044b\u043a\u043e\u0432 \u043f\u043e \u0442\u0438\u043f\u0443 \u0421\u0438, C++, Rust, Go, \u041f\u0430\u0441\u043a\u0430\u043b\u044f \u0438 \u0442.\u0434. \u0442\u0430\u043a\u0436\u0435 \u0431\u0443\u0434\u0435\u0442 \u0432\u0435\u0441\u044c\u043c\u0430 \u043f\u043e\u043b\u0435\u0437\u043d\u043e. \u0423 \u0432\u0430\u0441 \u0434\u043e\u043b\u0436\u0435\u043d \u0431\u044b\u0442\u044c \u0442\u0435\u043a\u0441\u0442\u043e\u0432\u044b\u0439 \u0440\u0435\u0434\u0430\u043a\u0442\u043e\u0440, \u0442\u0435\u0440\u043c\u0438\u043d\u0430\u043b \u0438 \u0418\u043d\u0442\u0435\u0440\u043d\u0435\u0442-\u043f\u043e\u0434\u043a\u043b\u044e\u0447\u0435\u043d\u0438\u0435. \u042d\u0442\u043e \u0440\u0443\u043a\u043e\u0432\u043e\u0434\u0441\u0442\u0432\u043e \u043d\u0435 \u0430\u0444\u0444\u0438\u043b\u0438\u0440\u043e\u0432\u0430\u043d\u043e (\u0438 \u043d\u0435 \u0441\u0432\u044f\u0437\u0430\u043d\u043e) \u0441 Zig Software Foundation \u0438 \u043f\u0440\u0435\u0434\u043d\u0430\u0437\u043d\u0430\u0447\u0435\u043d\u043e \u0434\u043b\u044f \u043f\u043e\u0441\u043b\u0435\u0434\u043e\u0432\u0430\u0442\u0435\u043b\u044c\u043d\u043e\u0433\u043e \u0447\u0442\u0435\u043d\u0438\u044f.</p>"},{"location":"ru/#_2","title":"\u0423\u0441\u0442\u0430\u043d\u043e\u0432\u043a\u0430","text":"<p>\u0412 \u044d\u0442\u043e\u043c \u0440\u0443\u043a\u043e\u0432\u043e\u0434\u0441\u0442\u0432\u0435 \u043f\u043e\u0434\u0440\u0430\u0437\u0443\u043c\u0435\u0432\u0430\u0435\u0442\u0441\u044f, \u0447\u0442\u043e \u0432\u044b \u0438\u0441\u043f\u043e\u043b\u044c\u0437\u0443\u0435\u0442\u0435 \u00ab\u043d\u043e\u0447\u043d\u0443\u044e\u00bb \u0441\u0431\u043e\u0440\u043a\u0443 (\u0441 \u043f\u043e\u0441\u043b\u0435\u0434\u043d\u0435\u0433\u043e \u043a\u043e\u043c\u043c\u0438\u0442\u0430 master \u0432\u0435\u0442\u043a\u0438) Zig, \u0430 \u043d\u0435 \u043f\u043e\u0441\u043b\u0435\u0434\u043d\u044e\u044e \u0432\u044b\u043f\u0443\u0449\u0435\u043d\u043d\u0443\u044e \u0432\u0435\u0440\u0441\u0438\u044e, \u0442.\u0435. \u0432\u0430\u043c \u043d\u0435\u043e\u0431\u0445\u043e\u0434\u0438\u043c\u043e \u0441\u043a\u0430\u0447\u0430\u0442\u044c \u0435\u0451 \u0441 \u0441\u0430\u0439\u0442\u0430 \u0438\u043b\u0438 \u0441\u043e\u0431\u0440\u0430\u0442\u044c \u0438\u0437 \u0438\u0441\u0445\u043e\u0434\u043d\u043e\u0433\u043e \u043a\u043e\u0434\u0430; \u0421\u043a\u043e\u0440\u0435\u0435 \u0432\u0441\u0435\u0433\u043e, \u0432 \u043c\u0435\u043d\u0435\u0434\u0436\u0435\u0440\u0435 \u043f\u0430\u043a\u0435\u0442\u043e\u0432 \u0432\u0430\u0448\u0435\u0439 \u0441\u0438\u0441\u0442\u0435\u043c\u044b \u043e\u0442\u0441\u043b\u0435\u0436\u0438\u0432\u0430\u044e\u0442\u0441\u044f \u0442\u043e\u043b\u044c\u043a\u043e \u0432\u044b\u043f\u0443\u0449\u0435\u043d\u043d\u044b\u0435 \u0432\u0435\u0440\u0441\u0438\u0438 Zig. \u042d\u0442\u043e \u0440\u0443\u043a\u043e\u0432\u043e\u0434\u0441\u0442\u0432\u043e \u043d\u0435 \u043f\u043e\u0434\u0434\u0435\u0440\u0436\u0438\u0432\u0430\u0435\u0442 \u0432\u044b\u043f\u0443\u0441\u043a Zig 0.10.1.</p> <ol> <li> <p>\u0421\u043a\u0430\u0447\u0430\u0439\u0442\u0435 \u0438 \u0440\u0430\u0441\u043f\u0430\u043a\u0443\u0439\u0442\u0435 \u0441\u0431\u043e\u0440\u043a\u0443 Zig \u0438\u0437 \u0440\u0430\u0437\u0434\u0435\u043b\u0430 master \u0432 https://ziglang.org/ru/download.</p> </li> <li> <p>\u0414\u043e\u0431\u0430\u0432\u044c\u0442\u0435 Zig \u0432 PATH</p> </li> <li> <p>Linux, MacOS, BSD</p> <p>\u0414\u043e\u0431\u0430\u0432\u044c\u0442\u0435 \u043f\u0443\u0442\u044c \u043a \u0438\u0441\u043f\u043e\u043b\u043d\u044f\u0435\u043c\u043e\u043c\u0443 \u0444\u0430\u0439\u043b\u0443 Zig \u0432 \u0432\u0430\u0448\u0443 \u043f\u0435\u0440\u0435\u043c\u0435\u043d\u043d\u0443\u044e \u043e\u043a\u0440\u0443\u0436\u0435\u043d\u0438\u044f <code>PATH</code>. \u0414\u043b\u044f \u043f\u043e\u0441\u0442\u043e\u044f\u043d\u043d\u043e\u0439 \u0440\u0430\u0431\u043e\u0442\u044b \u0434\u043e\u0431\u0430\u0432\u044c\u0442\u0435 \u043a\u043e\u043c\u0430\u043d\u0434\u0443 <code>export PATH=$PATH:~/zig</code> (\u0433\u0434\u0435 <code>~/zig</code> \u044f\u0432\u043b\u044f\u0435\u0442\u0441\u044f \u043f\u0443\u0442\u0435\u043c \u043a \u0438\u0441\u043f\u043e\u043b\u043d\u044f\u0435\u043c\u043e\u043c\u0443 \u0444\u0430\u0439\u043b\u0443 Zig) \u0432 \u0432\u0430\u0448 <code>/etc/profile</code> (\u0434\u043b\u044f \u0432\u0441\u0435\u0439 \u0441\u0438\u0441\u0442\u0435\u043c\u044b) \u0438\u043b\u0438 <code>$HOME/.profile</code> (\u0434\u043b\u044f \u0442\u0435\u043a\u0443\u0449\u0435\u0433\u043e \u043f\u043e\u043b\u044c\u0437\u043e\u0432\u0430\u0442\u0435\u043b\u044f). \u0415\u0441\u043b\u0438 \u044d\u0442\u0438 \u0438\u0437\u043c\u0435\u043d\u0435\u043d\u0438\u044f \u043d\u0435 \u0441\u0440\u0430\u0431\u043e\u0442\u0430\u043b\u0438 \u0441\u0440\u0430\u0437\u0443, \u0432\u044b\u043f\u043e\u043b\u043d\u0438\u0442\u0435 \u044d\u0442\u0443 \u043a\u043e\u043c\u0430\u043d\u0434\u0443 \u0432 \u0442\u0435\u043a\u0443\u0449\u0435\u0439 \u043a\u043e\u043c\u0430\u043d\u0434\u043d\u043e\u0439 \u043e\u0431\u043e\u043b\u043e\u0447\u043a\u0435 \u0438\u043b\u0438 \u043f\u0435\u0440\u0435\u0437\u0430\u043f\u0443\u0441\u0442\u0438\u0442\u0435 \u0442\u0435\u0440\u043c\u0438\u043d\u0430\u043b.    - Windows</p> <p>a) \u041d\u0430 \u0432\u0441\u044e \u0441\u0438\u0441\u0442\u0435\u043c\u0443 (PowerShell \u043e\u0442 \u0430\u0434\u043c\u0438\u043d\u0438\u0441\u0442\u0440\u0430\u0442\u043e\u0440\u0430)</p> <pre><code>[Environment]::SetEnvironmentVariable(\n   \"Path\",\n   [Environment]::GetEnvironmentVariable(\"Path\", \"Machine\") + \";C:\\\u0432\u0430\u0448-\u043f\u0443\u0442\u044c-\u043a-\u0440\u0430\u0441\u043f\u0430\u043a\u043e\u0432\u0430\u043d\u043d\u043e\u043c\u0443\\zig-windows-x86_64-\u0432\u0430\u0448\u0430-\u0432\u0435\u0440\u0441\u0438\u044f\",\n   \"Machine\"\n)\n</code></pre> <p>b) \u0414\u043b\u044f \u0442\u0435\u043a\u0443\u0449\u0435\u0433\u043e \u043f\u043e\u043b\u044c\u0437\u043e\u0432\u0430\u0442\u0435\u043b\u044f (PowerShell)</p> <pre><code>[Environment]::SetEnvironmentVariable(\n   \"Path\",\n   [Environment]::GetEnvironmentVariable(\"Path\", \"User\") + \";C:\\\u0432\u0430\u0448-\u043f\u0443\u0442\u044c-\u043a-\u0440\u0430\u0441\u043f\u0430\u043a\u043e\u0432\u0430\u043d\u043d\u043e\u043c\u0443\\zig-windows-x86_64-\u0432\u0430\u0448\u0430-\u0432\u0435\u0440\u0441\u0438\u044f\",\n   \"User\"\n)\n</code></pre> <p>\u041f\u043e\u0441\u043b\u0435 \u044d\u0442\u043e\u0433\u043e \u043f\u0435\u0440\u0435\u0437\u0430\u043f\u0443\u0441\u0442\u0438\u0442\u0435 \u0442\u0435\u0440\u043c\u0438\u043d\u0430\u043b.</p> </li> <li> <p>\u041f\u0440\u043e\u0432\u0435\u0440\u044c\u0442\u0435 \u0432\u0430\u0448\u0443 \u0443\u0441\u0442\u0430\u043d\u043e\u0432\u043a\u0443 \u0441 \u043f\u043e\u043c\u043e\u0449\u0438 <code>zig version</code>. \u041a\u043e\u043c\u0430\u043d\u0434\u0430 \u0434\u043e\u043b\u0436\u043d\u0430 \u043d\u0430\u043f\u0435\u0447\u0430\u0442\u0430\u0442\u044c \u0447\u0442\u043e-\u0442\u043e \u043d\u0430\u043f\u043e\u0434\u043e\u0431\u0438\u0438: <pre><code>$ zig version\n0.11.0-dev.2777+b95cdf0ae\n</code></pre></p> </li> <li> <p>(\u041d\u0435\u043e\u0431\u044f\u0437\u0430\u0442\u0435\u043b\u044c\u043d\u043e, \u0441\u0442\u043e\u0440\u043e\u043d\u043d\u0438\u0435 \u0440\u0430\u0437\u0440\u0430\u0431\u043e\u0442\u0447\u0438\u043a\u0438) \u0414\u043b\u044f \u0430\u0432\u0442\u043e\u0434\u043e\u043f\u043e\u043b\u043d\u0435\u043d\u0438\u044f, \u043f\u0435\u0440\u0435\u0445\u043e\u0434\u0430 \u043a \u043e\u0431\u044a\u044f\u0432\u043b\u0435\u043d\u0438\u044e \u0438 \u043f\u0440\u043e\u0447\u0438\u0445 \u043f\u043e\u043b\u0435\u0437\u043d\u044b\u0445 \u0448\u0442\u0443\u043a \u0443\u0441\u0442\u0430\u043d\u043e\u0432\u0438\u0442\u0435 Zig Language Server \u0441 https://github.com/zigtools/zls/ (\u043d\u0435\u043e\u0431\u0445\u043e\u0434\u0438\u043c \u0440\u0435\u0434\u0430\u043a\u0442\u043e\u0440 \u0441 \u043f\u043e\u0434\u0434\u0435\u0440\u0436\u043a\u043e\u0439 Language Server Protocol).</p> </li> <li> <p>(\u041d\u0435\u043e\u0431\u044f\u0437\u0430\u0442\u0435\u043b\u044c\u043d\u043e) \u0412\u043e\u0439\u0434\u0438\u0442\u0435 \u0432 \u0441\u043e\u043e\u0431\u0449\u0435\u0441\u0442\u0432\u043e Zig.</p> </li> </ol>"},{"location":"ru/#_3","title":"\u041f\u0440\u0438\u0432\u0435\u0442, \u043c\u0438\u0440!","text":"<p>\u0421\u043e\u0437\u0434\u0430\u0439\u0442\u0435 \u0444\u0430\u0439\u043b \u043f\u043e\u0434 \u043d\u0430\u0437\u0432\u0430\u043d\u0438\u0435\u043c <code>main.zig</code> \u0441 \u0441\u043b\u0435\u0434\u0443\u044e\u0449\u0438\u043c \u0441\u043e\u0434\u0435\u0440\u0436\u0438\u043c\u044b\u043c:</p> <pre><code>const std = @import(\"std\");\n\npub fn main() void {\nstd.debug.print(\"\u041f\u0440\u0438\u0432\u0435\u0442, {s}!\\n\", .{\"\u041c\u0438\u0440\"});\n}\n</code></pre> <p>\u043f\u0440\u0438\u043c\u0435\u0447\u0430\u043d\u0438\u0435: \u0443\u0431\u0435\u0434\u0438\u0442\u0435\u0441\u044c, \u0447\u0442\u043e \u0432 \u0432\u0430\u0448\u0435\u043c \u0444\u0430\u0439\u043b\u0435 \u0438\u0441\u043f\u043e\u043b\u044c\u0437\u0443\u0435\u0442\u0441\u044f \u043a\u043e\u0434\u0438\u0440\u043e\u0432\u043a\u0430 UTF-8!</p> <p>\u043f\u0440\u0438\u043c\u0435\u0447\u0430\u043d\u0438\u0435: \u0415\u0441\u043b\u0438 \u0432\u044b \u0438\u0441\u043f\u043e\u043b\u044c\u0437\u0443\u0435\u0442\u0435 \u0442\u0430\u0431\u0443\u043b\u044f\u0446\u0438\u044e \u0434\u043b\u044f \u043e\u0442\u0441\u0442\u0443\u043f\u043e\u0432 \u0438/\u0438\u043b\u0438 \u043f\u0435\u0440\u0435\u0432\u043e\u0434 \u0441\u0442\u0440\u043e\u043a\u0438 CRLF (\u0441\u0442\u0438\u043b\u044c Windows), \u043a\u043e\u043c\u043f\u0438\u043b\u044f\u0442\u043e\u0440 Zig \u043f\u0440\u0438\u043c\u0435\u0442 \u0438\u0445, \u043d\u043e \u0438\u0441\u043f\u043e\u043b\u044c\u0437\u043e\u0432\u0430\u043d\u0438\u0435 <code>zig fmt</code> \u0437\u0430\u043c\u0435\u043d\u0438\u0442 \u0438\u0445 \u043d\u0430 \u043f\u0440\u043e\u0431\u0435\u043b\u044b \u0438 \u043f\u0435\u0440\u0435\u0432\u043e\u0434 \u0441\u0442\u0440\u043e\u043a\u0438 LF (\u0441\u0442\u0438\u043b\u044c Unix)</p> <p>\u0417\u0430\u043f\u0443\u0441\u0442\u0438\u0442\u0435 \u043a\u043e\u043c\u0430\u043d\u0434\u0443 <code>zig run main.zig</code> \u0434\u043b\u044f \u0441\u0431\u043e\u0440\u043a\u0438 \u0438 \u0437\u0430\u043f\u0443\u0441\u043a\u0430 \u044d\u0442\u043e\u0433\u043e \u0444\u0430\u0439\u043b\u0430. \u0412 \u044d\u0442\u043e\u043c \u043f\u0440\u0438\u043c\u0435\u0440\u0435 \u043f\u0440\u043e\u0433\u0440\u0430\u043c\u043c\u0430 \u043d\u0430\u043f\u0435\u0447\u0430\u0442\u0430\u0435\u0442 <code>\u041f\u0440\u0438\u0432\u0435\u0442, \u041c\u0438\u0440!</code> \u0432 stderr (\u0441\u0442\u0430\u043d\u0434\u0430\u0440\u0442\u043d\u044b\u0439 \u0432\u044b\u0432\u043e\u0434 \u043e\u0448\u0438\u0431\u043e\u043a).</p>"},{"location":"ru/chapter-1/","title":"\u0413\u043b\u0430\u0432\u0430 1 \u2014 \u041e\u0441\u043d\u043e\u0432\u044b","text":""},{"location":"ru/chapter-1/#_1","title":"\u041f\u0435\u0440\u0435\u043c\u0435\u043d\u043d\u044b\u0435","text":"<p>\u0422\u0430\u043a \u043c\u044b \u043f\u0440\u0438\u0441\u0432\u0430\u0438\u0432\u0430\u0435\u043c \u0437\u043d\u0430\u0447\u0435\u043d\u0438\u0435 \u043a\u043e\u043d\u0441\u0442\u0430\u043d\u0442\u0435 \u0438\u043b\u0438 \u043f\u0435\u0440\u0435\u043c\u0435\u043d\u043d\u043e\u0439: <code>(const|var) \u043d\u0430\u0437\u0432\u0430\u043d\u0438\u0435[: \u0442\u0438\u043f] = \u0437\u043d\u0430\u0447\u0435\u043d\u0438\u0435</code>.</p> <ul> <li>\u041c\u043e\u0434\u0438\u0444\u0438\u043a\u0430\u0442\u043e\u0440 <code>const</code> \u0443\u043a\u0430\u0437\u044b\u0432\u0430\u0435\u0442, \u0447\u0442\u043e <code>\u043d\u0430\u0437\u0432\u0430\u043d\u0438\u0435</code> \u044f\u0432\u043b\u044f\u0435\u0442\u0441\u044f \u043a\u043e\u043d\u0441\u0442\u0430\u043d\u0442\u043e\u0439, \u043a\u043e\u0442\u043e\u0440\u0430\u044f \u043d\u0435 \u043c\u0435\u043d\u044f\u0435\u0442 \u0441\u0432\u043e\u0451 \u0437\u043d\u0430\u0447\u0435\u043d\u0438\u0435.</li> <li>\u041c\u043e\u0434\u0438\u0444\u0438\u043a\u0430\u0442\u043e\u0440 <code>var</code> \u0443\u043a\u0430\u0437\u044b\u0432\u0430\u0435\u0442, \u0447\u0442\u043e <code>\u043d\u0430\u0437\u0432\u0430\u043d\u0438\u0435</code> \u044f\u0432\u043b\u044f\u0435\u0442\u0441\u044f \u043f\u0435\u0440\u0435\u043c\u0435\u043d\u043d\u043e\u0439, \u043a\u043e\u0442\u043e\u0440\u0430\u044f \u043c\u043e\u0436\u0435\u0442 \u0438\u0437\u043c\u0435\u043d\u0438\u0442\u044c \u0441\u0432\u043e\u0451 \u0437\u043d\u0430\u0447\u0435\u043d\u0438\u0435.</li> <li>\u0410\u043d\u043d\u043e\u0442\u0430\u0446\u0438\u044f <code>: \u0442\u0438\u043f</code> \u0443\u043a\u0430\u0437\u044b\u0432\u0430\u0435\u0442 \u0442\u0438\u043f \u0434\u043b\u044f <code>\u043d\u0430\u0437\u0432\u0430\u043d\u0438\u0435</code>, \u043e\u043d \u043c\u043e\u0436\u0435\u0442 \u0431\u044b\u0442\u044c \u043f\u0440\u043e\u043f\u0443\u0449\u0435\u043d, \u0435\u0441\u043b\u0438 \u043c\u043e\u0436\u043d\u043e \u0430\u0432\u0442\u043e\u043c\u0430\u0442\u0438\u0447\u0435\u0441\u043a\u0438 \u0432\u044b\u0432\u0435\u0441\u0442\u0438 \u0442\u0438\u043f.</li> </ul> <pre><code>const constant: i32 = 5; // \u043a\u043e\u043d\u0441\u0442\u0430\u043d\u0442\u0430 \u0440\u0430\u0437\u043c\u0435\u0440\u043e\u043c 32 \u0431\u0438\u0442, \u0437\u043d\u0430\u043a\u043e\u0432\u043e\u0435 \u0446\u0435\u043b\u043e\u0435 \u0447\u0438\u0441\u043b\u043e (int 32)\nvar variable: u32 = 5000; // \u043f\u0435\u0440\u0435\u043c\u0435\u043d\u043d\u0430\u044f \u0440\u0430\u0437\u043c\u0435\u0440\u043e\u043c 32 \u0431\u0438\u0442, \u0431\u0435\u0437\u0437\u043d\u0430\u043a\u043e\u0432\u043e\u0435 \u0446\u0435\u043b\u043e\u0435 \u0447\u0438\u0441\u043b\u043e (unsigned int 32)\n\n// @as \u043f\u0440\u043e\u0438\u0437\u0432\u043e\u0434\u0438\u0442 \u044f\u0432\u043d\u043e\u0435 \u043f\u0440\u0438\u0432\u0435\u0434\u0435\u043d\u0438\u0435 \u0442\u0438\u043f\u043e\u0432\nconst inferred_constant = @as(i32, 5);\nvar inferred_variable = @as(u32, 5000);\n</code></pre> <p>\u041a\u043e\u043d\u0441\u0442\u0430\u043d\u0442\u044b \u0438 \u043f\u0435\u0440\u0435\u043c\u0435\u043d\u043d\u044b\u0435 \u0434\u043e\u043b\u0436\u043d\u044b \u0438\u043c\u0435\u0442\u044c \u0437\u043d\u0430\u0447\u0435\u043d\u0438\u0435. \u0415\u0441\u043b\u0438 \u0437\u043d\u0430\u0447\u0435\u043d\u0438\u0435 \u0435\u0449\u0451 \u043d\u0435\u0438\u0437\u0432\u0435\u0441\u0442\u043d\u043e, \u0432\u044b \u043c\u043e\u0436\u0435\u0442\u0435 \u043f\u0440\u0438\u0441\u0432\u043e\u0438\u0442\u044c \u0437\u043d\u0430\u0447\u0435\u043d\u0438\u0435 <code>undefined</code>, \u043a\u043e\u0442\u043e\u0440\u043e\u0435 \u043c\u043e\u0436\u0435\u0442 \u043f\u0440\u0438\u0432\u043e\u0434\u0438\u0442\u044c\u0441\u044f \u043a \u043b\u044e\u0431\u043e\u043c\u0443 \u0442\u0438\u043f\u0443, \u043f\u0440\u0438 \u0443\u0441\u043b\u043e\u0432\u0438\u0438, \u0447\u0442\u043e \u0432\u044b \u044f\u0432\u043d\u043e \u0430\u043d\u043d\u043e\u0442\u0438\u0440\u043e\u0432\u0430\u043b\u0438 \u0442\u0438\u043f.</p> <pre><code>const a: i32 = undefined;\nvar b: u32 = undefined;\n</code></pre> <p>\u0412 \u0431\u043e\u043b\u044c\u0448\u0438\u043d\u0441\u0442\u0432\u0435 \u0441\u043b\u0443\u0447\u0430\u0435\u0432 \u0436\u0435\u043b\u0430\u0442\u0435\u043b\u044c\u043d\u043e \u0438\u0441\u043f\u043e\u043b\u044c\u0437\u043e\u0432\u0430\u0442\u044c <code>const</code> \u0432\u043c\u0435\u0441\u0442\u043e <code>var</code>.</p>"},{"location":"ru/chapter-1/#nt","title":"\u041c\u0430\u0441\u0441\u0438\u0432\u044b [N]T","text":"<p>\u041c\u0430\u0441\u0441\u0438\u0432\u044b \u043e\u0431\u043e\u0437\u043d\u0430\u0447\u0430\u044e\u0442\u0441\u044f \u0441\u0438\u043d\u0442\u0430\u043a\u0441\u0438\u0441\u043e\u043c <code>[N]T</code>, \u0433\u0434\u0435 <code>N</code> \u2014 \u043a\u043e\u043b\u0438\u0447\u0435\u0441\u0442\u0432\u043e \u044d\u043b\u0435\u043c\u0435\u043d\u0442\u043e\u0432 \u0432 \u043c\u0430\u0441\u0441\u0438\u0432\u0435, \u0430 <code>T</code> \u2014 \u0442\u0438\u043f \u044d\u0442\u0438\u0445 \u044d\u043b\u0435\u043c\u0435\u043d\u0442\u043e\u0432 (\u0442.\u0435. \u0434\u043e\u0447\u0435\u0440\u043d\u0438\u0439 \u0442\u0438\u043f \u043c\u0430\u0441\u0441\u0438\u0432\u0430).</p> <p>\u0412 \u043b\u0438\u0442\u0435\u0440\u0430\u043b\u0430\u0445 \u043c\u0430\u0441\u0441\u0438\u0432\u0430 (\u0431\u0435\u0437\u044b\u043c\u044f\u043d\u043d\u044b\u0445 \u043c\u0430\u0441\u0441\u0438\u0432\u0430\u0445), <code>N</code> \u043c\u043e\u0436\u043d\u043e \u0437\u0430\u043c\u0435\u043d\u0438\u0442\u044c \u043d\u0430 <code>_</code>, \u0442\u043e\u0433\u0434\u0430 \u0440\u0430\u0437\u043c\u0435\u0440 \u043c\u0430\u0441\u0441\u0438\u0432\u0430 \u0431\u0443\u0434\u0435\u0442 \u0432\u044b\u0432\u0435\u0434\u0435\u043d \u0430\u0432\u0442\u043e\u043c\u0430\u0442\u0438\u0447\u0435\u0441\u043a\u0438.</p> <pre><code>const a = [5]u8{ 'h', 'e', 'l', 'l', 'o' };\nconst b = [_]u8{ 'w', 'o', 'r', 'l', 'd' };\n</code></pre> <p>\u0427\u0442\u043e\u0431\u044b \u043f\u043e\u043b\u0443\u0447\u0438\u0442\u044c \u0440\u0430\u0437\u043c\u0435\u0440 \u043c\u0430\u0441\u0441\u0438\u0432\u0430, \u043e\u0431\u0440\u0430\u0442\u0438\u0442\u0435\u0441\u044c \u043a \u043f\u043e\u043b\u044e \u043c\u0430\u0441\u0441\u0438\u0432\u0430 <code>len</code>.</p> <pre><code>const array = [_]u8{ 'h', 'e', 'l', 'l', 'o' };\nconst length = array.len; // 5\n</code></pre>"},{"location":"ru/chapter-1/#if","title":"If","text":"<p>\u041e\u0431\u044b\u0447\u043d\u0430\u044f \u0432\u0435\u0440\u0441\u0438\u044f \u043e\u043f\u0435\u0440\u0430\u0442\u043e\u0440\u0430 <code>if</code> \u0432 Zig \u043f\u0440\u0438\u043d\u0438\u043c\u0430\u0435\u0442 \u0442\u043e\u043b\u044c\u043a\u043e \u0437\u043d\u0430\u0447\u0435\u043d\u0438\u044f \u0442\u0438\u043f\u0430 <code>bool</code> (\u0442.\u0435. <code>true</code> \u2014 \u0438\u0441\u0442\u0438\u043d\u0430 \u0438\u043b\u0438 <code>false</code> \u2014 \u043b\u043e\u0436\u044c). \u0412 \u044d\u0442\u043e\u043c \u0441\u043b\u0443\u0447\u0430\u0435 \u043d\u0435 \u0441\u0443\u0449\u0435\u0441\u0442\u0432\u0443\u0435\u0442 \u0438\u0441\u0442\u0438\u043d\u043d\u043e\u043f\u043e\u0434\u043e\u0431\u043d\u044b\u0445 (truthy) \u0438\u043b\u0438 \u043b\u043e\u0436\u043d\u043e\u043f\u043e\u0434\u043e\u0431\u043d\u044b\u0445 (falsy) \u0437\u043d\u0430\u0447\u0435\u043d\u0438\u0439.</p> <p>\u0417\u0434\u0435\u0441\u044c \u043c\u044b \u043d\u0430\u0447\u0438\u043d\u0430\u0435\u043c \u0438\u0441\u043f\u043e\u043b\u044c\u0437\u043e\u0432\u0430\u0442\u044c \u0442\u0435\u0441\u0442\u044b. \u0421\u043e\u0445\u0440\u0430\u043d\u0438\u0442\u0435 \u043a\u043e\u0434 \u043d\u0438\u0436\u0435, \u0430 \u0437\u0430\u0442\u0435\u043c \u0441\u043e\u0431\u0435\u0440\u0438\u0442\u0435 \u0438 \u0437\u0430\u043f\u0443\u0441\u0442\u0438\u0442\u0435 \u0435\u0433\u043e \u043a\u043e\u043c\u0430\u043d\u0434\u043e\u0439 <code>zig test \u043d\u0430\u0437\u0432\u0430\u043d\u0438\u0435-\u0444\u0430\u0439\u043b\u0430.zig</code>. \u0417\u0434\u0435\u0441\u044c \u043c\u044b \u0438\u0441\u043f\u043e\u043b\u044c\u0437\u0443\u0435\u043c \u0444\u0443\u043d\u043a\u0446\u0438\u044e <code>expect</code> \u0438\u0437 \u0441\u0442\u0430\u043d\u0434\u0430\u0440\u0442\u043d\u043e\u0439 \u0431\u0438\u0431\u043b\u0438\u043e\u0442\u0435\u043a\u0438, \u043a\u043e\u0442\u043e\u0440\u0430\u044f \u0432\u044b\u0434\u0430\u0441\u0442 \u043e\u0448\u0438\u0431\u043a\u0443, \u0435\u0441\u043b\u0438 \u0432\u044b\u0440\u0430\u0436\u0435\u043d\u0438\u0435 \u043b\u043e\u0436\u043d\u043e. \u0415\u0441\u043b\u0438 \u0442\u0435\u0441\u0442 \u0437\u0430\u0432\u0435\u0440\u0448\u0430\u0435\u0442\u0441\u044f \u0441 \u043e\u0448\u0438\u0431\u043a\u043e\u0439, \u043f\u043e\u044f\u0432\u0438\u0442\u0441\u044f \u0442\u0440\u0430\u0441\u0441\u0438\u0440\u043e\u0432\u043a\u0430 \u043e\u0448\u0438\u0431\u043a\u0438 \u0438 \u0441\u0442\u0435\u043a\u0430.</p> <pre><code>const expect = @import(\"std\").testing.expect;\n\ntest \"\u0423\u0441\u043b\u043e\u0432\u043d\u044b\u0439 \u043e\u043f\u0435\u0440\u0430\u0442\u043e\u0440 if\" {\nconst a = true;\nvar x: u16 = 0;\nif (a) {\nx += 1;\n} else {\nx += 2;\n}\ntry expect(x == 1);\n}\n</code></pre> <p>\u041e\u043f\u0435\u0440\u0430\u0442\u043e\u0440 if \u0442\u0430\u043a\u0436\u0435 \u043c\u043e\u0436\u043d\u043e \u0438\u0441\u043f\u043e\u043b\u044c\u0437\u043e\u0432\u0430\u0442\u044c \u0432 \u0432\u044b\u0440\u0430\u0436\u0435\u043d\u0438\u044f\u0445.</p> <pre><code>test \"\u041e\u043f\u0435\u0440\u0430\u0442\u043e\u0440 if \u0432 \u0432\u044b\u0440\u0430\u0436\u0435\u043d\u0438\u0438\" {\nconst a = true;\nvar x: u16 = 0;\nx += if (a) 1 else 2;\ntry expect(x == 1);\n}\n</code></pre>"},{"location":"ru/chapter-1/#while","title":"While","text":"<p>\u0426\u0438\u043a\u043b <code>while</code> \u043c\u043e\u0436\u0435\u0442 \u0441\u043e\u0434\u0435\u0440\u0436\u0430\u0442\u044c \u0442\u0440\u0438 \u0447\u0430\u0441\u0442\u0438 \u2014 \u0443\u0441\u043b\u043e\u0432\u0438\u0435, \u0432\u044b\u043f\u043e\u043b\u043d\u044f\u0435\u043c\u044b\u0439 \u043a\u043e\u0434 (\u0432 \u0431\u043b\u043e\u043a\u0435) \u0438 \u0432\u044b\u0440\u0430\u0436\u0435\u043d\u0438\u0435, \u043a\u043e\u0442\u043e\u0440\u043e\u0435 \u0438\u0441\u043f\u043e\u043b\u043d\u044f\u0435\u0442\u0441\u044f \u043f\u043e\u0441\u043b\u0435 \u043a\u0430\u0436\u0434\u043e\u0439 \u0438\u0442\u0435\u0440\u0430\u0446\u0438\u0438 (continue expression).</p> <p>\u041f\u0440\u0438\u043c\u0435\u0440 \u0431\u0435\u0437 \u00abcontinue expression\u00bb. <pre><code>test \"\u0426\u0438\u043a\u043b while\" {\nvar i: u8 = 2;\nwhile (i &lt; 100) {\ni *= 2;\n}\ntry expect(i == 128);\n}\n</code></pre></p> <p>\u041f\u0440\u0438\u043c\u0435\u0440 \u0441 \u00abcontinue expression\u00bb. <pre><code>test \"\u0426\u0438\u043a\u043b while \u0441 \u0432\u044b\u0440\u0430\u0436\u0435\u043d\u0438\u0435\u043c, \u0438\u0441\u043f\u043e\u043b\u043d\u044f\u0435\u043c\u044b\u043c \u043f\u043e\u0441\u043b\u0435 \u043a\u0430\u0436\u0434\u043e\u0439 \u0438\u0442\u0435\u0440\u0430\u0446\u0438\u0438\" {\nvar sum: u8 = 0;\nvar i: u8 = 1;\nwhile (i &lt;= 10) : (i += 1) {\nsum += i;\n}\ntry expect(sum == 55);\n}\n</code></pre></p> <p>\u0421 \u043e\u043f\u0435\u0440\u0430\u0442\u043e\u0440\u043e\u043c \u043f\u0440\u043e\u043f\u0443\u0441\u043a\u0430 \u0438\u0442\u0435\u0440\u0430\u0446\u0438\u0438 <code>continue</code>.</p> <pre><code>test \"\u0426\u0438\u043a\u043b while \u0441 \u043f\u0440\u043e\u043f\u0443\u0441\u043a\u043e\u043c \u0438\u0442\u0435\u0440\u0430\u0446\u0438\u0438\" {\nvar sum: u8 = 0;\nvar i: u8 = 0;\nwhile (i &lt;= 3) : (i += 1) {\nif (i == 2) continue;\nsum += i;\n}\ntry expect(sum == 4);\n}\n</code></pre> <p>\u0421 \u043e\u043f\u0435\u0440\u0430\u0442\u043e\u0440\u043e\u043c \u0434\u043e\u0441\u0440\u043e\u0447\u043d\u043e\u0433\u043e \u0432\u044b\u0445\u043e\u0434\u0430 \u0438\u0437 \u0446\u0438\u043a\u043b\u0430 <code>break</code>.</p> <pre><code>test \"\u0426\u0438\u043a\u043b while \u0441 \u0434\u043e\u0441\u0440\u043e\u0447\u043d\u044b\u043c \u0432\u044b\u0445\u043e\u0434\u043e\u043c\" {\nvar sum: u8 = 0;\nvar i: u8 = 0;\nwhile (i &lt;= 3) : (i += 1) {\nif (i == 2) break;\nsum += i;\n}\ntry expect(sum == 1);\n}\n</code></pre>"},{"location":"ru/chapter-1/#for","title":"For","text":"<p>\u0426\u0438\u043a\u043b <code>for</code> \u0438\u0441\u043f\u043e\u043b\u044c\u0437\u0443\u0435\u0442\u0441\u044f \u0434\u043b\u044f \u043f\u0440\u043e\u0445\u043e\u0434\u0430 \u043f\u043e \u043c\u0430\u0441\u0441\u0438\u0432\u0430\u043c (\u0438 \u0434\u0440\u0443\u0433\u0438\u043c \u0442\u0438\u043f\u0430\u043c, \u043e \u043d\u0438\u0445 \u0440\u0430\u0441\u0441\u043a\u0430\u0436\u0435\u043c \u043f\u043e\u0437\u0436\u0435). \u0426\u0438\u043a\u043b <code>for</code> \u0441\u043b\u0435\u0434\u0443\u0435\u0442 \u043d\u0438\u0436\u0435\u0443\u043a\u0430\u0437\u0430\u043d\u043d\u043e\u043c\u0443 \u0441\u0438\u043d\u0442\u0430\u043a\u0441\u0438\u0441\u0443. \u041a\u0430\u043a \u0438 \u0432 \u0446\u0438\u043a\u043b\u0435 <code>while</code>, \u0432 \u0446\u0438\u043a\u043b\u0435 <code>for</code> \u0438\u043e\u0433\u0443\u0442 \u0438\u0441\u043f\u043e\u043b\u044c\u0437\u043e\u0432\u0430\u0442\u044c\u0441\u044f \u043e\u043f\u0435\u0440\u0430\u0442\u043e\u0440\u044b <code>break</code> \u0438 <code>continue</code>. \u041c\u044b \u043f\u0440\u0438\u0441\u0432\u0430\u0438\u0432\u0430\u0435\u043c \u0437\u043d\u0430\u0447\u0435\u043d\u0438\u044f \u043a <code>_</code>, \u0442.\u043a. Zig \u043d\u0435 \u0440\u0430\u0437\u0440\u0435\u0448\u0430\u0435\u0442 \u043c\u043e\u043b\u0447\u0430 \u0438\u0433\u043d\u043e\u0440\u0438\u0440\u043e\u0432\u0430\u0442\u044c \u0437\u043d\u0430\u0447\u0435\u043d\u0438\u044f (\u043f\u043e\u0434\u0440\u043e\u0431\u043d\u0435\u0435 \u0432 \u043f\u043e\u0434\u0440\u0430\u0437\u0434\u0435\u043b\u0435 \u0424\u0443\u043d\u043a\u0446\u0438\u0438).</p> <pre><code>test \"\u0426\u0438\u043a\u043b for\" {\n// \u0423\u043a\u0430\u0437\u0430\u043d\u043d\u044b\u0435 \u043d\u0438\u0436\u0435 \u043b\u0438\u0442\u0435\u0440\u0430\u043b\u044b \u0441\u0438\u043c\u0432\u043e\u043b\u043e\u0432 \u044d\u043a\u0432\u0438\u0432\u0430\u043b\u0435\u043d\u0442\u043d\u044b \u043b\u0438\u0442\u0435\u0440\u0430\u043b\u0430\u043c \u0441\u0432\u043e\u0438\u0445 \u0437\u043d\u0430\u0447\u0435\u043d\u0438\u0439 \u0432 \u0432\u0438\u0434\u0435 \u0447\u0438\u0441\u0435\u043b\nconst string = [_]u8{ 'a', 'b', 'c' };\n\nfor (string, 0..) |character, index| {\n_ = character; // \u0442\u0435\u043a\u0443\u0449\u0438\u0439 \u044d\u043b\u0435\u043c\u0435\u043d\u0442 \u043c\u0430\u0441\u0441\u0438\u0432\u0430\n_ = index; // \u0442\u0435\u043a\u0443\u0449\u0438\u0439 \u0438\u043d\u0434\u0435\u043a\u0441\n}\n\nfor (string) |character| {\n_ = character;\n}\n\nfor (string, 0..) |_, index| {\n_ = index;\n}\n\nfor (string) |_| {}\n}\n</code></pre>"},{"location":"ru/chapter-1/#_2","title":"\u0424\u0443\u043d\u043a\u0446\u0438\u0438","text":"<p>\u0412\u0441\u0435 \u0430\u0440\u0433\u0443\u043c\u0435\u043d\u0442\u044b \u0444\u0443\u043d\u043a\u0446\u0438\u0438 \u044f\u0432\u043b\u044f\u044e\u0442\u0441\u044f \u043d\u0435\u0438\u0437\u043c\u0435\u043d\u044f\u0435\u043c\u044b\u043c\u0438 \u2014 \u0435\u0441\u043b\u0438 \u0432\u0430\u043c \u043d\u0443\u0436\u043d\u0430 \u043a\u043e\u043f\u0438\u044f, \u043d\u0435\u043e\u0431\u0445\u043e\u0434\u0438\u043c\u043e \u044f\u0432\u043d\u043e \u0441\u043e\u0437\u0434\u0430\u0442\u044c \u0435\u0451. \u041f\u0435\u0440\u0435\u043c\u0435\u043d\u043d\u044b\u0435 \u043f\u0440\u0438\u043d\u044f\u0442\u043e \u043e\u0444\u043e\u0440\u043c\u043b\u044f\u0442\u044c \u0432 \u0437\u043c\u0435\u0438\u043d\u043e\u043c_\u0440\u0435\u0433\u0438\u0441\u0442\u0440\u0435 (snake_case), \u0430 \u0444\u0443\u043d\u043a\u0446\u0438\u0438 \u0432 \u043d\u0438\u0436\u043d\u0435\u0412\u0435\u0440\u0431\u043b\u044e\u0436\u0435\u043c\u0420\u0435\u0433\u0438\u0441\u0442\u0440\u0435 (lowerCamelCase). \u041d\u0438\u0436\u0435 \u043c\u044b \u043e\u0431\u044a\u044f\u0432\u043b\u044f\u0435\u043c \u0438 \u0432\u044b\u0437\u044b\u0432\u0430\u0435\u043c \u043f\u0440\u043e\u0441\u0442\u0443\u044e \u0444\u0443\u043a\u043d\u0446\u0438\u044e.</p> <pre><code>fn addFive(x: u32) u32 {\nreturn x + 5;\n}\n\ntest \"\u0412\u044b\u0437\u043e\u0432 \u0444\u0443\u043d\u043a\u0446\u0438\u0438 addFive\" {\nconst y = addFive(0);\ntry expect(@TypeOf(y) == u32);\ntry expect(y == 5);\n}\n</code></pre> <p>\u0412\u044b \u0442\u0430\u043a\u0436\u0435 \u043c\u043e\u0436\u0435\u0442\u0435 \u0438\u0441\u043f\u043e\u043b\u044c\u0437\u043e\u0432\u0430\u0442\u044c \u0440\u0435\u043a\u0443\u0440\u0441\u0438\u044e (\u0432\u044b\u0437\u044b\u0432\u0430\u0442\u044c \u0444\u0443\u043d\u043a\u0446\u0438\u044e \u0432\u043d\u0443\u0442\u0440\u0438 \u0441\u0435\u0431\u044f):</p> <pre><code>fn fibonacci(n: u16) u16 {\nif (n == 0 or n == 1) return n;\nreturn fibonacci(n - 1) + fibonacci(n - 2);\n}\n\ntest \"\u0412\u044b\u0437\u043e\u0432 \u0440\u0435\u043a\u0443\u0440\u0441\u0438\u0432\u043d\u043e\u0439 \u0444\u0443\u043d\u043a\u0446\u0438\u0438 fibonacci\" {\nconst x = fibonacci(10);\ntry expect(x == 55);\n}\n</code></pre> <p>\u041a\u043e\u0433\u0434\u0430 \u0441\u043b\u0443\u0447\u0430\u0435\u0442\u0441\u044f \u0440\u0435\u043a\u0443\u0440\u0441\u0438\u044f, \u043a\u043e\u043c\u043f\u0438\u043b\u044f\u0442\u043e\u0440 \u0443\u0436\u0435 \u043d\u0435 \u043c\u043e\u0436\u0435\u0442 \u043f\u0440\u0435\u0434\u0432\u0430\u0440\u0438\u0442\u0435\u043b\u044c\u043d\u043e \u0440\u0430\u0441\u0441\u0447\u0438\u0442\u0430\u0442\u044c \u043c\u0430\u043a\u0441\u0438\u043c\u0430\u043b\u044c\u043d\u044b\u0439 \u0440\u0430\u0437\u043c\u0435\u0440 \u0441\u0442\u0435\u043a\u0430. \u042d\u0442\u043e \u043c\u043e\u0436\u0435\u0442 \u043f\u0440\u0438\u0432\u0435\u0441\u0442\u0438 \u043a \u043d\u0435\u0431\u0435\u0437\u043e\u043f\u0430\u0441\u043d\u043e\u043c\u0443 \u043f\u043e\u0432\u0435\u0434\u0435\u043d\u0438\u044e \u2014 \u0441\u0442\u0435\u043a \u043c\u043e\u0436\u0435\u0442 \u043f\u0435\u0440\u0435\u043f\u043e\u043b\u043d\u0438\u0442\u044c\u0441\u044f. \u041e \u0442\u043e\u043c, \u043a\u0430\u043a \u0434\u043e\u0431\u0438\u0442\u044c\u0441\u044f \u0431\u0435\u0437\u043e\u043f\u0430\u0441\u043d\u043e\u0439 \u0440\u0435\u043a\u0443\u0440\u0441\u0438\u0438, \u0431\u0443\u0434\u0435\u0442 \u043d\u0430\u043f\u0438\u0441\u0430\u043d\u043e \u0432 \u0431\u0443\u0434\u0443\u0449\u0435\u043c.</p> <p>\u0417\u043d\u0430\u0447\u0435\u043d\u0438\u044f \u043c\u043e\u0436\u043d\u043e \u0438\u0433\u043d\u043e\u0440\u0438\u0440\u043e\u0432\u0430\u0442\u044c, \u0438\u0441\u043f\u043e\u043b\u044c\u0437\u0443\u044f <code>_</code> \u0432\u043c\u0435\u0441\u0442\u043e \u043e\u0431\u044a\u044f\u0432\u043b\u0435\u043d\u0438\u044f \u043f\u0435\u0440\u0435\u043c\u0435\u043d\u043d\u043e\u0439 \u0438\u043b\u0438 \u043a\u043e\u043d\u0441\u0442\u0430\u043d\u0442\u044b. \u042d\u0442\u043e \u043d\u0435 \u0440\u0430\u0431\u043e\u0442\u0430\u0435\u0442 \u0438 \u043d\u0435 \u043d\u0443\u0436\u043d\u043e \u0432 \u0433\u043b\u043e\u0431\u0430\u043b\u044c\u043d\u043e\u0439 \u043e\u0431\u043b\u0430\u0441\u0442\u0438 \u0432\u0438\u0434\u0438\u043c\u043e\u0441\u0442\u0438 (\u0442.\u0435. \u0440\u0430\u0431\u043e\u0442\u0430\u0435\u0442 \u0442\u043e\u043b\u044c\u043a\u043e \u0432\u043d\u0443\u0442\u0440\u0438 \u0444\u0443\u043d\u043a\u0446\u0438\u0439 \u0438 \u0431\u043b\u043e\u043a\u043e\u0432) \u0438 \u043f\u043e\u043b\u0435\u0437\u043d\u043e \u0434\u043b\u044f \u0438\u0433\u043d\u043e\u0440\u0438\u0440\u043e\u0432\u0430\u043d\u0438\u044f \u0437\u043d\u0430\u0447\u0435\u043d\u0438\u0439, \u0435\u0441\u043b\u0438 \u043e\u043d\u0438 \u0432\u0430\u043c \u043d\u0435 \u043d\u0443\u0436\u043d\u044b.</p> <pre><code>_ = 10;\n</code></pre>"},{"location":"ru/chapter-1/#defer","title":"Defer","text":"<p>\u041e\u043f\u0435\u0440\u0430\u0442\u043e\u0440 defer \u0438\u0441\u043f\u043e\u043b\u044c\u0437\u0443\u0435\u0442\u0441\u044f \u0434\u043b\u044f \u0432\u044b\u043f\u043e\u043b\u043d\u0435\u043d\u0438\u044f \u0432\u044b\u0440\u0430\u0436\u0435\u043d\u0438\u044f \u0432\u043e \u0432\u0440\u0435\u043c\u044f \u0432\u044b\u0445\u043e\u0434\u0430 \u0438\u0437 \u0442\u0435\u043a\u0443\u0449\u0435\u0439 \u043e\u0431\u043b\u0430\u0441\u0442\u0438 \u0432\u0438\u0434\u0438\u043c\u043e\u0441\u0442\u0438.</p> <pre><code>test \"\u041e\u043f\u0435\u0440\u0430\u0442\u043e\u0440 defer\" {\nvar x: i16 = 5;\n{\ndefer x += 2;\ntry expect(x == 5);\n}\ntry expect(x == 7);\n}\n</code></pre> <p>\u0415\u0441\u043b\u0438 \u0432 \u043e\u0434\u043d\u043e\u043c \u0431\u043b\u043e\u043a\u0435 \u043d\u0430\u0445\u043e\u0434\u044f\u0442\u0441\u044f \u043d\u0435\u0441\u043a\u043e\u043b\u044c\u043a\u043e \u043e\u043f\u0435\u0440\u0430\u0442\u043e\u0440\u043e\u0432 defer, \u043e\u043d\u0438 \u0432\u044b\u043f\u043e\u043b\u043d\u044f\u044e\u0442\u0441\u044f \u0432 \u043e\u0431\u0440\u0430\u0442\u043d\u043e\u043c \u043f\u043e\u0440\u044f\u0434\u043a\u0435 (\u0441\u043d\u0438\u0437\u0443 \u0432\u0432\u0435\u0440\u0445).</p> <pre><code>test \"\u041c\u043d\u043e\u0436\u0435\u0441\u0442\u0432\u043e \u043e\u043f\u0435\u0440\u0430\u0442\u043e\u0440\u043e\u0432 defer\" {\nvar x: f32 = 5;\n{\ndefer x += 2;\ndefer x /= 2;\n}\ntry expect(x == 4.5);\n}\n</code></pre>"},{"location":"ru/chapter-1/#_3","title":"\u041e\u0448\u0438\u0431\u043a\u0438","text":"<p>\u041c\u043d\u043e\u0436\u0435\u0441\u0442\u0432\u043e \u043e\u0448\u0438\u0431\u043e\u043a (error set) \u043f\u043e\u0445\u043e\u0436\u0435 \u043d\u0430 \u043f\u0435\u0440\u0435\u0447\u0438\u0441\u043b\u0435\u043d\u0438\u044f (\u043f\u043e\u0434\u0440\u043e\u0431\u043d\u0435\u0435 \u043e \u043f\u0435\u0440\u0435\u0447\u0438\u0441\u043b\u0435\u043d\u0438\u044f\u0445 \u0432 Zig \u043f\u043e\u0437\u0436\u0435), \u043d\u043e \u0432 \u043a\u0430\u0447\u0435\u0441\u0442\u0432\u0435 \u044d\u043b\u0435\u043c\u0435\u043d\u0442\u043e\u0432 \u0438\u0441\u043f\u043e\u043b\u044c\u0437\u0443\u044e\u0442\u0441\u044f \u043a\u043e\u0434\u044b \u043e\u0448\u0438\u0431\u043e\u043a. \u0412 Zig \u043d\u0435 \u0441\u0443\u0449\u0435\u0441\u0442\u0432\u0443\u0435\u0442 \u0438\u0441\u043a\u043b\u044e\u0447\u0435\u043d\u0438\u0439 \u2014 \u043e\u0448\u0438\u0431\u043a\u0438 \u043e\u0431\u0440\u0430\u0431\u0430\u0442\u044b\u0432\u0430\u044e\u0442\u0441\u044f \u043a\u0430\u043a \u043e\u0431\u044b\u0447\u043d\u044b\u0435 \u0437\u043d\u0430\u0447\u0435\u043d\u0438\u044f. \u0414\u0430\u0432\u0430\u0439\u0442\u0435 \u0441\u043e\u0437\u0434\u0430\u0434\u0438\u043c \u043c\u043d\u043e\u0436\u0435\u0441\u0442\u0432\u043e \u043e\u0448\u0438\u0431\u043e\u043a.</p> <pre><code>const FileOpenError = error{\nAccessDenied,\nOutOfMemory,\nFileNotFound,\n};\n</code></pre> <p>\u041c\u043d\u043e\u0436\u0435\u0441\u0442\u0432\u043e \u043e\u0448\u0438\u0431\u043e\u043a \u043c\u043e\u0436\u043d\u043e \u043f\u0440\u0438\u0432\u0435\u0441\u0442\u0438 \u043a \u0435\u0433\u043e \u043d\u0430\u0434\u043c\u043d\u043e\u0436\u0435\u0441\u0442\u0432\u0443.</p> <pre><code>const AllocationError = error{OutOfMemory};\n\ntest \"\u041f\u0440\u0438\u0432\u0435\u0434\u0435\u043d\u0438\u0435 \u043e\u0448\u0438\u0431\u043a\u0438 \u0438\u0437 \u043f\u043e\u0434\u043c\u043d\u043e\u0436\u0435\u0441\u0442\u0432\u0430 \u043a \u043d\u0430\u0434\u043c\u043d\u043e\u0436\u0435\u0441\u0442\u0432\u0443\" {\nconst err: FileOpenError = AllocationError.OutOfMemory;\ntry expect(err == FileOpenError.OutOfMemory);\n}\n</code></pre> <p>\u0422\u0438\u043f \u00ab\u043c\u043d\u043e\u0436\u0435\u0441\u0442\u0432\u043e \u043e\u0448\u0438\u0431\u043e\u043a\u00bb \u0438 \u0442\u0438\u043f \u043e\u0431\u044b\u0447\u043d\u044b\u0445 \u0437\u043d\u0430\u0447\u0435\u043d\u0438\u0439 \u043c\u043e\u0436\u043d\u043e \u0441\u043e\u0435\u0434\u0438\u043d\u0438\u0442\u044c \u0441 \u043f\u043e\u043c\u043e\u0449\u044c\u044e \u043e\u043f\u0435\u0440\u0430\u0442\u043e\u0440\u0430 <code>!</code> \u0434\u043b\u044f \u0444\u043e\u0440\u043c\u0438\u0440\u043e\u0432\u0430\u043d\u0438\u044f \u0442\u0438\u043f\u0430 \u00ab\u043e\u0431\u044a\u0435\u0434\u0438\u043d\u0435\u043d\u0438\u0435 \u0441 \u043e\u0448\u0438\u0431\u043a\u043e\u0439\u00bb (error union type). \u042d\u0442\u043e\u0442 \u0442\u0438\u043f \u0441\u043e\u0434\u0435\u0440\u0436\u0438\u0442 \u0438\u043b\u0438 \u043e\u0448\u0438\u0431\u043a\u0443, \u0438\u043b\u0438 \u043e\u0431\u044b\u0447\u043d\u043e\u0435 \u0437\u043d\u0430\u0447\u0435\u043d\u0438\u0435.</p> <p>\u0414\u0430\u0432\u0430\u0439\u0442\u0435 \u0441\u043e\u0437\u0434\u0430\u0434\u0438\u043c \u0437\u043d\u0430\u0447\u0435\u043d\u0438\u0435 \u0441 \u044d\u0442\u0438\u043c \u0442\u0438\u043f\u043e\u043c. \u0417\u0434\u0435\u0441\u044c \u0438\u0441\u043f\u043e\u043b\u044c\u0437\u0443\u0435\u0442\u0441\u044f \u043e\u043f\u0435\u0440\u0430\u0442\u043e\u0440 <code>catch</code>, \u0437\u0430 \u043a\u043e\u0442\u043e\u0440\u044b\u043c \u0434\u043e\u043b\u0436\u043d\u043e \u0441\u043b\u0435\u0434\u043e\u0432\u0430\u0442\u044c \u0432\u044b\u0440\u0430\u0436\u0435\u043d\u0438\u0435, \u043a\u043e\u0442\u043e\u0440\u043e\u0435 \u0432\u044b\u043f\u043e\u043b\u043d\u044f\u0435\u0442\u0441\u044f, \u0435\u0441\u043b\u0438 \u0437\u043d\u0430\u0447\u0435\u043d\u0438\u0435 \u044f\u0432\u043b\u044f\u0435\u0442\u0441\u044f \u043e\u0448\u0438\u0431\u043a\u043e\u0439. \u0417\u0434\u0435\u0441\u044c \u043c\u044b \u0438\u0441\u043f\u043e\u043b\u044c\u0437\u0443\u0435\u043c \u044d\u0442\u043e\u0442 \u043e\u043f\u0435\u0440\u0430\u0442\u043e\u0440 \u0434\u043b\u044f \u0432\u044b\u0441\u0442\u0430\u0432\u043b\u0435\u043d\u0438\u044f \u0440\u0435\u0437\u0435\u0440\u0432\u043d\u043e\u0433\u043e \u0437\u043d\u0430\u0447\u0435\u043d\u0438\u044f \u043d\u0430 \u0441\u043b\u0443\u0447\u0430\u0439 \u043e\u0448\u0438\u0431\u043a\u0438, \u043d\u043e \u0432\u043c\u0435\u0441\u0442\u043e \u043d\u0435\u0433\u043e \u043c\u043e\u0436\u0435\u0442 \u0438\u0434\u0442\u0438 \u0442\u0438\u043f <code>noreturn</code> \u2014 \u0442\u0438\u043f \u0432\u044b\u0440\u0430\u0436\u0435\u043d\u0438\u0439 <code>return</code>, <code>while (true)</code> \u0438 \u0442.\u0434, \u043e\u0437\u043d\u0430\u0447\u0430\u044e\u0449\u0438\u0439, \u0447\u0442\u043e \u0437\u0434\u0435\u0441\u044c \u043d\u0430\u0445\u043e\u0434\u0438\u0442\u0441\u044f \u0442\u043e\u0447\u043a\u0430 \u043d\u0435\u0432\u043e\u0437\u0432\u0440\u0430\u0442\u0430.</p> <pre><code>test \"\u041e\u0431\u044a\u0435\u0434\u0438\u043d\u0435\u043d\u0438\u0435 \u0441 \u043e\u0448\u0438\u0431\u043a\u043e\u0439\" {\nconst maybe_error: AllocationError!u16 = 10;\nconst no_error = maybe_error catch 0;\n\ntry expect(@TypeOf(no_error) == u16);\ntry expect(no_error == 10);\n}\n</code></pre> <p>\u0424\u0443\u043d\u043a\u0446\u0438\u0438 \u0447\u0430\u0441\u0442\u043e \u0432\u043e\u0437\u0432\u0440\u0430\u0449\u0430\u044e\u0442 \u043e\u0431\u044a\u0435\u0434\u0438\u043d\u0435\u043d\u0438\u0435 \u0441 \u043e\u0448\u0438\u0431\u043a\u043e\u0439. \u0412\u043e\u0442 \u043f\u0440\u0438\u043c\u0435\u0440 \u0438\u0441\u043f\u043e\u043b\u044c\u0437\u043e\u0432\u0430\u043d\u0438\u044f \u043e\u043f\u0435\u0440\u0430\u0442\u043e\u0440\u0430 catch, \u0433\u0434\u0435 \u0432 <code>|err|</code> \u043f\u0435\u0440\u0435\u0434\u0430\u0451\u0442\u0441\u044f \u043a\u043e\u0434 \u043e\u0448\u0438\u0431\u043a\u0438. \u042d\u0442\u043e\u0442 \u0441\u0438\u043d\u0442\u0430\u043a\u0441\u0438\u0441 \u043d\u0430\u0437\u044b\u0432\u0430\u0435\u0442\u0441\u044f \u0437\u0430\u0445\u0432\u0430\u0442\u043e\u043c \u0437\u043d\u0430\u0447\u0435\u043d\u0438\u044f (payload capturing) \u0438 \u0438\u0441\u043f\u043e\u043b\u044c\u0437\u0443\u0435\u0442\u0441\u044f \u0430\u043d\u0430\u043b\u043e\u0433\u0438\u0447\u043d\u044b\u043c \u043e\u0431\u0440\u0430\u0437\u043e\u043c \u0432\u043e \u043c\u043d\u043e\u0433\u0438\u0445 \u043c\u0435\u0441\u0442\u0430\u0445. \u0414\u0430\u043b\u0435\u0435 \u0432 \u0433\u043b\u0430\u0432\u0435 \u043c\u044b \u043f\u043e\u0433\u043e\u0432\u043e\u0440\u0438\u043c \u043e\u0431 \u044d\u0442\u043e\u043c \u043f\u043e\u0434\u0440\u043e\u0431\u043d\u0435\u0435. \u041f\u0440\u0438\u043c\u0435\u0447\u0430\u043d\u0438\u0435: \u043d\u0435\u043a\u043e\u0442\u043e\u0440\u044b\u0435 \u044f\u0437\u044b\u043a\u0438 \u0438\u0441\u043f\u043e\u043b\u044c\u0437\u0443\u044e\u0442 \u043f\u043e\u0434\u043e\u0431\u043d\u044b\u0439 \u0441\u0438\u043d\u0442\u0430\u043a\u0441\u0438\u0441 \u0434\u043b\u044f \u043b\u044f\u043c\u0431\u0434\u0430-\u0432\u044b\u0440\u0430\u0436\u0435\u043d\u0438\u0439 \u2014 \u044d\u0442\u043e \u043d\u0435 \u043e\u0442\u043d\u043e\u0441\u0438\u0442\u0441\u044f \u043a Zig.</p> <pre><code>fn failingFunction() error{Oops}!void {\nreturn error.Oops;\n}\n\ntest \"\u0412\u043e\u0437\u0432\u0440\u0430\u0442 \u043e\u0448\u0438\u0431\u043a\u0438 \u0438 \u0435\u0451 \u0437\u0430\u0445\u0432\u0430\u0442 \u0441 \u043f\u043e\u043c\u043e\u0449\u044c\u044e catch\" {\nfailingFunction() catch |err| {\ntry expect(err == error.Oops);\nreturn;\n};\n}\n</code></pre> <p><code>try x</code> \u044f\u0432\u043b\u044f\u0435\u0442\u0441\u044f \u043a\u0440\u0430\u0442\u043a\u043e\u0439 \u0437\u0430\u043f\u0438\u0441\u044c\u044e \u0432\u044b\u0440\u0430\u0436\u0435\u043d\u0438\u044f <code>x catch |err| return err</code> \u0438 \u043e\u0431\u044b\u0447\u043d\u043e \u0438\u0441\u043f\u043e\u043b\u044c\u0437\u0443\u0435\u0442\u0441\u044f \u0432 \u043c\u0435\u0441\u0442\u0430\u0445, \u0433\u0434\u0435 \u043e\u0431\u0440\u0430\u0431\u043e\u0442\u043a\u0430 \u043e\u0448\u0438\u0431\u043a\u0438 \u043d\u0435\u0443\u043c\u0435\u0441\u0442\u043d\u0430. \u041e\u043f\u0435\u0440\u0430\u0442\u043e\u0440\u044b <code>try</code> \u0438 <code>catch</code> \u0432 Zig \u043d\u0435 \u0441\u0432\u044f\u0437\u0430\u043d\u044b \u0441 \u043a\u043e\u043d\u0441\u0442\u0440\u0443\u043a\u0446\u0438\u0435\u0439 try-catch \u0432 \u0434\u0440\u0443\u0433\u0438\u0445 \u044f\u0437\u044b\u043a\u0430\u0445.</p> <pre><code>fn failFn() error{Oops}!i32 {\ntry failingFunction();\nreturn 12;\n}\n\ntest \"\u041e\u043f\u0435\u0440\u0430\u0442\u043e\u0440 try\" {\nvar v = failFn() catch |err| {\ntry expect(err == error.Oops);\nreturn;\n};\ntry expect(v == 12); // \u0442\u0435\u0441\u0442 \u043d\u0435 \u0434\u043e\u0445\u043e\u0434\u0438\u0442 \u0434\u043e \u044d\u0442\u043e\u0439 \u0441\u0442\u0440\u043e\u043a\u0438\n}\n</code></pre> <p>\u041e\u043f\u0435\u0440\u0430\u0442\u043e\u0440 <code>errdefer</code> \u0441\u0445\u043e\u0436 \u0441 <code>defer</code>, \u043d\u043e \u0432\u044b\u043f\u043e\u043b\u043d\u044f\u0435\u0442 \u0432\u044b\u0440\u0430\u0436\u0435\u043d\u0438\u0435 \u0442\u043e\u043b\u044c\u043a\u043e \u0432 \u0442\u043e\u043c \u0441\u043b\u0443\u0447\u0430\u0435, \u0435\u0441\u043b\u0438 \u0432 \u0431\u043b\u043e\u043a\u0435 \u0444\u0443\u043d\u043a\u0446\u0438\u0438 \u0441 <code>errdefer</code> \u0431\u044b\u043b\u0430 \u0432\u043e\u0437\u0432\u0440\u0430\u0449\u0435\u043d\u0430 \u043e\u0448\u0438\u0431\u043a\u0430.</p> <pre><code>var problems: u32 = 98;\n\nfn failFnCounter() error{Oops}!void {\nerrdefer problems += 1;\ntry failingFunction();\n}\n\ntest \"\u041e\u043f\u0435\u0440\u0430\u0442\u043e\u0440 errdefer\" {\nfailFnCounter() catch |err| {\ntry expect(err == error.Oops);\ntry expect(problems == 99);\nreturn;\n};\n}\n</code></pre> <p>\u0415\u0441\u043b\u0438 \u0444\u0443\u043d\u043a\u0446\u0438\u044f \u0432\u043e\u0437\u0432\u0440\u0430\u0449\u0430\u0435\u0442 \u043e\u0431\u044a\u0435\u0434\u0438\u043d\u0435\u043d\u0438\u0435 \u0441 \u043e\u0448\u0438\u0431\u043a\u043e\u0439 \u0438 \u043c\u043d\u043e\u0436\u0435\u0441\u0442\u0432\u043e \u043e\u0448\u0438\u0431\u043e\u043a \u043d\u0435 \u0443\u043a\u0430\u0437\u0430\u043d\u043e \u044f\u0432\u043d\u043e, \u043e\u043d\u043e \u0431\u0443\u0434\u0435\u0442 \u0432\u044b\u0432\u0435\u0434\u0435\u043d\u043e. \u042d\u0442\u043e \u0432\u044b\u0432\u0435\u0434\u0435\u043d\u043d\u043e\u0435 \u043c\u043d\u043e\u0436\u0435\u0441\u0442\u0432\u043e \u0441\u043e\u0434\u0435\u0440\u0436\u0438\u0442 \u0432\u0441\u0435 \u0432\u043e\u0437\u043c\u043e\u0436\u043d\u044b\u0435 \u043e\u0448\u0438\u0431\u043a\u0438, \u043a\u043e\u0442\u043e\u0440\u044b\u0435 \u043c\u043e\u0436\u0435\u0442 \u0432\u0435\u0440\u043d\u0443\u0442\u044c \u044d\u0442\u0430 \u0444\u0443\u043d\u043a\u0446\u0438\u044f.</p> <pre><code>fn createFile() !void {\nreturn error.AccessDenied;\n}\n\ntest \"\u0412\u044b\u0432\u0435\u0434\u0435\u043d\u043d\u043e\u0435 \u043c\u043d\u043e\u0436\u0435\u0441\u0442\u0432\u043e \u043e\u0448\u0438\u0431\u043e\u043a\" {\n// \u0417\u0434\u0435\u0441\u044c \u043f\u0440\u043e\u0438\u0441\u0445\u043e\u0434\u0438\u0442 \u043f\u0440\u0438\u0432\u0435\u0434\u0435\u043d\u0438\u0435 \u0442\u0438\u043f\u0430\nconst x: error{AccessDenied}!void = createFile();\n\n// Zig \u043d\u0435 \u043f\u043e\u0437\u0432\u043e\u043b\u044f\u0435\u0442 \u043d\u0430\u043c \u0438\u0433\u043d\u043e\u0440\u0438\u0440\u043e\u0432\u0430\u0442\u044c \u043e\u0431\u044a\u0435\u0434\u0438\u043d\u0435\u043d\u0438\u0435 \u0441 \u043e\u0448\u0438\u0431\u043a\u043e\u0439\n// \u0441\u0438\u043d\u0442\u0430\u043a\u0441\u0438\u0441\u043e\u043c _ = x;\n// \u041c\u044b \u043e\u0431\u044f\u0437\u0430\u043d\u044b \u00ab\u0440\u0430\u0441\u043f\u0430\u043a\u043e\u0432\u0430\u0442\u044c\u00bb (unwrap) \u0432\u043e\u0437\u043c\u043e\u0436\u043d\u0443\u044e \u043e\u0448\u0438\u0431\u043a\u0443 \u0441 \u043f\u043e\u043c\u043e\u0449\u044c\u044e `try`, `catch` \u0438\u043b\u0438 \u0432\u0435\u0440\u0441\u0438\u0435\u0439 `if` \u0434\u043b\u044f \u043e\u0448\u0438\u0431\u043e\u043a\n_ = x catch {};\n}\n</code></pre> <p>\u041c\u043d\u043e\u0436\u0435\u0441\u0442\u0432\u0430 \u043e\u0448\u0438\u0431\u043e\u043a \u043c\u043e\u0436\u043d\u043e \u043e\u0431\u044a\u0435\u0434\u0438\u043d\u044f\u0442\u044c \u0432\u043c\u0435\u0441\u0442\u0435.</p> <pre><code>const A = error{ NotDir, PathNotFound };\nconst B = error{ OutOfMemory, PathNotFound };\nconst C = A || B;\n</code></pre> <p><code>anyerror</code> \u2014 \u044d\u0442\u043e \u0433\u043b\u043e\u0431\u0430\u043b\u044c\u043d\u043e\u0435 \u043c\u043d\u043e\u0436\u0435\u0441\u0442\u0432\u043e \u043e\u0448\u0438\u0431\u043e\u043a. \u041e\u043d\u043e \u044f\u0432\u043b\u044f\u0435\u0442\u0441\u044f \u043d\u0430\u0434\u043c\u043d\u043e\u0436\u0435\u0441\u0442\u0432\u043e\u043c \u0434\u043b\u044f \u0432\u0441\u0435\u0445 \u043c\u043d\u043e\u0436\u0435\u0441\u0442\u0432 \u043e\u0448\u0438\u0431\u043e\u043a \u0438 \u0441\u043e\u0434\u0435\u0440\u0436\u0438\u0442 \u0432\u0441\u0435 \u0432\u043e\u0437\u043c\u043e\u0436\u043d\u044b\u0435 \u043a\u043e\u0434\u044b \u043e\u0448\u0438\u0431\u043e\u043a. \u0412 \u0431\u043e\u043b\u044c\u0448\u0438\u043d\u0441\u0442\u0432\u0435 \u0441\u043b\u0443\u0447\u0430\u0435\u0432 \u0435\u0433\u043e \u0441\u043b\u0435\u0434\u0443\u0435\u0442 \u0438\u0437\u0431\u0435\u0433\u0430\u0442\u044c.</p>"},{"location":"ru/chapter-1/#switch","title":"Switch","text":"<p>\u041a\u043e\u043d\u0441\u0442\u0440\u0443\u043a\u0446\u0438\u044f <code>switch</code> \u0432 Zig \u0440\u0430\u0431\u043e\u0442\u0430\u0435\u0442 \u043a\u0430\u043a \u043e\u043f\u0435\u0440\u0430\u0442\u043e\u0440, \u0442\u0430\u043a \u0432\u044b\u0440\u0430\u0436\u0435\u043d\u0438\u0435. \u0420\u0435\u0437\u0443\u043b\u044c\u0442\u0430\u0442 \u0432\u043e \u0432\u0441\u0435\u0445 \u0432\u0435\u0442\u0432\u044f\u0445 \u0434\u043e\u043b\u0436\u0435\u043d \u043f\u0440\u0438\u0432\u043e\u0434\u0438\u0442\u044c\u0441\u044f \u043a \u0442\u0438\u043f\u0443 \u0440\u0435\u0437\u0443\u043b\u044c\u0442\u0430\u0442\u0430. \u0412\u0441\u0435 \u0432\u043e\u0437\u043c\u043e\u0436\u043d\u044b\u0435 \u0437\u043d\u0430\u0447\u0435\u043d\u0438\u044f \u0434\u043e\u043b\u0436\u043d\u044b \u0431\u044b\u0442\u044c \u044f\u0432\u043d\u043e \u0441\u043e\u043f\u043e\u0441\u0442\u0430\u0432\u043b\u0435\u043d\u044b \u0441 \u043a\u0430\u043a\u043e\u0439-\u0442\u043e \u0432\u0435\u0442\u0432\u044c\u044e. \u0418\u0437 \u043e\u0434\u043d\u0438\u0445 \u0432\u0435\u0442\u0432\u0435\u0439 \u043d\u0435\u043b\u044c\u0437\u044f \u043f\u043e\u043f\u0430\u0441\u0442\u044c \u0432 \u0434\u0440\u0443\u0433\u0438\u0435.</p> <p>\u041d\u0438\u0436\u0435 \u043f\u043e\u043a\u0430\u0437\u0430\u043d \u043f\u0440\u0438\u043c\u0435\u0440 \u0438\u0441\u043f\u043e\u043b\u044c\u0437\u043e\u0432\u0430\u043d\u0438\u044f <code>switch</code> \u0432 \u043a\u0430\u0447\u0435\u0441\u0442\u0432\u0435 \u043e\u043f\u0435\u0440\u0430\u0442\u043e\u0440\u0430. \u0412\u0435\u0442\u0432\u044c <code>else</code> \u0438\u0441\u043f\u043e\u043b\u044c\u0437\u0443\u0435\u0442\u0441\u044f \u0434\u043b\u044f \u0432\u0441\u0435\u0445 \u043e\u0441\u0442\u0430\u0432\u0448\u0438\u0445\u0441\u044f (\u043d\u0435 \u043f\u043e\u043a\u0440\u044b\u0442\u044b\u0445) \u0441\u043b\u0443\u0447\u0430\u0435\u0432 <code>x</code>.</p> <pre><code>test \"\u041e\u043f\u0435\u0440\u0430\u0442\u043e\u0440 \u043c\u043d\u043e\u0433\u043e\u0437\u043d\u0430\u0447\u043d\u043e\u0433\u043e \u0432\u044b\u0431\u043e\u0440\u0430 switch\" {\nvar x: i8 = 10;\nswitch (x) {\n-1...1 =&gt; {\nx = -x;\n},\n10, 100 =&gt; {\n// \u0421\u043b\u0435\u0434\u0443\u0435\u0442 \u0443\u0434\u0435\u043b\u044f\u0442\u044c \u043e\u0441\u043e\u0431\u043e\u0435 \u0432\u043d\u0438\u043c\u0430\u043d\u0438\u0435\n// \u043f\u0440\u0438 \u0434\u0435\u043b\u0435\u043d\u0438\u0438 \u0437\u043d\u0430\u043a\u043e\u0432\u044b\u0445 \u0447\u0438\u0441\u0435\u043b\nx = @divExact(x, 10);\n},\nelse =&gt; {},\n}\ntry expect(x == 1);\n}\n</code></pre> <p>\u0422\u043e\u0442 \u0436\u0435 \u043f\u0440\u0438\u043c\u0435\u0440, \u043d\u043e \u0441 <code>switch</code> \u0432 \u043a\u0430\u0447\u0435\u0441\u0442\u0432\u0435 \u0432\u044b\u0440\u0430\u0436\u0435\u043d\u0438\u044f.</p> <pre><code>test \"\u0412\u044b\u0440\u0430\u0436\u0435\u043d\u0438\u0435 \u0441 switch\" {\nvar x: i8 = 10;\nx = switch (x) {\n-1...1 =&gt; -x,\n10, 100 =&gt; @divExact(x, 10),\nelse =&gt; x,\n};\ntry expect(x == 1);\n}\n</code></pre>"},{"location":"ru/chapter-1/#_4","title":"\u0411\u0435\u0437\u043e\u043f\u0430\u0441\u043d\u043e\u0441\u0442\u044c \u0432\u043e \u0432\u0440\u0435\u043c\u044f \u0432\u044b\u043f\u043e\u043b\u043d\u0435\u043d\u0438\u044f","text":"<p>Zig \u043f\u0440\u0435\u0434\u043e\u0441\u0442\u0430\u0432\u043b\u044f\u0435\u0442 \u0443\u0440\u043e\u0432\u0435\u043d\u044c \u0431\u0435\u0437\u043e\u043f\u0430\u0441\u043d\u043e\u0441\u0442\u0438 \u00ab\u0432\u043e \u0432\u0440\u0435\u043c\u044f \u0432\u044b\u043f\u043e\u043b\u043d\u0435\u043d\u0438\u044f\u00bb (runtime safety), \u043f\u0440\u0438 \u043a\u043e\u0442\u043e\u0440\u043e\u043c \u043f\u0440\u043e\u0431\u043b\u0435\u043c\u044b \u043c\u043e\u0433\u0443\u0442 \u0431\u044b\u0442\u044c \u043d\u0430\u0439\u0434\u0435\u043d\u044b \u0432\u043e \u0432\u0440\u0435\u043c\u044f \u0432\u044b\u043f\u043e\u043b\u043d\u0435\u043d\u0438\u044f. \u042d\u0442\u0438 \u043f\u0440\u043e\u0432\u0435\u0440\u043a\u0438 \u043c\u043e\u0436\u043d\u043e \u0432\u043a\u043b\u044e\u0447\u0438\u0442\u044c \u0438\u043b\u0438 \u043e\u0442\u043a\u043b\u044e\u0447\u0438\u0442\u044c. \u0412 Zig \u0441\u0443\u0449\u0435\u0441\u0442\u0432\u0443\u0435\u0442 \u043a\u043e\u043d\u0446\u0435\u043f\u0446\u0438\u044f \u043e\u0431\u043d\u0430\u0440\u0443\u0436\u0438\u0432\u0430\u0435\u043c\u043e\u0433\u043e \u043d\u0435\u0434\u043e\u043f\u0443\u0441\u0442\u0438\u043c\u043e\u0433\u043e \u043f\u043e\u0432\u0435\u0434\u0435\u043d\u0438\u044f (detectable illegal behaviour) \u2014 \u0442\u0430\u043a\u043e\u0435 \u043f\u043e\u0432\u0435\u0434\u0435\u043d\u0438\u0435 \u043f\u0440\u0438 \u0432\u043a\u043b\u044e\u0447\u0435\u043d\u043d\u044b\u0445 \u043f\u0440\u043e\u0432\u0435\u0440\u043a\u0430\u0445 \u0431\u0443\u0434\u0435\u0442 \u043e\u0431\u043d\u0430\u0440\u0443\u0436\u0435\u043d\u043e (\u0432\u044b\u0437\u044b\u0432\u0430\u044f \u043f\u0430\u043d\u0438\u043a\u0443), \u0430 \u043f\u0440\u0438 \u043e\u0442\u043a\u043b\u044e\u0447\u0435\u043d\u043d\u044b\u0445 \u0441\u0442\u0430\u043d\u043e\u0432\u0438\u0442\u0441\u044f \u043d\u0435\u043e\u043f\u0440\u0435\u0434\u0435\u043b\u0435\u043d\u043d\u044b\u043c \u043f\u043e\u0432\u0435\u0434\u0435\u043d\u0438\u0435\u043c (undefined behaviour). \u041f\u043e\u043b\u044c\u0437\u043e\u0432\u0430\u0442\u0435\u043b\u044f\u043c \u0441\u0442\u0440\u043e\u0433\u043e \u0440\u0435\u043a\u043e\u043c\u0435\u043d\u0434\u0443\u0435\u0442\u0441\u044f \u0440\u0430\u0437\u0440\u0430\u0431\u0430\u0442\u044b\u0432\u0430\u0442\u044c \u0438 \u0442\u0435\u0441\u0442\u0438\u0440\u043e\u0432\u0430\u0442\u044c \u0440\u0430\u0437\u0440\u0430\u0431\u0430\u0442\u044b\u0432\u0430\u0435\u043c\u043e\u0435 \u041f\u041e \u0441 \u0432\u043a\u043b\u044e\u0447\u0435\u043d\u043d\u044b\u043c\u0438 \u043f\u0440\u043e\u0432\u0435\u0440\u043a\u0430\u043c\u0438, \u043d\u0435\u0441\u043c\u043e\u0442\u0440\u044f \u043d\u0430 \u0443\u0445\u0443\u0434\u0448\u0435\u043d\u0438\u0435 \u043f\u0440\u043e\u0438\u0437\u0432\u043e\u0434\u0438\u0442\u0435\u043b\u044c\u043d\u043e\u0441\u0442\u0438.</p> <p>\u041e\u0434\u043d\u0438\u043c \u0438\u0437 \u043f\u0440\u0438\u043c\u0435\u0440\u043e\u0432 \u043e\u0431\u043d\u0430\u0440\u0443\u0436\u0438\u0432\u0430\u0435\u043c\u043e\u0433\u043e \u043d\u0435\u0434\u043e\u043f\u0443\u0441\u0442\u0438\u043c\u043e\u0433\u043e \u043f\u043e\u0432\u0435\u0434\u0435\u043d\u0438\u044f \u044f\u0432\u043b\u044f\u0435\u0442\u0441\u044f \u00ab\u0432\u044b\u0445\u043e\u0434 \u0437\u0430 \u0434\u0438\u0430\u043f\u0430\u0437\u043e\u043d \u0434\u043e\u043f\u0443\u0441\u0442\u0438\u043c\u044b\u0445 \u0438\u043d\u0434\u0435\u043a\u0441\u043e\u0432\u00bb.</p> <p><pre><code>test \"\u0412\u044b\u0445\u043e\u0434 \u0437\u0430 \u0433\u0440\u0430\u043d\u0438\u0446\u044b \u043c\u0430\u0441\u0441\u0438\u0432\u0430 \u0432\u043e \u0432\u0440\u0435\u043c\u044f \u0432\u044b\u043f\u043e\u043b\u043d\u0435\u043d\u0438\u044f\" {\nconst a = [3]u8{ 1, 2, 3 };\nvar index: u8 = 5;\nconst b = a[index];\n_ = b;\n}\n</code></pre> <pre><code>Test [1/1] test.\u0412\u044b\u0445\u043e\u0434 \u0437\u0430 \u0433\u0440\u0430\u043d\u0438\u0446\u044b \u043c\u0430\u0441\u0441\u0438\u0432\u0430 \u0432\u043e \u0432\u0440\u0435\u043c\u044f \u0432\u044b\u043f\u043e\u043b\u043d\u0435\u043d\u0438... thread 8964 panic: index out of bounds: index 5, len 3\n./tests.zig:4:16: 0x2246e1 in test.\u0412\u044b\u0445\u043e\u0434 \u0437\u0430 \u0433\u0440\u0430\u043d\u0438\u0446\u044b \u043c\u0430\u0441\u0441\u0438\u0432\u0430 \u0432\u043e \u0432\u0440\u0435\u043c\u044f \u0432\u044b\u043f\u043e\u043b\u043d\u0435\u043d\u0438\u044f (test)\n    const b = a[index];\n               ^\n</code></pre></p> <p>\u041f\u043e \u0443\u043c\u043e\u043b\u0447\u0430\u043d\u0438\u044e \u043f\u0440\u043e\u0432\u0435\u0440\u043a\u0438 \u0432\u043a\u043b\u044e\u0447\u0435\u043d\u044b \u0434\u043b\u044f \u0440\u0435\u0436\u0438\u043c\u043e\u0432 \u0441\u0431\u043e\u0440\u043a\u0438 <code>Debug</code> \u0438 <code>ReleaseSafe</code> \u0438 \u043e\u0442\u043a\u043b\u044e\u0447\u0435\u043d\u044b \u0434\u043b\u044f <code>ReleaseFast</code> \u0438 <code>ReleaseSmall</code> (\u043f\u043e\u0434\u0440\u043e\u0431\u043d\u0435\u0435 \u043e \u0440\u0435\u0436\u0438\u043c\u0430\u0445 \u0441\u0431\u043e\u0440\u043a\u0438 \u0432 \u0441\u043b\u0435\u0434\u0443\u044e\u0449\u0438\u0445 \u0433\u043b\u0430\u0432\u0430\u0445). \u041f\u043e\u043b\u044c\u0437\u043e\u0432\u0430\u0442\u0435\u043b\u044c \u043c\u043e\u0436\u0435\u0442 \u043f\u0440\u0438\u043d\u0443\u0434\u0438\u0442\u0435\u043b\u044c\u043d\u043e (\u0434\u043b\u044f \u043b\u044e\u0431\u043e\u0433\u043e \u0440\u0435\u0436\u0438\u043c\u0430 \u0441\u0431\u043e\u0440\u043a\u0438) \u0432\u043a\u043b\u044e\u0447\u0438\u0442\u044c \u0438\u043b\u0438 \u043e\u0442\u043a\u043b\u044e\u0447\u0438\u0442\u044c \u044d\u0442\u0438 \u043f\u0440\u043e\u0432\u0435\u0440\u043a\u0438, \u0438\u0441\u043f\u043e\u043b\u044c\u0437\u0443\u044f \u0432 \u043d\u0443\u0436\u043d\u043e\u043c \u0431\u043b\u043e\u043a\u0435 \u0432\u0441\u0442\u0440\u043e\u0435\u043d\u043d\u0443\u044e \u0444\u0443\u043d\u043a\u0446\u0438\u044e <code>@setRuntimeSafety</code>.</p> <pre><code>test \"\u0412\u044b\u0445\u043e\u0434 \u0437\u0430 \u043f\u0440\u0435\u0434\u0435\u043b\u044b \u043c\u0430\u0441\u0441\u0438\u0432\u0430 \u0432\u043e \u0432\u0440\u0435\u043c\u044f \u0432\u044b\u043f\u043e\u043b\u043d\u0435\u043d\u0438\u044f, \u0431\u0435\u0437 \u043f\u0440\u043e\u0432\u0435\u0440\u043a\u0438\" {\n@setRuntimeSafety(false);\nconst a = [3]u8{ 1, 2, 3 };\nvar index: u8 = 5;\nconst b = a[index];\n_ = b;\n}\n</code></pre>"},{"location":"ru/chapter-1/#unreachable","title":"Unreachable","text":"<p>\u041e\u043f\u0435\u0440\u0430\u0442\u043e\u0440 <code>unreachable</code> \u0443\u0442\u0432\u0435\u0440\u0436\u0434\u0430\u0435\u0442, \u0447\u0442\u043e \u044d\u0442\u0430 \u0438\u043d\u0441\u0442\u0440\u0443\u043a\u0446\u0438\u044f \u043d\u0435\u0434\u043e\u0441\u0442\u0438\u0436\u0438\u043c\u0430. \u0421 \u043f\u043e\u043c\u043e\u0449\u044c\u044e \u043d\u0435\u0433\u043e \u0432\u044b \u043e\u0431\u0435\u0449\u0430\u0435\u0442\u0435 \u043a\u043e\u043c\u043f\u0438\u043b\u044f\u0442\u043e\u0440\u0443, \u0447\u0442\u043e \u0434\u0430\u043d\u043d\u0430\u044f \u0432\u0435\u0442\u0432\u044c \u043d\u0438\u043a\u043e\u0433\u0434\u0430 \u043d\u0435 \u0432\u044b\u043f\u043e\u043b\u043d\u0438\u0442\u0441\u044f, \u0431\u043b\u0430\u0433\u043e\u0434\u0430\u0440\u044f \u0447\u0435\u043c\u0443 \u043e\u043d \u043c\u043e\u0436\u0435\u0442 \u043f\u0440\u043e\u0438\u0437\u0432\u043e\u0434\u0438\u0442\u044c \u0431\u043e\u043b\u0435\u0435 \u0443\u043c\u043d\u044b\u0435 \u043e\u043f\u0442\u0438\u043c\u0438\u0437\u0430\u0446\u0438\u0438. \u0414\u043e\u0441\u0442\u0438\u0436\u0435\u043d\u0438\u0435 <code>unreachable</code> \u0441\u0447\u0438\u0442\u0430\u0435\u0442\u0441\u044f \u043d\u0430\u0440\u0443\u0448\u0435\u043d\u0438\u0435\u043c \u043e\u0431\u0435\u0449\u0430\u043d\u0438\u044f/\u043a\u043e\u043d\u0442\u0440\u0430\u043a\u0442\u0430 \u0438 \u043e\u0431\u043d\u0430\u0440\u0443\u0436\u0438\u0432\u0430\u0435\u043c\u044b\u043c \u043d\u0435\u0434\u043e\u043f\u0443\u0441\u0442\u0438\u043c\u044b\u043c \u043f\u043e\u0432\u0435\u0434\u0435\u043d\u0438\u0435\u043c.</p> <p>\u0422\u0430\u043a \u043a\u0430\u043a \u044d\u0442\u043e\u0442 \u043e\u043f\u0435\u0440\u0430\u0442\u043e\u0440 \u0438\u043c\u0435\u0435\u0442 \u0442\u0438\u043f <code>noreturn</code> (\u0442\u043e\u0447\u043a\u0438 \u043d\u0435\u0432\u043e\u0437\u0432\u0440\u0430\u0442\u0430), \u043e\u043d \u0441\u043e\u0432\u043c\u0435\u0441\u0442\u0438\u043c \u0441\u043e \u0432\u0441\u0435\u043c\u0438 \u0434\u0440\u0443\u0433\u0438\u043c\u0438 \u0442\u0438\u043f\u0430\u043c\u0438. \u0417\u0434\u0435\u0441\u044c \u043e\u043d \u0441\u043e\u0432\u043c\u0435\u0441\u0442\u0438\u043c \u0441 \u0442\u0438\u043f\u043e\u043c u32 \u0438 \u043f\u0440\u0438\u0432\u043e\u0434\u0438\u0442\u0441\u044f \u043a \u043d\u0435\u043c\u0443.</p> <p><pre><code>test \"\u0414\u043e\u0441\u0442\u0438\u0436\u0435\u043d\u0438\u0435 unreachable\" {\nconst x: i32 = 1;\nconst y: u32 = if (x == 2) 5 else unreachable;\n_ = y;\n}\n</code></pre> <pre><code>Test [1/1] test.\u0414\u043e\u0441\u0442\u0438\u0436\u0435\u043d\u0438\u0435 unreachable... thread 14125 panic: reached unreachable code\n./tests.zig:3:39: 0x2246f0 in test.\u0414\u043e\u0441\u0442\u0438\u0436\u0435\u043d\u0438\u0435 unreachable (test)\n    const y: u32 = if (x == 2) 5 else unreachable;\n                                      ^\n</code></pre></p> <p>\u0412 \u043f\u0440\u0438\u043c\u0435\u0440\u0435 \u043d\u0438\u0436\u0435 unreachable \u0438\u0441\u043f\u043e\u043b\u044c\u0437\u0443\u0435\u0442\u0441\u044f \u0434\u043b\u044f \u0443\u0442\u0432\u0435\u0440\u0436\u0434\u0435\u043d\u0438\u044f \u00ab\u0432\u0435\u0442\u0432\u044c else \u043d\u0438\u043a\u043e\u0433\u0434\u0430 \u043d\u0435 \u0432\u044b\u043f\u043e\u043b\u043d\u0438\u0442\u0441\u044f\u00bb. <pre><code>fn asciiToUpper(x: u8) u8 {\nreturn switch (x) {\n'a'...'z' =&gt; x + 'A' - 'a',\n'A'...'Z' =&gt; x,\nelse =&gt; unreachable,\n};\n}\n\ntest \"\u041e\u043f\u0435\u0440\u0430\u0442\u043e\u0440 unreachable \u0432 \u0432\u0435\u0442\u0432\u0438 switch\" {\ntry expect(asciiToUpper('a') == 'A');\ntry expect(asciiToUpper('A') == 'A');\n}\n</code></pre></p>"},{"location":"ru/chapter-1/#t","title":"\u0423\u043a\u0430\u0437\u0430\u0442\u0435\u043b\u044c \u043d\u0430 \u043e\u0434\u0438\u043d \u044d\u043b\u0435\u043c\u0435\u043d\u0442 (<code>*T</code>)","text":"<p>\u041e\u0431\u044b\u0447\u043d\u044b\u0435 \u0443\u043a\u0430\u0437\u0430\u0442\u0435\u043b\u0438 \u0432 Zig \u043d\u0435 \u043c\u043e\u0433\u0443\u0442 \u0438\u043c\u0435\u0442\u044c \u0437\u043d\u0430\u0447\u0435\u043d\u0438\u0435 0 \u0438\u043b\u0438 null. \u041e\u043d\u0438 \u0441\u043b\u0435\u0434\u0443\u044e\u0442 \u0441\u0438\u043d\u0442\u0430\u043a\u0441\u0438\u0441\u0443 <code>*T</code>, \u0447\u0442\u043e \u043e\u0437\u043d\u0430\u0447\u0430\u0435\u0442 \u00ab\u0443\u043a\u0430\u0437\u0430\u0442\u0435\u043b\u044c \u043d\u0430 \u043e\u0434\u043d\u043e \u0437\u043d\u0430\u0447\u0435\u043d\u0438\u0435 \u0442\u0438\u043f\u0430 T\u00bb.</p> <p>\u0423\u043a\u0430\u0437\u0430\u0442\u0435\u043b\u044c \u0441\u043e\u0437\u0434\u0430\u0451\u0442\u0441\u044f \u043f\u0440\u0438 \u043f\u043e\u043c\u043e\u0449\u0438 \u0441\u0438\u043d\u0442\u0430\u043a\u0441\u0438\u0441\u0430 <code>&amp;variable</code>, \u0430 \u0440\u0430\u0437\u044b\u043c\u0435\u043d\u043e\u0432\u044b\u0432\u0430\u0435\u0442\u0441\u044f \u043f\u0440\u0438 \u043f\u043e\u043c\u043e\u0449\u0438 <code>pointer.*</code>.</p> <pre><code>fn increment(num: *u8) void {\nnum.* += 1;\n}\n\ntest \"\u0423\u043a\u0430\u0437\u0430\u0442\u0435\u043b\u044c \u043d\u0430 \u043f\u0435\u0440\u0435\u043c\u0435\u043d\u043d\u0443\u044e\" {\nvar x: u8 = 1;\nincrement(&amp;x);\ntry expect(x == 2);\n}\n</code></pre> <p>\u041f\u043e\u043f\u044b\u0442\u043a\u0430 \u0443\u0441\u0442\u0430\u043d\u043e\u0432\u0438\u0442\u044c \u0437\u043d\u0430\u0447\u0435\u043d\u0438\u0435 0 \u0434\u043b\u044f \u0443\u043a\u0430\u0437\u0430\u0442\u0435\u043b\u044f <code>*T</code> \u0441\u0447\u0438\u0442\u0430\u0435\u0442\u0441\u044f \u043e\u0431\u043d\u0430\u0440\u0443\u0436\u0438\u0432\u0430\u0435\u043c\u044b\u043c \u043d\u0435\u0434\u043e\u043f\u0443\u0441\u0442\u0438\u043c\u044b\u043c \u043f\u043e\u0432\u0435\u0434\u0435\u043d\u0438\u0435\u043c.</p> <p><pre><code>test \"\u041d\u0435\u043f\u043e\u0441\u043b\u0443\u0448\u043d\u044b\u0439 \u0443\u043a\u0430\u0437\u0430\u0442\u0435\u043b\u044c\" {\nvar x: u16 = 0;\nvar y: *u8 = @ptrFromInt(x);\n_ = y;\n}\n</code></pre> <pre><code>Test [1/1] test.\u041d\u0435\u043f\u043e\u0441\u043b\u0443\u0448\u043d\u044b\u0439 \u0443\u043a\u0430\u0437\u0430\u0442\u0435\u043b\u044c... thread 15237 panic: cast causes pointer to be null\n/home/bratishkaerik/github.com/zighelp/tests.zig:3:18: 0x224711 in test.\u041d\u0435\u043f\u043e\u0441\u043b\u0443\u0448\u043d\u044b\u0439 \u0443\u043a\u0430\u0437\u0430\u0442\u0435\u043b\u044c (test)\n    var y: *u8 = @ptrFromInt(x);\n                 ^\n</code></pre></p> <p>Zig \u0442\u0430\u043a\u0436\u0435 \u0441\u043e\u0434\u0435\u0440\u0436\u0438\u0442 \u0443\u043a\u0430\u0437\u0430\u0442\u0435\u043b\u0438 \u043d\u0430 \u043a\u043e\u043d\u0441\u0442\u0430\u043d\u0442\u044b (const pointers) \u0432 \u0432\u0438\u0434\u0435 <code>*const T</code>, \u043a\u043e\u0442\u043e\u0440\u044b\u0435 \u043d\u0435\u043b\u044c\u0437\u044f \u0438\u0441\u043f\u043e\u043b\u044c\u0437\u043e\u0432\u0430\u0442\u044c \u0434\u043b\u044f \u0438\u0437\u043c\u0435\u043d\u0435\u043d\u0438\u044f \u0443\u043a\u0430\u0437\u044b\u0432\u0430\u0435\u043c\u043e\u0433\u043e \u0437\u043d\u0430\u0447\u0435\u043d\u0438\u044f.</p> <p><pre><code>test \"\u0423\u043a\u0430\u0437\u0430\u0442\u0435\u043b\u044c \u043d\u0430 \u043a\u043e\u043d\u0441\u0442\u0430\u043d\u0442\u0443\" {\nconst x: u8 = 1;\nvar y = &amp;x;\ny.* += 1;\n}\n</code></pre> <pre><code>error: cannot assign to constant\n    y.* += 1;\n    ~~~~^~~~\n</code></pre></p> <p>\u0422\u0438\u043f <code>*T</code> \u043c\u043e\u0436\u0435\u0442 \u0431\u044b\u0442\u044c \u0430\u0432\u0442\u043e\u043c\u0430\u0442\u0438\u0447\u0435\u0441\u043a\u0438 \u043f\u0440\u0438\u0432\u0435\u0434\u0451\u043d \u043a \u0442\u0438\u043f\u0443 <code>*const T</code>, \u043d\u043e \u043d\u0435 \u043d\u0430\u043e\u0431\u043e\u0440\u043e\u0442.</p>"},{"location":"ru/chapter-1/#usize-isize","title":"\u0426\u0435\u043b\u044b\u0435 \u0447\u0438\u0441\u043b\u0430 \u0440\u0430\u0437\u043c\u0435\u0440\u043e\u043c \u0441 \u0443\u043a\u0430\u0437\u0430\u0442\u0435\u043b\u044c: <code>usize</code> \u0438 <code>isize</code>","text":"<p>\u0422\u0438\u043f\u044b <code>usize</code> \u0438 <code>isize</code> \u0438\u0441\u043f\u043e\u043b\u044c\u0437\u0443\u044e\u0442\u0441\u044f \u0434\u043b\u044f \u043e\u0431\u044a\u044f\u0432\u043b\u0435\u043d\u0438\u044f \u0431\u0435\u0437\u0437\u043d\u0430\u043a\u043e\u0432\u044b\u0445 \u0438 \u0437\u043d\u0430\u043a\u043e\u0432\u044b\u0445 \u0446\u0435\u043b\u044b\u0445 \u0447\u0438\u0441\u0435\u043b \u0441\u043e\u043e\u0442\u0432\u0435\u0441\u0442\u0432\u0435\u043d\u043d\u043e \u0438 \u0438\u043c\u0435\u044e\u0442 \u0442\u043e\u0442 \u0436\u0435 \u0440\u0430\u0437\u043c\u0435\u0440, \u0447\u0442\u043e \u0438 \u0443\u043a\u0430\u0437\u0430\u0442\u0435\u043b\u0438 \u043d\u0430 \u0434\u0430\u043d\u043d\u043e\u0439 \u0430\u0440\u0445\u0438\u0442\u0435\u043a\u0442\u0443\u0440\u0435.</p> <pre><code>test \"\u0420\u0430\u0437\u043c\u0435\u0440\u044b usize \u0438 isize\" {\ntry expect(@sizeOf(usize) == @sizeOf(*u8));\ntry expect(@sizeOf(isize) == @sizeOf(*u8));\n}\n</code></pre>"},{"location":"ru/chapter-1/#t_1","title":"\u0423\u043a\u0430\u0437\u0430\u0442\u0435\u043b\u044c \u043d\u0430 \u043d\u0435\u0438\u0437\u0432\u0435\u0441\u0442\u043d\u043e\u0435 \u043a\u043e\u043b\u0438\u0447\u0435\u0441\u0442\u0432\u043e \u044d\u043b\u0435\u043c\u0435\u043d\u0442\u043e\u0432 (<code>[*]T</code>)","text":"<p>\u0418\u043d\u043e\u0433\u0434\u0430 \u0432\u0430\u043c \u043c\u043e\u0436\u0435\u0442 \u043f\u043e\u043d\u0430\u0434\u043e\u0431\u0438\u0442\u044c\u0441\u044f \u0443\u043a\u0430\u0437\u0430\u0442\u0435\u043b\u044c \u043d\u0430 \u043d\u0435\u0438\u0437\u0432\u0435\u0441\u0442\u043d\u043e\u0435 \u043a\u043e\u043b\u0438\u0447\u0435\u0441\u0442\u0432\u043e \u044d\u043b\u0435\u043c\u0435\u043d\u0442\u043e\u0432. \u0412 \u044d\u0442\u043e\u043c \u0441\u043b\u0443\u0447\u0430\u0435 \u0438\u0441\u043f\u043e\u043b\u044c\u0437\u0443\u0435\u0442\u0441\u044f \u0441\u0438\u043d\u0442\u0430\u043a\u0441\u0438\u0441 <code>[*]T</code> (\u0443\u043a\u0430\u0437\u0430\u0442\u0435\u043b\u044c \u043d\u0430 \u043d\u0435\u0438\u0437\u0432\u0435\u0441\u0442\u043d\u043e\u0435 \u043a\u043e\u043b\u0438\u0447\u0435\u0441\u0442\u0432\u043e \u044d\u043b\u0435\u043c\u0435\u043d\u0442\u043e\u0432 \u0441 \u0442\u0438\u043f\u043e\u043c T), \u043a\u043e\u0442\u043e\u0440\u044b\u0439 \u0441\u0445\u043e\u0436 \u0441 \u0443\u043a\u0430\u0437\u0430\u0442\u0435\u043b\u0435\u043c <code>*T</code>. \u0412 \u043e\u0442\u043b\u0438\u0447\u0438\u0438 \u043e\u0442 \u043f\u043e\u0441\u043b\u0435\u0434\u043d\u0435\u0433\u043e. \u044d\u0442\u043e\u0442 \u0443\u043a\u0430\u0437\u0430\u0442\u0435\u043b\u044c \u043f\u043e\u0434\u0434\u0435\u0440\u0436\u0438\u0432\u0430\u0435\u0442 \u0434\u043e\u0441\u0442\u0443\u043f \u043f\u043e \u0438\u043d\u0434\u0435\u043a\u0441\u0443, \u0430\u0440\u0438\u0444\u043c\u0435\u0442\u0438\u043a\u0443 \u0443\u043a\u0430\u0437\u0430\u0442\u0435\u043b\u0435\u0439 \u0438 \u043e\u0431\u0440\u0435\u0437\u0430\u043d\u0438\u0435 (slicing). \u0422\u0430\u043a\u0436\u0435 \u043e\u043d \u043d\u0435 \u043f\u043e\u0434\u0434\u0435\u0440\u0436\u0438\u0432\u0430\u0435\u0442 \u0442\u0438\u043f\u044b \u0441 \u043d\u0435\u0438\u0437\u0432\u0435\u0441\u0442\u043d\u044b\u043c \u0440\u0430\u0437\u043c\u0435\u0440\u043e\u043c. \u0422\u0438\u043f <code>*T</code> \u043f\u0440\u0438\u0432\u043e\u0434\u0438\u0442\u0441\u044f \u043a \u0442\u0438\u043f\u0443 <code>[*]T</code>.</p> <p>\u041e\u043d\u0438 \u043c\u043e\u0433\u0443\u0442 \u0443\u043a\u0430\u0437\u044b\u0432\u0430\u0442\u044c \u043d\u0430 \u043b\u044e\u0431\u043e\u0435 \u043a\u043e\u043b\u0438\u0447\u0435\u0441\u0442\u0432\u043e \u044d\u043b\u0435\u043c\u0435\u043d\u0442\u043e\u0432, \u0432\u043a\u043b\u044e\u0447\u0430\u044f 0 \u0438 1.</p>"},{"location":"ru/chapter-1/#t_2","title":"\u0421\u0440\u0435\u0437\u044b (<code>[]T</code>)","text":"<p>\u0421\u0440\u0435\u0437\u044b (slices) \u043c\u043e\u0436\u043d\u043e \u0440\u0430\u0441\u0441\u043c\u0430\u0442\u0440\u0438\u0432\u0430\u0442\u044c \u043a\u0430\u043a \u043e\u0431\u044a\u0435\u0434\u0438\u043d\u0435\u043d\u0438\u0435 <code>[*]T</code> (\u0443\u043a\u0430\u0437\u0430\u0442\u0435\u043b\u044c \u043d\u0430 \u0434\u0430\u043d\u043d\u044b\u0435) \u0438 <code>usize</code> (\u043a\u043e\u043b-\u0432\u043e \u044d\u043b\u0435\u043c\u0435\u043d\u0442\u043e\u0432). \u0421\u0438\u043d\u0442\u0430\u043a\u0441\u0438\u0441 \u0432\u044b\u0433\u043b\u044f\u0434\u0438\u0442 \u043f\u043e\u0434\u043e\u0431\u043d\u044b\u043c \u043e\u0431\u0440\u0430\u0437\u043e\u043c: <code>[]T</code>, \u0433\u0434\u0435 <code>T</code> \u044f\u0432\u043b\u044f\u0435\u0442\u0441\u044f \u0442\u0438\u043f\u043e\u043c \u0434\u043e\u0447\u0435\u0440\u043d\u0435\u0433\u043e \u044d\u043b\u0435\u043c\u0435\u043d\u0442\u0430. \u0421\u0440\u0435\u0437\u044b \u0448\u0438\u0440\u043e\u043a\u043e \u0438\u0441\u043f\u043e\u043b\u044c\u0437\u0443\u044e\u0442\u0441\u044f \u0432 \u044fZig, \u043a\u043e\u0433\u0434\u0430 \u043d\u0435\u043e\u0431\u0445\u043e\u0434\u0438\u043c\u043e \u043e\u043f\u0435\u0440\u0438\u0440\u043e\u0432\u0430\u0442\u044c \u0441 \u0434\u0430\u043d\u043d\u044b\u043c\u0438 \u0440\u0430\u0437\u043d\u043e\u0439 \u0434\u043b\u0438\u043d\u044b. \u0421\u0440\u0435\u0437\u044b \u043c\u043e\u0433\u0443\u0442 \u0441\u043e\u0434\u0435\u0440\u0436\u0430\u0442\u044c \u0442\u0435 \u0436\u0435 \u0430\u0442\u0440\u0438\u0431\u0443\u0442\u044b, \u0447\u0442\u043e \u0438 \u0443\u043a\u0430\u0437\u0430\u0442\u0435\u043b\u0438, \u043d\u0430\u043f\u0440. \u043a\u043e\u043d\u0441\u0442\u0430\u043d\u0442\u043d\u043e\u0441\u0442\u044c \u044d\u043b\u0435\u043c\u0435\u043d\u0442\u0430 (<code>[*]const T</code> \u0438 <code>[]const T</code>). \u041a\u0430\u043a \u0438 \u043c\u0430\u0441\u0441\u0438\u0432\u044b, \u0441\u0440\u0435\u0437\u044b \u043c\u043e\u0436\u043d\u043e \u0438\u0441\u043f\u043e\u043b\u044c\u0437\u043e\u0432\u0430\u0442\u044c \u0432 \u0446\u0438\u043a\u043b\u0430\u0445 for. \u0421\u0442\u0440\u043e\u043a\u043e\u0432\u044b\u0435 \u043b\u0438\u0442\u0435\u0440\u0430\u043b\u044b \u0432 Zig \u043c\u043e\u0433\u0443\u0442 \u0431\u044b\u0442\u044c \u043f\u0440\u0438\u0432\u0435\u0434\u0435\u043d\u044b \u043a \u0442\u0438\u043f\u0443 <code>[]const u8</code>.</p> <p>\u0414\u043b\u044f \u043e\u0431\u0440\u0435\u0437\u0430\u043d\u0438\u044f \u0447\u0430\u0441\u0442\u0438 \u043c\u0430\u0441\u0441\u0438\u0432\u0430 \u0438\u0441\u043f\u043e\u043b\u044c\u0437\u0443\u0435\u0442\u0441\u044f \u0441\u0438\u043d\u0442\u0430\u043a\u0441\u0438\u0441 <code>x[n..m]</code>. \u042d\u0442\u0430 \u043e\u043f\u0435\u0440\u0430\u0446\u0438\u044f \u043d\u0430\u0437\u044b\u0432\u0430\u0435\u0442\u0441\u044f \u043e\u0431\u0440\u0435\u0437\u0430\u043d\u0438\u0435\u043c \u0438 \u0441\u043e\u0437\u0434\u0430\u0451\u0442 \u0441\u0440\u0435\u0437 \u044d\u043b\u0435\u043c\u0435\u043d\u0442\u043e\u0432 \u0441 <code>x[n]</code> \u0438 \u0434\u043e <code>x[m - 1]</code>. \u0412 \u044d\u0442\u043e\u043c \u043f\u0440\u0438\u043c\u0435\u0440\u0435 \u043c\u044b \u0438\u0441\u043f\u043e\u043b\u044c\u0437\u0443\u0435\u043c \u043d\u0435\u0438\u0437\u043c\u0435\u043d\u044f\u0435\u043c\u044b\u0439 \u0441\u0440\u0435\u0437, \u0442.\u043a. \u043c\u044b \u043d\u0435 \u0438\u0437\u043c\u0435\u043d\u044f\u0435\u043c \u0437\u043d\u0430\u0447\u0435\u043d\u0438\u044f, \u043d\u0430 \u043a\u043e\u0442\u043e\u0440\u044b\u0435 \u043e\u043d \u0443\u043a\u0430\u0437\u044b\u0432\u0430\u0435\u0442.</p> <pre><code>fn total(values: []const u8) usize {\nvar sum: usize = 0;\nfor (values) |v| sum += v;\nreturn sum;\n}\ntest \"\u0421\u0440\u0435\u0437\u044b\" {\nconst array = [_]u8{ 1, 2, 3, 4, 5 };\nconst slice = array[0..3];\ntry expect(total(slice) == 6);\n}\n</code></pre> <p>\u0415\u0441\u043b\u0438 \u0437\u043d\u0430\u0447\u0435\u043d\u0438\u044f <code>n</code> \u0438 <code>m</code> \u0438\u0437\u0432\u0435\u0441\u0442\u043d\u044b \u0432\u043e \u0432\u0440\u0435\u043c\u044f \u043a\u043e\u043c\u043f\u0438\u043b\u044f\u0446\u0438\u0438, \u0432\u043c\u0435\u0441\u0442\u043e \u0441\u0440\u0435\u0437\u0430 \u0431\u0443\u0434\u0435\u0442 \u0441\u043e\u0437\u0434\u0430\u043d \u0443\u043a\u0430\u0437\u0430\u0442\u0435\u043b\u044c \u043d\u0430 \u043f\u043e\u0434\u043c\u0430\u0441\u0441\u0438\u0432. \u0422\u0430\u043a \u043a\u0430\u043a \u044d\u0442\u043e\u0442 \u0443\u043a\u0430\u0437\u0430\u0442\u0435\u043b\u044c \u043c\u043e\u0436\u0435\u0442 \u0431\u044b\u0442\u044c \u043f\u0440\u0438\u0432\u0435\u0434\u0451\u043d \u043a \u0441\u0440\u0435\u0437\u0443, \u044d\u0442\u043e \u043d\u0435 \u044f\u0432\u043b\u044f\u0435\u0442\u0441\u044f \u043f\u0440\u043e\u0431\u043b\u0435\u043c\u043e\u0439 (\u0442.\u0435. <code>*[N]T</code> \u043f\u0440\u0438\u0432\u043e\u0434\u0438\u043c \u043a <code>[]T</code>).</p> <pre><code>test \"\u0421\u0440\u0435\u0437\u044b 2\" {\nconst array = [_]u8{ 1, 2, 3, 4, 5 };\nconst slice = array[0..3];\ntry expect(@TypeOf(slice) == *const [3]u8);\n}\n</code></pre> <p>\u0412\u044b \u043c\u043e\u0436\u0435\u0442\u0435 \u043f\u0440\u043e\u043f\u0443\u0441\u0442\u0438\u0442\u044c \u0432\u0442\u043e\u0440\u043e\u0435 \u0437\u043d\u0430\u0447\u0435\u043d\u0438\u0435, \u0435\u0441\u043b\u0438 \u0432\u044b \u043e\u0431\u0440\u0435\u0437\u0430\u0435\u0442\u0435 \u0434\u043e \u043a\u043e\u043d\u0446\u0430 \u2014 <code>x[n..]</code>.</p> <pre><code>test \"\u0421\u0440\u0435\u0437\u044b 3\" {\nvar array = [_]u8{ 1, 2, 3, 4, 5 };\nvar slice = array[0..];\n_ = slice;\n}\n</code></pre> <p>\u041a\u0440\u043e\u043c\u0435 \u043c\u0430\u0441\u0441\u0438\u0432\u043e\u0432, \u0442\u0430\u043a\u0436\u0435 \u043c\u043e\u0436\u043d\u043e \u043e\u0431\u0440\u0435\u0437\u0430\u0442\u044c \u0443\u043a\u0430\u0437\u0430\u0442\u0435\u043b\u0438 \u043d\u0430 \u043d\u0435\u0438\u0437\u0432\u0435\u0441\u0442\u043d\u043e\u0435 \u043a\u043e\u043b-\u0432\u043e \u044d\u043b\u0435\u043c\u0435\u043d\u0442\u043e\u0432 \u0438 \u0441\u0430\u043c\u0438 \u0441\u0440\u0435\u0437\u044b.</p>"},{"location":"ru/chapter-1/#_5","title":"\u041f\u0435\u0440\u0435\u0447\u0438\u0441\u043b\u0435\u043d\u0438\u044f","text":"<p>\u041f\u0435\u0440\u0435\u0447\u0438\u0441\u043b\u0435\u043d\u0438\u044f (enumerations) \u0432 Zig \u044f\u0432\u043b\u044f\u044e\u0442\u0441\u044f \u043d\u0430\u0431\u043e\u0440\u043e\u043c \u0438\u0434\u0435\u043d\u0442\u0438\u0444\u0438\u043a\u0430\u0442\u043e\u0440\u043e\u0432 \u0441 \u0446\u0435\u043b\u043e\u0447\u0438\u0441\u043b\u0435\u043d\u043d\u044b\u043c\u0438 \u0437\u043d\u0430\u0447\u0435\u043d\u0438\u044f\u043c\u0438.</p> <p>\u0414\u0430\u0432\u0430\u0439\u0442\u0435 \u0441\u043e\u0437\u0434\u0430\u0434\u0438\u043c \u0442\u0438\u043f \u0434\u043b\u044f \u043f\u0435\u0440\u0435\u0447\u0438\u0441\u043b\u0435\u043d\u0438\u044f \u043d\u0430\u043f\u0440\u0430\u0432\u043b\u0435\u043d\u0438\u044f. <pre><code>const Direction = enum { north, south, east, west };\n</code></pre></p> <p>\u0412 \u043f\u0435\u0440\u0435\u0447\u0438\u0441\u043b\u0435\u043d\u0438\u044f\u0445 \u043c\u043e\u0436\u043d\u043e \u044f\u0432\u043d\u043e \u0443\u043a\u0430\u0437\u0430\u0442\u044c (\u0447\u0438\u0441\u043b\u0435\u043d\u043d\u044b\u0439) \u0442\u0438\u043f \u043d\u0430\u0445\u043e\u0434\u044f\u0449\u0438\u0445\u0441\u044f \u0432\u043d\u0443\u0442\u0440\u0438 \u044d\u043b\u0435\u043c\u0435\u043d\u0442\u043e\u0432. <pre><code>const Value = enum(u2) { zero, one, two };\n</code></pre></p> <p>\u041f\u043e \u0443\u043c\u043e\u043b\u0447\u0430\u043d\u0438\u044e, \u0447\u0438\u0441\u043b\u0435\u043d\u043d\u044b\u0435 \u0437\u043d\u0430\u0447\u0435\u043d\u0438\u044f \u044d\u043b\u0435\u043c\u0435\u043d\u0442\u043e\u0432 \u043d\u0430\u0447\u0438\u043d\u0430\u044e\u0442\u0441\u044f \u0441 \u043d\u0443\u043b\u044f. \u042d\u043b\u0435\u043c\u0435\u043d\u0442\u044b \u043c\u043e\u0436\u043d\u043e \u043f\u0440\u0435\u043e\u0431\u0440\u0430\u0437\u043e\u0432\u0430\u0442\u044c \u0432 \u0447\u0438\u0441\u043b\u0430 \u043f\u0440\u0438 \u043f\u043e\u043c\u043e\u0449\u0438 \u0432\u0441\u0442\u0440\u043e\u0435\u043d\u043d\u043e\u0439 \u0444\u0443\u043d\u043a\u0446\u0438\u0438 <code>@intFromEnum</code>. <pre><code>test \"\u041f\u043e\u043b\u0443\u0447\u0435\u043d\u0438\u0435 \u0447\u0438\u0441\u043b\u0435\u043d\u043d\u044b\u0445 \u0437\u043d\u0430\u0447\u0435\u043d\u0438\u0439 \u0438\u0437 \u044d\u043b\u0435\u043c\u0435\u043d\u0442\u043e\u0432\" {\ntry expect(@intFromEnum(Value.zero) == 0);\ntry expect(@intFromEnum(Value.one) == 1);\ntry expect(@intFromEnum(Value.two) == 2);\n}\n</code></pre></p> <p>\u0417\u043d\u0430\u0447\u0435\u043d\u0438\u044f \u044d\u043b\u0435\u043c\u0435\u043d\u0442\u043e\u0432 \u043c\u043e\u0436\u043d\u043e \u043f\u0435\u0440\u0435\u043e\u043f\u0440\u0435\u0434\u0435\u043b\u044f\u0442\u044c, \u043f\u0440\u0438 \u044d\u0442\u043e\u043c \u0437\u043d\u0430\u0447\u0435\u043d\u0438\u044f \u0441\u043b\u0435\u0434\u0443\u044e\u0449\u0438\u0445 \u044d\u043b\u0435\u043c\u0435\u043d\u0442\u043e\u0432 \u0432\u0441\u0451 \u0442\u0430\u043a \u0436\u0435 \u043f\u0440\u043e\u0434\u043e\u043b\u0436\u0430\u044e\u0442 \u0447\u0438\u0441\u043b\u0435\u043d\u043d\u044b\u0439 \u0440\u044f\u0434.</p> <pre><code>const Value2 = enum(u32) {\nhundred = 100,\nthousand = 1000,\nmillion = 1000000,\nnext,\n};\n\ntest \"\u041f\u0435\u0440\u0435\u043e\u043f\u0440\u0435\u0434\u0435\u043b\u0435\u043d\u0438\u0435 \u0447\u0438\u0441\u043b\u0435\u043d\u043d\u044b\u0445 \u0437\u043d\u0430\u0447\u0435\u043d\u0438\u0439\" {\ntry expect(@intFromEnum(Value2.hundred) == 100);\ntry expect(@intFromEnum(Value2.thousand) == 1000);\ntry expect(@intFromEnum(Value2.million) == 1000000);\ntry expect(@intFromEnum(Value2.next) == 1000001);\n}\n</code></pre> <p>\u0412 \u043e\u0431\u044a\u044f\u0432\u043b\u0435\u043d\u0438\u0438 \u043f\u0435\u0440\u0435\u0447\u0438\u0441\u043b\u044f\u0435\u043c\u043e\u0433\u043e \u0442\u0438\u043f\u0430 \u043c\u043e\u0436\u043d\u043e \u0434\u043e\u0431\u0430\u0432\u0438\u0442\u044c \u0444\u0443\u043d\u043a\u0446\u0438\u0438, \u043f\u0440\u0438 \u044d\u0442\u043e\u043c \u043e\u043d\u0438 \u0431\u0443\u0434\u0443\u0442 \u043e\u0433\u0440\u0430\u043d\u0438\u0447\u0435\u043d\u044b \u043e\u043a\u0440\u0443\u0436\u0430\u044e\u0449\u0438\u043c \u043f\u0440\u043e\u0441\u0442\u0440\u0430\u043d\u0441\u0442\u0432\u043e\u043c \u0438\u043c\u0451\u043d. \u0418\u0445 \u043c\u043e\u0436\u043d\u043e \u0432\u044b\u0437\u0432\u0430\u0442\u044c \u043a\u0430\u043a \u043e\u0431\u044b\u0447\u043d\u0443\u044e \u0444\u0443\u043d\u043a\u0446\u0438\u044e, \u043b\u0438\u0431\u043e \u0432 \u0441\u0442\u0438\u043b\u0435 \u043c\u0435\u0442\u043e\u0434\u043e\u0432 \u0438\u0441\u043f\u043e\u043b\u044c\u0437\u0443\u044f \u0441\u0438\u043d\u0442\u0430\u043a\u0441\u0438\u0441 <code>\u044d\u043b\u0435\u043c\u0435\u043d\u0442.\u0432\u044b\u0437\u044b\u0432\u0430\u0435\u043c\u0430\u044f\u0424\u0443\u043d\u043a\u0446\u0438\u044f(a, b)</code> (dot syntax), \u043f\u0440\u0438 \u044d\u0442\u043e\u043c \u044d\u043b\u0435\u043c\u0435\u043d\u0442 \u043f\u0435\u0440\u0435\u0447\u0438\u0441\u043b\u0435\u043d\u0438\u044f \u0430\u0432\u0442\u043e\u043c\u0430\u0442\u0438\u0447\u0435\u0441\u043a\u0438 \u0441\u0442\u0430\u043d\u043e\u0432\u0438\u0442\u0441\u044f \u043f\u0435\u0440\u0432\u044b\u043c \u043f\u0430\u0440\u0430\u043c\u0435\u0442\u0440\u043e\u043c \u0444\u0443\u043d\u043a\u0446\u0438\u0438 (\u0442.\u0435. \u0434\u0430\u043d\u043d\u0430\u044f \u0437\u0430\u043f\u0438\u0441\u044c \u044d\u043a\u0432\u0438\u0432\u0430\u043b\u0435\u043d\u0442\u0430 <code>\u041f\u0435\u0440\u0435\u0447\u0438\u0441\u043b\u0435\u043d\u0438\u0435.\u0432\u044b\u0437\u044b\u0432\u0430\u0435\u043c\u0430\u044f\u0424\u0443\u043d\u043a\u0446\u0438\u044f(\u044d\u043b\u0435\u043c\u0435\u043d\u0442, a, b)</code>).</p> <pre><code>const Suit = enum {\nclubs,\nspades,\ndiamonds,\nhearts,\n\npub fn isClubs(self: Suit) bool {\nreturn self == Suit.clubs;\n}\n};\n\ntest \"\u0412\u044b\u0437\u043e\u0432 \u0444\u0443\u043d\u043a\u0446\u0438\u0438 \u0438\u0437 \u043f\u0440\u043e\u0441\u0442\u0440\u0430\u043d\u0441\u0442\u0432\u0430 \u0438\u043c\u0451\u043d \u043f\u0435\u0440\u0435\u0447\u0438\u0441\u043b\u0435\u043d\u0438\u044f\" {\nconst element = Suit.spades; // \u044d\u043a\u0437\u0435\u043c\u043f\u043b\u044f\u0440 \u043f\u0435\u0440\u0435\u0447\u0438\u0441\u043b\u0435\u043d\u0438\u044f Suit\ntry expect(element.isClubs() == true);\ntry expect(Suit.isClubs(element) == true);\n}\n</code></pre> <p>\u041f\u0435\u0440\u0435\u0447\u0438\u0441\u043b\u0435\u043d\u0438\u044f \u0442\u0430\u043a\u0436\u0435 \u043c\u043e\u0433\u0443\u0442 \u0438\u043c\u0435\u0442\u044c \u043e\u0431\u044a\u044f\u0432\u043b\u0435\u043d\u0438\u044f \u0437\u043d\u0430\u0447\u0435\u043d\u0438\u0439 \u0441 \u043f\u043e\u043c\u043e\u0449\u044c\u044e <code>var</code> \u0438 <code>const</code>. \u041e\u043d\u0438 \u0434\u0435\u0439\u0441\u0442\u0432\u0443\u044e\u0442 \u043a\u0430\u043a \u0433\u043b\u043e\u0431\u0430\u043b\u044c\u043d\u044b\u0435 \u043f\u0435\u0440\u0435\u043c\u0435\u043d\u043d\u044b\u0435 (\u0438\u043b\u0438 \u043a\u043e\u043d\u0441\u0442\u0430\u043d\u0442\u044b) \u0432 \u044d\u0442\u043e\u043c \u043f\u0440\u043e\u0441\u0442\u0440\u0430\u043d\u0441\u0442\u0432\u0435 \u0438\u043c\u0451\u043d, \u0438 \u0438\u0445 \u0437\u043d\u0430\u0447\u0435\u043d\u0438\u044f \u043d\u0435 \u0441\u0432\u044f\u0437\u0430\u043d\u044b \u0438 \u043d\u0435 \u043f\u0440\u0438\u0432\u044f\u0437\u0430\u043d\u044b \u043a \u044d\u043a\u0437\u0435\u043c\u043f\u043b\u044f\u0440\u0430\u043c \u0441\u0430\u043c\u043e\u0433\u043e \u043f\u0435\u0440\u0435\u0447\u0438\u0441\u043b\u0435\u043d\u0438\u044f.</p> <pre><code>const Mode = enum {\nvar count: u32 = 0;\n\non,\noff,\n};\n\ntest \"\u0418\u0437\u043c\u0435\u043d\u0435\u043d\u0438\u0435 \u0433\u043b\u043e\u0431\u0430\u043b\u044c\u043d\u043e\u0439 \u043f\u0435\u0440\u0435\u043c\u0435\u043d\u043d\u043e\u0439 \u043f\u0435\u0440\u0435\u0447\u0438\u0441\u043b\u0435\u043d\u0438\u044f Mode\" {\nMode.count += 1;\ntry expect(Mode.count == 1);\n}\n</code></pre>"},{"location":"ru/chapter-1/#vectors","title":"Vectors","text":"<p>Zig provides vector types for SIMD. These are not to be conflated with vectors in a mathematical sense, or vectors like C++'s std::vector (for this, see \"Arraylist\" in chapter 2). Vector types are created with the builtin function @Vector.</p> <p>A vector is a group of booleans, Integers, Floats, or Pointers which are operated on in parallel, using SIMD instructions if possible.</p> <p>Operations between vectors with the same child type and length can take place. These operations are performed on each of the values in the vector.<code>std.meta.eql</code> is used here to check for equality between two vectors (also useful for other types like structs).</p> <pre><code>const meta = @import(\"std\").meta;\n\ntest \"vector add\" {\nconst x: @Vector(4, f32) = .{ 1, -10, 20, -1 };\nconst y: @Vector(4, f32) = .{ 2, 10, 0, 1 };\nconst z = x + y;\ntry expect(meta.eql(z, @Vector(4, f32){ 3, 0, 20, 0 }));\n}\n</code></pre> <p>Vectors are indexable. <pre><code>test \"vector indexing\" {\nconst x: @Vector(4, u8) = .{ 255, 0, 255, 0 };\ntry expect(x[0] == 255);\n}\n\u044e\u044e`\n\nThe built-in function [`@splat`](https://ziglang.org/documentation/master/#splat) may be used to construct a vector where all of the values are the same. Here we use it to multiply a vector by a scalar.\n\n```zig\ntest \"vector * scalar\" {\nconst x: @Vector(3, f32) = .{ 12.5, 37.5, 2.5 };\nconst vec: @Vector(3, f32) = @splat(2);\nconst y = x * vec;\ntry expect(meta.eql(y, @Vector(3, f32){ 25, 75, 5 }));\n}\n</code></pre></p> <p>Vectors do not have a <code>len</code> field like arrays, but may still be looped over. Here, <code>std.mem.len</code> is used as a shortcut for <code>@typeInfo(@TypeOf(x)).Vector.len</code>.</p> <pre><code>const len = @import(\"std\").mem.len;\n\ntest \"vector looping\" {\nconst x = @Vector(4, u8){ 255, 0, 255, 0 };\nvar sum = blk: {\nvar tmp: u10 = 0;\nvar i: u8 = 0;\nwhile (i &lt; 4) : (i += 1) tmp += x[i];\nbreak :blk tmp;\n};\ntry expect(sum == 510);\n}\n</code></pre> <p>Vectors coerce to their respective arrays.</p> <pre><code>const arr: [4]f32 = @Vector(4, f32){ 1, 2, 3, 4 };\n</code></pre> <p>It is worth noting that using explicit vectors may result in slower software if you do not make the right decisions - the compiler's auto-vectorisation is fairly smart as-is.</p>"},{"location":"pt/","title":"Chapter 0 - Come\u00e7ando","text":""},{"location":"pt/#bem-vindoa","title":"Bem-vindo(a)","text":"<p>Zig \u00e9 uma linguagem de program\u00e7\u00e3o de uso geral e um toolchain para manter software robusto, \u00f3timizado, and reutiliz\u00e1vel.</p> <p>Aviso: O \u00faltima vers\u00e3o principal \u00e9 0.11 - O Zig ainda \u00e9 pr\u00e9-1.0; o uso em produ\u00e7\u00e3o ainda n\u00e3o \u00e9 recomendado e poder\u00e1 encontrar bugs no compilador.</p> <p>Para seguir este guia, n\u00f3s assumimos que tem:</p> <ul> <li>Experi\u00eancia pr\u00e9via com program\u00e7\u00e3o</li> <li>Alguma compreens\u00e3o sobre conceitos de program\u00e7\u00e3o de baixo n\u00edvel</li> </ul> <p>Saber uma linguagem como C, C++, Rust, Go, Pascal ou similar vai lhe ajudar a seguir este guia. Tem de ter um editor, terminal e conex\u00e3o \u00e0 internet. Este guia n\u00e3o \u00e9 oficial e nem afiliado \u00e0 funda\u00e7\u00e3o Zig Software Foundation e foi feito para ser lido por ordem e desde o \u00ednicio.</p>"},{"location":"pt/#instalacao","title":"Instala\u00e7\u00e3o","text":"<p>Este guia assume que est\u00e1 utilizando a vers\u00e3o master do Zig em vez da \u00faltima vers\u00e3o principal, o que significa que descarregar o bin\u00e1rio do site ou compilar a partir da fonte; a vers\u00e3o do Zig no seu gerenciador de pacotes (package manager) est\u00e1 provavelmente desatualizado. Este guia n\u00e3o suporta o Zig 0.10.1.</p> <ol> <li> <p>Descarregue e extraia o bin\u00e1rio do pr\u00e9-compilado do master do Zig apartir do https://ziglang.org/download/.</p> </li> <li> <p>Adicione o Zig ao seu path</p> </li> <li> <p>linux, macos, bsd</p> <p>Adicione a localiza\u00e7\u00e3o do seu bin\u00e1rio do Zig \u00e0 sua vari\u00e1vel de environment <code>PATH</code>. Para instalar, adicione <code>export PATH=$PATH:~/zig</code> ou similar ao seu <code>/etc/profile</code> (para todo o sistema) ou <code>$HOME/.profile</code>. Se estas mudan\u00e7as n\u00e3o forem aplicadas imediatamente, execute a linha no seu shell.     - windows</p> <p>a) Para todo o sistema (admin powershell)</p> <pre><code>[Environment]::SetEnvironmentVariable(\n   \"Path\",\n   [Environment]::GetEnvironmentVariable(\"Path\", \"Machine\") + \";C:\\your-path\\zig-windows-x86_64-your-version\",\n   \"Machine\"\n)\n</code></pre> <p>b) Para o utilizador (powershell)</p> <pre><code>[Environment]::SetEnvironmentVariable(\n   \"Path\",\n   [Environment]::GetEnvironmentVariable(\"Path\", \"User\") + \";C:\\your-path\\zig-windows-x86_64-your-version\",\n   \"User\"\n)\n</code></pre> <p>Feche o seu terminal e abra um novo.</p> </li> <li> <p>Verifique a sua instala\u00e7\u00e3o <code>zig version</code>. O output deve ser algo parecido a isto: <pre><code>$ zig version\n0.11.0-dev.2777+b95cdf0ae\n</code></pre></p> </li> <li> <p>(opcional, feito por terceiros) Para auto-completamento e para \"ir para defini\u00e7\u00f5es\" no seu editor, instale o Zig Language Server apartir de https://github.com/zigtools/zls/.</p> </li> <li> <p>(opcional) Entre numa comunidade do Zig.</p> </li> </ol>"},{"location":"pt/#ola-mundo","title":"Ol\u00e1, mundo","text":"<p>Crie um ficheiro chamado <code>main.zig</code>, com o seguinte conte\u00fado:</p> <pre><code>const std = @import(\"std\");\n\npub fn main() void {\nstd.debug.print(\"Hello, {s}!\\n\", .{\"World\"});\n}\n</code></pre> <p>nota: certifique que o ficheiro est\u00e1 codificado com UTF-8!</p> <p>nota: Se estiver a utilizar tabs para indenta\u00e7\u00e3o e/ou CRLF para o fim das linhas no seu ficheiro, o compilador vai aceit\u00e1-lo mas usar <code>zig fmt</code> vai canoniz\u00e1-los para espa\u00e7os e fim de linhas com LF!</p> <p>Use <code>zig run main.zig</code> para compilar e executar o programa. Neste exemplo <code>Hello, World!</code> ser\u00e1 escrito para stderr e \u00e9 assumido que nunca vai falhar.</p>"},{"location":"pt/chapter-1/","title":"Chapter 1 - O b\u00e1sico","text":""},{"location":"pt/chapter-1/#atribuicao-de-variaveis","title":"Atribui\u00e7\u00e3o de vari\u00e1veis","text":"<p>A atribui\u00e7\u00e3o de vari\u00e1veis tem a seguinte sintaxe: <code>(const|var) identificador[: tipo] = valor</code>.</p> <ul> <li><code>const</code> indica que o <code>identificador</code> \u00e9 uma constante que possui um valor imut\u00e1vel.</li> <li><code>var</code> indica que o <code>identificador</code> \u00e9 uma vari\u00e1vel que possui um valor mut\u00e1vel.</li> <li><code>: tipo</code> \u00e9 a anota\u00e7\u00e3o do tipo para o <code>identificador</code> e pode ser omitido se o tipo dos dados do <code>valor</code> for inferido.</li> </ul> <pre><code>const constant: i32 = 5; // constante assinado de 32 bits\nvar variable: u32 = 5000; // constante n\u00e3o assinado de 32 bits\n\n// @as faz a coer\u00e7\u00e3o explicita de tipos\nconst inferred_constant = @as(i32, 5);\nvar inferred_variable = @as(u32, 5000);\n</code></pre> <p>Constantes e vari\u00e1veis devem ter um valor. Se nenhum valor possa ser atribuido, o valor <code>undefined</code>, que coage a qualquer tipo, pode ser usado desde que a anota\u00e7\u00e3o do tipo seja fornecido.</p> <pre><code>const a: i32 = undefined;\nvar b: u32 = undefined;\n</code></pre> <p>Quando poss\u00edvel, valores <code>const</code> s\u00e3o preferidos ao inv\u00e9s de valores <code>var</code>.</p>"},{"location":"pt/chapter-1/#arrays-nt","title":"Arrays [N]T","text":"<p>Arrays s\u00e3o denotados por <code>[N]T</code>, onde <code>N</code> \u00e9 o n\u00famero de elementos no array e <code>T</code> \u00e9 o tipo dos seus elementos (ou seja, o tipo dos itens no array).</p> <p>Para a literal do array <code>N</code> pode ser substituido por <code>_</code> para inferir o tamanho do array.</p> <pre><code>const a = [5]u8{ 'h', 'e', 'l', 'l', 'o' };\nconst b = [_]u8{ 'w', 'o', 'r', 'l', 'd' };\n</code></pre> <p>Para obter o tamanho do array, simplesmente acesse o campo <code>len</code> do array.</p> <pre><code>const array = [_]u8{ 'h', 'e', 'l', 'l', 'o' };\nconst length = array.len; // 5\n</code></pre>"},{"location":"pt/chapter-1/#if","title":"If","text":"<p>A declara\u00e7\u00e3o If do Zig \u00e9 simples porque somente aceita valores <code>bool</code> (de valores <code>true</code> ou <code>false</code>). N\u00e3o h\u00e1 um conceito de valores verdadeiros ou falsos.</p> <p>Aqui n\u00f3s vamos introduzir testes. Guarde o c\u00f3digo abaixo e compile + execute com <code>zig test file-name.zig</code>. N\u00f3s vamos usar a fun\u00e7\u00e3o <code>expect</code> da biblioteca padr\u00e3o, que vai fazer o teste falhar se receber um valor <code>false</code>. Quando o teste falha, o erro e o stack trace v\u00e3o aparecer.</p> <pre><code>const expect = @import(\"std\").testing.expect;\n\ntest \"declara\u00e7\u00e3o if\" {\nconst a = true;\nvar x: u16 = 0;\nif (a) {\nx += 1;\n} else {\nx += 2;\n}\ntry expect(x == 1);\n}\n</code></pre> <p>Declara\u00e7\u00f5es If tamb\u00e9m funcionam como express\u00f5es.</p> <pre><code>test \"declara\u00e7\u00e3o if como express\u00e3o\" {\nconst a = true;\nvar x: u16 = 0;\nx += if (a) 1 else 2;\ntry expect(x == 1);\n}\n</code></pre>"},{"location":"pt/chapter-1/#while","title":"While","text":"<p>O loop while do Zig tem 3 partes - uma condi\u00e7\u00e3o, um bloco e uma express\u00e3o continue.</p> <p>Sem a express\u00e3o continue. <pre><code>test \"declara\u00e7\u00e3o while\" {\nvar i: u8 = 2;\nwhile (i &lt; 100) {\ni *= 2;\n}\ntry expect(i == 128);\n}\n</code></pre></p> <p>Com a express\u00e3o continue. <pre><code>test \"express\u00e3o while com continue\" {\nvar sum: u8 = 0;\nvar i: u8 = 1;\nwhile (i &lt;= 10) : (i += 1) {\nsum += i;\n}\ntry expect(sum == 55);\n}\n</code></pre></p> <p>Com <code>continue</code>.</p> <pre><code>test \"while com continue\" {\nvar sum: u8 = 0;\nvar i: u8 = 0;\nwhile (i &lt;= 3) : (i += 1) {\nif (i == 2) continue;\nsum += i;\n}\ntry expect(sum == 4);\n}\n</code></pre> <p>Com <code>break</code>.</p> <pre><code>test \"while com break\" {\nvar sum: u8 = 0;\nvar i: u8 = 0;\nwhile (i &lt;= 3) : (i += 1) {\nif (i == 2) break;\nsum += i;\n}\ntry expect(sum == 1);\n}\n</code></pre>"},{"location":"pt/chapter-1/#for","title":"For","text":"<p>Loops For s\u00e3o usados para iterar arrays (e outros tipos discutidos mais tarde). Para loops siga a seguinte sintaxe. Como o while, os loops for usam <code>break</code> e <code>continue</code>. Aqui tivemos que atribuir valores ao <code>_</code>, porque o Zig n\u00e3o permite valores n\u00e3o usados.</p> <pre><code>test \"for\" {\n//character literals are equivalent to integer literals\nconst string = [_]u8{ 'a', 'b', 'c' };\n\nfor (string, 0..) |character, index| {\n_ = character;\n_ = index;\n}\n\nfor (string) |character| {\n_ = character;\n}\n\nfor (string, 0..) |_, index| {\n_ = index;\n}\n\nfor (string) |_| {}\n}\n</code></pre>"},{"location":"pt/chapter-1/#funcoes","title":"Fun\u00e7\u00f5es","text":"<p>Todos os argumentos das fun\u00e7\u00f5es s\u00e3o imut\u00e1veis - Se quiser uma c\u00f3pia, o utilizador ter\u00e1 que fazer uma explicitamente. Ao contr\u00e1rio das vari\u00e1veis que s\u00e3o snake_case, fun\u00e7\u00f5es s\u00e3o camelCase. Aqui est\u00e3o alguns exemplos de como declarar e chamar uma fun\u00e7\u00e3o simples.</p> <pre><code>fn addFive(x: u32) u32 {\nreturn x + 5;\n}\n\ntest \"function\" {\nconst y = addFive(0);\ntry expect(@TypeOf(y) == u32);\ntry expect(y == 5);\n}\n</code></pre> <p>A recurs\u00e3o \u00e9 permitida:</p> <pre><code>fn fibonacci(n: u16) u16 {\nif (n == 0 or n == 1) return n;\nreturn fibonacci(n - 1) + fibonacci(n - 2);\n}\n\ntest \"function recursion\" {\nconst x = fibonacci(10);\ntry expect(x == 55);\n}\n</code></pre> <p>Quando uma recurs\u00e3o acontece, o compilador j\u00e1 n\u00e3o vai poder saber qual o tamanho m\u00e1ximo da stack. Isso poder\u00e1 resultar em comportamentos inseguro - um stack overflow. Detalhes em como fazer recurs\u00f5es seguras ser\u00e3o abordadas no futuro.</p> <p>Valores podem ser ignorados usando o <code>_</code> no lugar de uma declara\u00e7\u00e3o de uma vari\u00e1vel ou constante. Mas isto n\u00e3o funciona no scope global (ou seja, s\u00f3 funciona em fun\u00e7\u00f5es e em blocos) e \u00e9 \u00fatil para ignorar valores retornados de fun\u00e7\u00f5es se elas n\u00e3o forem necess\u00e1rias.</p> <pre><code>_ = 10;\n</code></pre>"},{"location":"pt/chapter-1/#defer","title":"Defer","text":"<p>Defer \u00e9 usado para executar uma declara\u00e7\u00e3o ao sair do bloco atual.</p> <pre><code>test \"defer\" {\nvar x: i16 = 5;\n{\ndefer x += 2;\ntry expect(x == 5);\n}\ntry expect(x == 7);\n}\n</code></pre> <p>Quando existem multiplos defers num \u00fanico bloco, eles s\u00e3o executados na ordem reversa.</p> <pre><code>test \"multi defer\" {\nvar x: f32 = 5;\n{\ndefer x += 2;\ndefer x /= 2;\n}\ntry expect(x == 4.5);\n}\n</code></pre>"},{"location":"pt/chapter-1/#erros","title":"Erros","text":"<p>Um conjunto de erros \u00e9 como um enum (detalhes nos enums do Zig mais tarde), em que cada erro no conjunto \u00e9 um valor. N\u00e3o existem exce\u00e7\u00f5es no Zig; os erros s\u00e3o valores. Vamos criar um conjunto de erros.</p> <p><pre><code>const FileOpenError = error{\nAccessDenied,\nOutOfMemory,\nFileNotFound,\n};\n</code></pre> O conjunto de erros coage ao seu super-conjunto.</p> <pre><code>const AllocationError = error{OutOfMemory};\n\ntest \"coerce error from a subset to a superset\" {\nconst err: FileOpenError = AllocationError.OutOfMemory;\ntry expect(err == FileOpenError.OutOfMemory);\n}\n</code></pre> <p>Um conjunto de erros e um tipo normal podem ser combinados com o operador <code>!</code> para formar uma uni\u00e3o entre o erro e o tipo. Os valores destes tipos podem ser tanto um erro quanto um valor de um tipo normal.</p> <p>Vamos criar um valor com uma uni\u00e3o com o erro. Aqui usamos o <code>catch</code>, que \u00e9 seguido por uma express\u00e3o que \u00e9 avaliada quando o valor antes dela \u00e9 um erro. O catch \u00e9 usado aqui para fornecer um valor de fallback, mas ele pode ser tamb\u00e9m um <code>noreturn</code> - o tipo do <code>return</code>, <code>while (true)</code>, etc.</p> <pre><code>test \"error union\" {\nconst maybe_error: AllocationError!u16 = 10;\nconst no_error = maybe_error catch 0;\n\ntry expect(@TypeOf(no_error) == u16);\ntry expect(no_error == 10);\n}\n</code></pre> <p>Muitas vezes as fun\u00e7\u00f5es retornam uma uni\u00e3o com um conjunto de erros. Aqui temos um usando o catch, onde a sintaxe <code>|err|</code> recebe o valor de um erro. Isto \u00e9 chamado de captura do payload e \u00e9 usado de uma forma parecida em muitos lugares. N\u00f3s vamos falar mais sobre isso em detalhe mais tarde neste cap\u00edtulo. Obs: Algumas linguagens usam uma sintaxe parecida para lambdas - mas esse n\u00e3o \u00e9 o caso no Zig.</p> <pre><code>fn failingFunction() error{Oops}!void {\nreturn error.Oops;\n}\n\ntest \"returning an error\" {\nfailingFunction() catch |err| {\ntry expect(err == error.Oops);\nreturn;\n};\n}\n</code></pre> <p><code>try x</code> \u00e9 um atalho para <code>x catch |err| return err</code> e \u00e9 comummente usado em lugares onde o tratamento dos erros n\u00e3o \u00e9 apropriado. O <code>try</code> e o <code>catch</code> do Zig n\u00e3o est\u00e3o relacionados ao try-catch encontrado em outras linguagens.</p> <pre><code>fn failFn() error{Oops}!i32 {\ntry failingFunction();\nreturn 12;\n}\n\ntest \"try\" {\nvar v = failFn() catch |err| {\ntry expect(err == error.Oops);\nreturn;\n};\ntry expect(v == 12); // is never reached\n}\n</code></pre> <p><code>errdefer</code> funciona como o <code>defer</code>, mas s\u00f3 \u00e9 executado quando a fun\u00e7\u00e3o \u00e9 retornada com um erro dentro do bloco em que o <code>errdefer</code> est\u00e1 contido.</p> <pre><code>var problems: u32 = 98;\n\nfn failFnCounter() error{Oops}!void {\nerrdefer problems += 1;\ntry failingFunction();\n}\n\ntest \"errdefer\" {\nfailFnCounter() catch |err| {\ntry expect(err == error.Oops);\ntry expect(problems == 99);\nreturn;\n};\n}\n</code></pre> <p>As uni\u00f5es de erros retornados de uma fun\u00e7\u00e3o podem ter os seus conjuntos de erros inferidos desde que n\u00e3o haja um conjunto de erros explicito. Este conjunto de erros inferido cont\u00e9m todos os erros poss\u00edveis retornados pela fun\u00e7\u00e3o.</p> <pre><code>fn createFile() !void {\nreturn error.AccessDenied;\n}\n\ntest \"inferred error set\" {\n//type coercion successfully takes place\nconst x: error{AccessDenied}!void = createFile();\n\n//Zig does not let us ignore error unions via _ = x;\n//we must unwrap it with \"try\", \"catch\", or \"if\" by any means\n_ = x catch {};\n}\n</code></pre> <p>Conjuntos de erros podem ser unidos.</p> <pre><code>const A = error{ NotDir, PathNotFound };\nconst B = error{ OutOfMemory, PathNotFound };\nconst C = A || B;\n</code></pre> <p>O <code>anyerror</code> \u00e9 um conjunto de erros global que por ser um super-conjunto de todos os conjuntos, pode ter um erro de qualquer conjunto. O seu uso geralmente deve ser evitado.</p>"},{"location":"pt/chapter-1/#switch","title":"Switch","text":"<p>O <code>switch</code> do Zig funciona como uma declara\u00e7\u00e3o e como uma express\u00e3o. O tipo de todos os ramos devem coagir ao tipo a que se est\u00e1 a fazer o switch. Todos os valores poss\u00edveis devem ser associados ao ramo - os valores n\u00e3o podem ser ignorados. Os cases n\u00e3o podem fazer fallthrough a outros ramos.</p> <p>Um exemplo de uma declara\u00e7\u00e3o de switch. O else \u00e9 necess\u00e1rio para satisfazer a exaustividade do switch.</p> <pre><code>test \"switch statement\" {\nvar x: i8 = 10;\nswitch (x) {\n-1...1 =&gt; {\nx = -x;\n},\n10, 100 =&gt; {\n//special considerations must be made\n//when dividing signed integers\nx = @divExact(x, 10);\n},\nelse =&gt; {},\n}\ntry expect(x == 1);\n}\n</code></pre> <p>Aqui est\u00e1 o c\u00f3digo anterior mas como uma express\u00e3o. <pre><code>test \"switch expression\" {\nvar x: i8 = 10;\nx = switch (x) {\n-1...1 =&gt; -x,\n10, 100 =&gt; @divExact(x, 10),\nelse =&gt; x,\n};\ntry expect(x == 1);\n}\n</code></pre></p>"},{"location":"pt/chapter-1/#a-seguranca-durante-a-execucao","title":"A seguran\u00e7a durante a execu\u00e7\u00e3o","text":"<p>O Zig fornece alguns n\u00edveis de seguran\u00e7a, onde problemas podem ser descobertos durante a execu\u00e7\u00e3o. A seguran\u00e7a pode ser desativada. O Zig possui muitos casos de comportamento ilegal detet\u00e1veil. OU seja, comportamentos ilegais ser\u00e3o apanhados (causando um p\u00e2nico) quando a seguran\u00e7a estiver ativada, mas o mesmo resulta em comportamento n\u00e3o definido quando a seguran\u00e7a estiver desativada. \u00c9 recomendado que crie e teste o seu software com a seguran\u00e7a ativada, mesmo tendo penalidades na velocidade de execu\u00e7\u00e3o.</p> <p>Por exemplo, a seguran\u00e7a durante a execu\u00e7\u00e3o o protege contra indexa\u00e7\u00f5es fora do limite.</p> <p><pre><code>test \"out of bounds\" {\nconst a = [3]u8{ 1, 2, 3 };\nvar index: u8 = 5;\nconst b = a[index];\n_ = b;\n}\n</code></pre> <pre><code>test \"out of bounds\"...index out of bounds\n.\\tests.zig:43:14: 0x7ff698cc1b82 in test \"out of bounds\" (test.obj)\n    const b = a[index];\n             ^\n</code></pre></p> <p>Pode escolher desativar a seguran\u00e7a durante a execu\u00e7\u00e3o para o bloco atual usando a fun\u00e7\u00e3o built-in <code>@setRuntimeSafety</code>.</p> <pre><code>test \"out of bounds, no safety\" {\n@setRuntimeSafety(false);\nconst a = [3]u8{ 1, 2, 3 };\nvar index: u8 = 5;\nconst b = a[index];\n_ = b;\n}\n</code></pre> <p>A seguran\u00e7a \u00e9 desativada para alguns modos de compila\u00e7\u00e3o (isto ser\u00e1 discutido mais tarde).</p>"},{"location":"pt/chapter-1/#unreachable","title":"Unreachable","text":"<p><code>unreachable</code> \u00e9 uma afirma\u00e7\u00e3o que diz para o compilador que esta declara\u00e7\u00e3o nunca ser\u00e1 executada. Isto pode ser usado para dizer ao compilador que um ramo \u00e9 imposs\u00edvel, o que permite certos tipos de otimiza\u00e7\u00f5es. Chegar a um <code>unreachable</code> \u00e9 considerado um comportado ilegal detet\u00e1vel.</p> <p>Por ser do tipo <code>noreturn</code>, ele \u00e9 compat\u00edvel com todos os outros tipos. Aqui ele coage para o tipo u32.</p> <p><pre><code>test \"unreachable\" {\nconst x: i32 = 1;\nconst y: u32 = if (x == 2) 5 else unreachable;\n_ = y;\n}\n</code></pre> <pre><code>test \"unreachable\"...reached unreachable code\n.\\tests.zig:211:39: 0x7ff7e29b2049 in test \"unreachable\" (test.obj)\n    const y: u32 = if (x == 2) 5 else unreachable;\n                                      ^\n</code></pre></p> <p>Aqui temos um unreachable sendo usado numa switch. <pre><code>fn asciiToUpper(x: u8) u8 {\nreturn switch (x) {\n'a'...'z' =&gt; x + 'A' - 'a',\n'A'...'Z' =&gt; x,\nelse =&gt; unreachable,\n};\n}\n\ntest \"unreachable switch\" {\ntry expect(asciiToUpper('a') == 'A');\ntry expect(asciiToUpper('A') == 'A');\n}\n</code></pre></p>"},{"location":"pt/chapter-1/#ponteiros-t","title":"Ponteiros <code>*T</code>","text":"<p>Os ponteiros normais no Zig n\u00e3o s\u00e3o permitidos de terem os valores 0 ou null. Eles seguem a seguinte sintaxe <code>*T</code>, onde <code>T</code>\u00e9 o tipo base. Refer\u00eancias s\u00e3o feitas com <code>&amp;variavel</code> e derefer\u00eancias com <code>variavel.*</code>.</p> <pre><code>fn increment(num: *u8) void {\nnum.* += 1;\n}\n\ntest \"pointers\" {\nvar x: u8 = 1;\nincrement(&amp;x);\ntry expect(x == 2);\n}\n</code></pre> <p>Tentar atribuir <code>*T</code> com um valor 0 \u00e9 um comportamento ilegal detet\u00e1vel.</p> <p><pre><code>test \"naughty pointer\" {\nvar x: u16 = 0;\nvar y: *u8 = @intToPtr(*u8, x);\n_ = y;\n}\n</code></pre> <pre><code>test \"naughty pointer\"...cast causes pointer to be null\n.\\tests.zig:241:18: 0x7ff69ebb22bd in test \"naughty pointer\" (test.obj)\n    var y: *u8 = @intToPtr(*u8, x);\n                 ^\n</code></pre></p> <p>O zig tamb\u00e9m possui ponteiros const, que n\u00e3o podem ser usados para modificar os dados referenciados. Referenciar uma vari\u00e1vel const resulta num ponteiro const.</p> <p><pre><code>test \"const pointers\" {\nconst x: u8 = 1;\nvar y = &amp;x;\ny.* += 1;\n}\n</code></pre> <pre><code>error: cannot assign to constant\n    y.* += 1;\n    ~~~~^~~~\n</code></pre></p> <p>Um <code>*T</code> coage a um <code>*const T</code>.</p>"},{"location":"pt/chapter-1/#inteiros-do-tamanho-de-ponteiros-usize-e-isize","title":"Inteiros do tamanho de ponteiros: <code>usize</code> e <code>isize</code>","text":"<p><code>usize</code> e <code>isize</code> s\u00e3o inteiros n\u00e3o assinados e assinados respetivamente, cujo tamanho \u00e9 do mesmo tamanho de ponteiros. </p> <pre><code>test \"usize\" {\ntry expect(@sizeOf(usize) == @sizeOf(*u8));\ntry expect(@sizeOf(isize) == @sizeOf(*u8));\n}\n</code></pre>"},{"location":"pt/chapter-1/#ponteiros-de-muitos-itens-t","title":"Ponteiros de muitos itens <code>[*]T</code>","text":"<p>\u00c0s vezes podem haver ponteiros com uma quantidade desconhecida de elementos. <code>[*]T</code> \u00e9 a solu\u00e7\u00e3o para isto, ele funciona como um <code>*T</code> mas tamb\u00e9m suporta a sintaxe para indexa\u00e7\u00e3o, aritm\u00e9tica de ponteiros e slicing. Ao contr\u00e1rio do <code>*T</code>,  ele n\u00e3o pode apontar para um tipo com um tamanho desconhecido. O <code>*T</code> coage para <code>[*]T</code>.</p> <p>Todos estes ponteiros podem apontar para qualquer quantidade de elementos, incluindo 0 e 1.</p>"},{"location":"pt/chapter-1/#slices-t","title":"Slices <code>[]T</code>","text":"<p>Os slices podem ser considerados como um par de <code>[*]T</code> (um ponteiro para uns dados quaisquer) e um <code>usize</code> (o contador do elemento). A sua sintaxe \u00e9 <code>[]T</code>, <code>T</code> sendo o seu tipo base. Os slices s\u00e3o frequentemente utilizados no Zig quando quer se fazer opera\u00e7\u00f5es numa quantidade arbitr\u00e1ria de dados. Os slices tamb\u00e9m t\u00eam os mesmos atributos dos ponteiros, ou seja tamb\u00e9m existem slices const. Loops For tamb\u00e9m funcionam com slices. Strings literais tamb\u00e9m coagem a <code>[]const u8</code> no Zig.</p> <p>Aqui a sintaxe <code>x[n..m]</code> \u00e9 usada para criar um slice a partir de um array. Isto \u00e9 chamado de slicing e cria um slice coms os seus elementos come\u00e7ando de <code>x[n]</code> e acabando em <code>x[m - 1]</code>. Este exemplo usa um slice const porque os valores apontados pelo slice n\u00e3o precisam ser modificados.</p> <pre><code>fn total(values: []const u8) usize {\nvar sum: usize = 0;\nfor (values) |v| sum += v;\nreturn sum;\n}\ntest \"slices\" {\nconst array = [_]u8{ 1, 2, 3, 4, 5 };\nconst slice = array[0..3];\ntry expect(total(slice) == 6);\n}\n</code></pre> <p>Quando estes valores <code>n</code> e <code>m</code> s\u00e3o conhecidos durante a compila\u00e7\u00e3o, o slice ir\u00e1 produzir ponteiros para um array. Isto n\u00e3o \u00e9 um problema porque o ponteiro para o array  <code>*[N]T</code> coage para <code>[]T</code>.</p> <pre><code>test \"slices 2\" {\nconst array = [_]u8{ 1, 2, 3, 4, 5 };\nconst slice = array[0..3];\ntry expect(@TypeOf(slice) == *const [3]u8);\n}\n</code></pre> <p>A sintaxe <code>x[n..]</code> pode tamb\u00e9m ser usada quando quiser um slice at\u00e9 o final.</p> <pre><code>test \"slices 3\" {\nvar array = [_]u8{ 1, 2, 3, 4, 5 };\nvar slice = array[0..];\n_ = slice;\n}\n</code></pre> <p>Os tipos que podem ser convertidos em slices s\u00e3o: arrays, ponteiros de v\u00e1rios itens e outros slices.</p>"},{"location":"pt/chapter-1/#enums","title":"Enums","text":"<p>Os enums do Zig permitem que defina tipos que t\u00eam um conjunto de valores restrito.</p> <p>Vamos criar um enum. <pre><code>const Direction = enum { north, south, east, west };\n</code></pre></p> <p>Os enums podem ter o tipo da suas tags especificadas (inteiros).  <pre><code>const Value = enum(u2) { zero, one, two };\n</code></pre></p> <p>Os valores ordinais dos enums come\u00e7am do 0. Eles podem ser acessados com a fun\u00e7\u00e3o built-in <code>@intFromEnum</code>. <pre><code>test \"enum ordinal value\" {\ntry expect(@intFromEnum(Value.zero) == 0);\ntry expect(@intFromEnum(Value.one) == 1);\ntry expect(@intFromEnum(Value.two) == 2);\n}\n</code></pre></p> <p>Os seus valores podem ser mudados, a partir do pr\u00f3ximo valor eles continuam a partir desse valor. <pre><code>const Value2 = enum(u32) {\nhundred = 100,\nthousand = 1000,\nmillion = 1000000,\nnext,\n};\n\ntest \"set enum ordinal value\" {\ntry expect(@intFromEnum(Value2.hundred) == 100);\ntry expect(@intFromEnum(Value2.thousand) == 1000);\ntry expect(@intFromEnum(Value2.million) == 1000000);\ntry expect(@intFromEnum(Value2.next) == 1000001);\n}\n</code></pre></p> <p>Os m\u00e9todos podem receber enums. Estes agem como fun\u00e7\u00f5es com namespace que podem usar a sintaxe com um ponto.  <pre><code>const Suit = enum {\nclubs,\nspades,\ndiamonds,\nhearts,\npub fn isClubs(self: Suit) bool {\nreturn self == Suit.clubs;\n}\n};\n\ntest \"enum method\" {\ntry expect(Suit.spades.isClubs() == Suit.isClubs(.spades));\n}\n</code></pre></p> <p>Os enums tamb\u00e9m podem receber declara\u00e7\u00f5es <code>var</code>e <code>const</code>. Estes agem como globais com namespace e os seus valores n\u00e3o est\u00e3o relacionados nem anexados \u00e0s inst\u00e2ncias do tipo enum. </p> <pre><code>const Mode = enum {\nvar count: u32 = 0;\non,\noff,\n};\n\ntest \"hmm\" {\nMode.count += 1;\ntry expect(Mode.count == 1);\n}\n</code></pre>"},{"location":"pt/chapter-1/#structs","title":"Structs","text":"<p>Os structs s\u00e3o o tipo de dados comp\u00f3sito mais comum no Zig, permitindo que defina tipos que podem guardar um n\u00famero fixo de campos nomeados. O Zig n\u00e3o oferece nenhuma garantia da ordem dos campos do struct na mem\u00f3ria nem do seu tamanho. Tal como arrays, os structs s\u00e3o criados com a sintaxe <code>T{}</code>. Aqui est\u00e1 um exemplo declarando e preenchendo uma struct. <pre><code>const Vec3 = struct { x: f32, y: f32, z: f32 };\n\ntest \"struct usage\" {\nconst my_vector = Vec3{\n.x = 0,\n.y = 100,\n.z = 50,\n};\n_ = my_vector;\n}\n</code></pre></p> <p>Todos os campos t\u00eam de ter um valor atribuido.</p> <p><pre><code>test \"missing struct field\" {\nconst my_vector = Vec3{\n.x = 0,\n.z = 50,\n};\n_ = my_vector;\n}\n</code></pre> <pre><code>error: missing field: 'y'\n    const my_vector = Vec3{\n                        ^\n</code></pre></p> <p>Os campos podem ter um valor padr\u00e3o: <pre><code>const Vec4 = struct { x: f32, y: f32, z: f32 = 0, w: f32 = undefined };\n\ntest \"struct defaults\" {\nconst my_vector = Vec4{\n.x = 25,\n.y = -50,\n};\n_ = my_vector;\n}\n</code></pre></p> <p>Tal como os enums, os structs podem tamb\u00e9m conter fun\u00e7\u00f5es e declara\u00e7\u00f5es.</p> <p>Os structs tamb\u00e9m t\u00eam uma propriedade \u00fanica em que quando recebem um ponteiro para um struct, \u00e9 feito derefer\u00eancia automaticamente ao aceder os seus campos. observe como neste exemplo, o self.x e o self.y s\u00e3o acessados na fun\u00e7\u00e3o swap sem precisar de fazer a derefer\u00eancia do ponteiro self.</p> <pre><code>const Stuff = struct {\nx: i32,\ny: i32,\nfn swap(self: *Stuff) void {\nconst tmp = self.x;\nself.x = self.y;\nself.y = tmp;\n}\n};\n\ntest \"automatic dereference\" {\nvar thing = Stuff{ .x = 10, .y = 20 };\nthing.swap();\ntry expect(thing.x == 20);\ntry expect(thing.y == 10);\n}\n</code></pre>"},{"location":"pt/chapter-1/#unioes","title":"Uni\u00f5es","text":"<p>As uni\u00f5es do Zig permitem que declare tipos que guarde um valor de v\u00e1rios tipos dependendo do campo; s\u00f3 um campo pode estar ativo de cada vez.</p> <p>Uni\u00f5es por s\u00ed s\u00f3 n\u00e3o t\u00eam um layout de mem\u00f3ria garantido. Por causa disso, eles n\u00e3o podem ser utilizados para reinterpretar a mem\u00f3ria. Acessar um campo de uma uniao que n\u00e3o est\u00e1 ativo e um comportamento ilegal detet\u00e1vel.</p> <p><pre><code>const Result = union {\nint: i64,\nfloat: f64,\nbool: bool,\n};\n\ntest \"simple union\" {\nvar result = Result{ .int = 1234 };\nresult.float = 12.34;\n}\n</code></pre> <pre><code>Test [1/1] test.simple union... thread 6604310 panic: access of union field 'float' while field 'int' is active\n./tests.zig:9:11: 0x10487c807 in test.simple union (test)\n    result.float = 12.34;\n</code></pre></p> <p>Uni\u00f5es marcadas s\u00e3o uni\u00f5es que usam um enum para detetar qual campo est\u00e1 ativo. Aqui fazemos outra vez o uso da captura do payload para poder se fazer switch na tag do tipo de uma uni\u00e3o enquanto se captura o valor contido nele. Aqui usamos uma <code>captura do ponteiro</code>; A captura de valores \u00e9 imut\u00e1vel, mas com a sintaxe <code>|*valor|</code> podemos capturar o ponteiro os valores em vez dos pr\u00f3prios valores. Isto permite-nos usar derefer\u00eancia para mutar o valor original.</p> <pre><code>const Tag = enum { a, b, c };\n\nconst Tagged = union(Tag) { a: u8, b: f32, c: bool };\n\ntest \"switch on tagged union\" {\nvar value = Tagged{ .b = 1.5 };\nswitch (value) {\n.a =&gt; |*byte| byte.* += 1,\n.b =&gt; |*float| float.* *= 2,\n.c =&gt; |*b| b.* = !b.*,\n}\ntry expect(value.b == 3);\n}\n</code></pre> <p>O tipo da tag de uma uni\u00e3o marcada pode tamb\u00e9m ser inferida. Isto \u00e9 equivalente ao tipo marcado em cima.</p> <pre><code>const Tagged = union(enum) { a: u8, b: f32, c: bool };\n</code></pre> <p>Membros tipo <code>void</code> podem ter os seus tipos omitidos da sintaxe. Aqui, nenhum deles \u00e9 do tipo <code>void</code>. </p> <pre><code>const Tagged2 = union(enum) { a: u8, b: f32, c: bool, none };\n</code></pre>"},{"location":"pt/chapter-1/#regras-para-inteiros","title":"Regras para inteiros","text":"<p>O Zig suporta numeros literais hexadecimais, octais e bin\u00e1rios. <pre><code>const decimal_int: i32 = 98222;\nconst hex_int: u8 = 0xff;\nconst another_hex_int: u8 = 0xFF;\nconst octal_int: u16 = 0o755;\nconst binary_int: u8 = 0b11110000;\n</code></pre></p> <p>O underscore pode tamb\u00e9m ser colocado entre os d\u00edgitos como um separador visual. <pre><code>const one_billion: u64 = 1_000_000_000;\nconst binary_mask: u64 = 0b1_1111_1111;\nconst permissions: u64 = 0o7_5_5;\nconst big_address: u64 = 0xFF80_0000_0000_0000;\n</code></pre></p> <p>\"Aumento do inteiro\" \u00e9 permitido, ou seja os inteiros de um determinado tipo coagem a outro tipo de inteiro, desde que o novo tipo consiga armazenar todos os valores contidos no tipo anterior.</p> <pre><code>test \"integer widening\" {\nconst a: u8 = 250;\nconst b: u16 = a;\nconst c: u32 = b;\ntry expect(c == a);\n}\n</code></pre> <p>Se tiver valor guardado em um inteiro que n\u00e3o possa ser coagido para o tipo que queira, <code>@intCast</code> pode ser usado para converter explicitamente de um tipo para o outro. Se o valor usado estiver fora do intervalo de valores permitidos para o tipo de destino, isso \u00e9 considerado como um comportamento ilegal detet\u00e1vel.</p> <pre><code>test \"@intCast\" {\nconst x: u64 = 200;\nconst y = @as(u8, @intCast(x));\ntry expect(@TypeOf(y) == u8);\n}\n</code></pre> <p>Os inteiros por padr\u00e3o n\u00e3o aceitam overflows. Os overflows s\u00e3o comportamentos detet\u00e1veis ilegais. \u00c0s vezes ser capaz de causar overflows num inteiro \u00e9 um comportamento bem definido e desejado. Para isto o Zig fornece operadores capazes de causar overflows. </p> Operador Normal Operador com Overflow + +% - -% * *% += +%= -= -%= *= *%= <pre><code>test \"well defined overflow\" {\nvar a: u8 = 255;\na +%= 1;\ntry expect(a == 0);\n}\n</code></pre>"},{"location":"pt/chapter-1/#floats","title":"Floats","text":"<p>Os floats (n\u00fameros com pontos flutuantes) do Zig s\u00e3o estritamente em conformidade com o IEEE, a n\u00e3o ser que <code>@setFloatMode(.Optimized)</code> seja usado, que \u00e9 equivalente ao <code>-ffast-math</code> do GCC. Floats coagem a tipos de floats maiores.</p> <pre><code>test \"float widening\" {\nconst a: f16 = 0;\nconst b: f32 = a;\nconst c: f128 = b;\ntry expect(c == @as(f128, a));\n}\n</code></pre> <p>Floats suportam v\u00e1rios tipos de literais. <pre><code>const floating_point: f64 = 123.0E+77;\nconst another_float: f64 = 123.0;\nconst yet_another: f64 = 123.0e+77;\n\nconst hex_floating_point: f64 = 0x103.70p-5;\nconst another_hex_float: f64 = 0x103.70;\nconst yet_another_hex_float: f64 = 0x103.70P-5;\n</code></pre></p> <p>Underscores podem tamb\u00e9m ser utilizados entre os digitos. <pre><code>const lightspeed: f64 = 299_792_458.000_000;\nconst nanosecond: f64 = 0.000_000_001;\nconst more_hex: f64 = 0x1234_5678.9ABC_CDEFp-10;\n</code></pre></p> <p>Inteiros e floats podem ser convertidos usando as fun\u00e7\u00f5es built-in <code>@floatFromInt</code> e <code>@intFromFloat</code>. <code>@floatFromInt</code> \u00e9 sempre seguro, enquanto que <code>@intFromFloat</code> \u00e9 um comportamento ilegal detet\u00e1vel se o valor do float n\u00e3o cabe no tipo do inteiro de destino. <pre><code>test \"int-float conversion\" {\nconst a: i32 = 0;\nconst b = @as(f32, @floatFromInt(a));\nconst c = @as(i32, @intFromFloat(b));\ntry expect(c == a);\n}\n</code></pre></p>"},{"location":"pt/chapter-1/#blocos-rotulados-blk","title":"Blocos rotulados <code>:blk {}</code>","text":"<p>Os blocos no Zig s\u00e3o express\u00f5es que podem receber r\u00f3tulos que s\u00e3o utilizados para retornar valores. Aqui n\u00f3s usamos um r\u00f3tulo chamado de blk. Os blocos retornam valores, ou seja, eles podem ser usados no lugar dos valores. O valor de um bloco vazio <code>{}</code> \u00e9 o valor do tipo <code>void</code>.</p> <pre><code>test \"labelled blocks\" {\nconst count = blk: {\nvar sum: u32 = 0;\nvar i: u32 = 0;\nwhile (i &lt; 10) : (i += 1) sum += i;\nbreak :blk sum;\n};\ntry expect(count == 45);\ntry expect(@TypeOf(count) == u32);\n}\n</code></pre> <p>Isto pode ser considerado como o equivalente do <code>i++</code>do C.</p> <pre><code>blk: {\nconst tmp = i;\ni += 1;\nbreak :blk tmp;\n}\n</code></pre>"},{"location":"pt/chapter-1/#loops-rotulados","title":"Loops rotulados","text":"<p>Os loops podem receber r\u00f3tulas, permitindo assim fazer <code>break</code>e <code>continue</code> para os loops externos.</p> <pre><code>test \"nested continue\" {\nvar count: usize = 0;\nouter: for ([_]i32{ 1, 2, 3, 4, 5, 6, 7, 8 }) |_| {\nfor ([_]i32{ 1, 2, 3, 4, 5 }) |_| {\ncount += 1;\ncontinue :outer;\n}\n}\ntry expect(count == 8);\n}\n</code></pre>"},{"location":"pt/chapter-1/#loops-como-expressoes","title":"Loops como express\u00f5es","text":"<p>Como o <code>return</code>, o <code>break</code> aceita um valor. Isto pode ser usado para return um valor do loop. Os loops no Zig tamb\u00eam t\u00eam um ramo <code>else</code> que \u00e9 executado quando o loop n\u00e3o \u00e9 parado com um <code>break</code>.</p> <pre><code>fn rangeHasNumber(begin: usize, end: usize, number: usize) bool {\nvar i = begin;\nreturn while (i &lt; end) : (i += 1) {\nif (i == number) {\nbreak true;\n}\n} else false;\n}\n\ntest \"while loop expression\" {\ntry expect(rangeHasNumber(0, 10, 3));\n}\n</code></pre>"},{"location":"pt/chapter-1/#opcionais-t","title":"Opcionais <code>?T</code>","text":"<p>Opcionais usam a sintaxe <code>?T</code> e s\u00e3o usados para guardar <code>null</code>, ou um valor com o tipo <code>T</code>.</p> <pre><code>test \"optional\" {\nvar found_index: ?usize = null;\nconst data = [_]i32{ 1, 2, 3, 4, 5, 6, 7, 8, 12 };\nfor (data, 0..) |v, i| {\nif (v == 10) found_index = i;\n}\ntry expect(found_index == null);\n}\n</code></pre> <p>Opcionais suportam express\u00f5es <code>orelse</code> que executam quando a opcional \u00e9 <code>null</code>. Isto torna o valor optional no seu tipo base.</p> <pre><code>test \"orelse\" {\nvar a: ?f32 = null;\nvar b = a orelse 0;\ntry expect(b == 0);\ntry expect(@TypeOf(b) == f32);\n}\n</code></pre> <p>O <code>.?</code> \u00e9 uma abrevia\u00e7\u00e3o para <code>orelse unreachable</code>. Isto \u00e9 usado quando sabemos que \u00e9 imposs\u00edvel para um valor opcional ser null, usar isto num valor <code>null</code> \u00e9 um comportamento ilegal detet\u00e1vel.</p> <pre><code>test \"orelse unreachable\" {\nconst a: ?f32 = 5;\nconst b = a orelse unreachable;\nconst c = a.?;\ntry expect(b == c);\ntry expect(@TypeOf(c) == f32);\n}\n</code></pre> <p>A captura de payload funciona em v\u00e1rios lugares para opcionais, ou seja, caso o valor n\u00e3o seja null n\u00f3s podemos \"capturar\" esse valor.</p> <p>Aqui n\u00f3s usamos uma captura de payload com um opcional num <code>if</code>; a e b s\u00e3o equivalentes aqui. <code>if (b) |valor|</code>captura o valor de <code>b</code> (nos casos onde <code>b</code> n\u00e3o \u00e9 null) e faz com que esse <code>valor</code> possa ser usado. Como no exemplo com a uni\u00e3o, o valor capturado \u00e9 imut\u00e1vel, mas aqui n\u00f3s ainda podemos usar o ponteiro capturado para modificar o valor em <code>b</code>.</p> <pre><code>test \"if optional payload capture\" {\nconst a: ?i32 = 5;\nif (a != null) {\nconst value = a.?;\n_ = value;\n}\n\nvar b: ?i32 = 5;\nif (b) |*value| {\nvalue.* += 1;\n}\ntry expect(b.? == 6);\n}\n</code></pre> <p>E com <code>while</code>: <pre><code>var numbers_left: u32 = 4;\nfn eventuallyNullSequence() ?u32 {\nif (numbers_left == 0) return null;\nnumbers_left -= 1;\nreturn numbers_left;\n}\n\ntest \"while null capture\" {\nvar sum: u32 = 0;\nwhile (eventuallyNullSequence()) |value| {\nsum += value;\n}\ntry expect(sum == 6); // 3 + 2 + 1\n}\n</code></pre></p> <p>Ponteiros e slices opcionais n\u00e3o ocupam nenhum espa\u00e7o extra na mem\u00f3ria quando comparado com as n\u00e3o opcionais. Isto \u00e9 porque internamente eles usam o valor 0 do ponteiro para <code>null</code>. Os ponteiros em Zig funcionam assim - eles t\u00eam de ser desempacotados para um n\u00e3o opcional antes de serem dereferenciados o que previne a derefer\u00eancia acidental de ponteiros null.</p>"},{"location":"pt/chapter-1/#comptime","title":"Comptime","text":"<p>Blocos de c\u00f3digo podem for\u00e7ar a executa\u00e7\u00e3o durante a compila\u00e7\u00e3o usando o <code>comptime</code>. Neste exemplo as vari\u00e1veis x e y s\u00e3o equivalentes.</p> <pre><code>test \"comptime blocks\" {\nvar x = comptime fibonacci(10);\n_ = x;\n\nvar y = comptime blk: {\nbreak :blk fibonacci(10);\n};\n_ = y;\n}\n</code></pre> <p>Inteiros literais s\u00e3o do tipo <code>comptime_int</code>. Eles s\u00e3o tipos especiais porque n\u00e3o t\u00eam um tamanho especifico (eles n\u00e3o podem ser usados durante a execu\u00e7\u00e3o) e t\u00eam precis\u00e3o arbitr\u00e1ria. Os valores do tipo <code>comptime_int</code> coagem a qualquer tipo de inteiro em que podem caber. Eles tamb\u00e9m coagem a floats. Caract\u00e9res literais s\u00e3o tamb\u00e9m deste tipo.</p> <pre><code>test \"comptime_int\" {\nconst a = 12;\nconst b = a + 10;\n\nconst c: u4 = a;\n_ = c;\nconst d: f32 = b;\n_ = d;\n}\n</code></pre> <p>Tamb\u00e9m existe <code>comptime_float</code>, que internamente \u00e9 um <code>f128</code>. Estes n\u00e3o podem ser coagidos a inteiros mesmo que caibam num valor inteiro.</p> <p>Os tipos no Zig s\u00e3o valores do tipo <code>type</code>. Estes est\u00e3o dispon\u00edveis durante a compila\u00e7\u00e3o. N\u00f3s os vimos anteriormente ao usar verificar o <code>@TypeOf</code> e comparar com outros tipos, mas n\u00f3s podemos fazer mais do que isso.</p> <pre><code>test \"branching on types\" {\nconst a = 5;\nconst b: if (a &lt; 10) f32 else i32 = 5;\n_ = b;\n}\n</code></pre> <p>Os parametros das fun\u00e7\u00f5es em Zig podem ser marcados como sendo <code>comptime</code>. Isso significa que o valor passado a essa fun\u00e7\u00e3o tem de ser conhecida durante a compila\u00e7\u00e3o. Vamos criar uma fun\u00e7\u00e3o que retorne um tipo. Observe como a fun\u00e7\u00e3o usa PascalCase isto \u00e9 porque ela retorna um tipo. </p> <pre><code>fn Matrix(\ncomptime T: type,\ncomptime width: comptime_int,\ncomptime height: comptime_int,\n) type {\nreturn [height][width]T;\n}\n\ntest \"returning a type\" {\ntry expect(Matrix(f32, 4, 4) == [4][4]f32);\n}\n</code></pre> <p>N\u00f3s podemos refletir tipos usando o built-in <code>@typeInfo</code>, que toma um <code>type</code> e retorna uma uni\u00e3o marcada. Este tipo de uni\u00e3o marcada pode ser encontrada em <code>std.builtin.Type</code> (mais informa\u00e7\u00f5es sobre como importar e usar std ser\u00e3o dadas mais tarde).</p> <pre><code>fn addSmallInts(comptime T: type, a: T, b: T) T {\nreturn switch (@typeInfo(T)) {\n.ComptimeInt =&gt; a + b,\n.Int =&gt; |info| if (info.bits &lt;= 16)\na + b\nelse\n@compileError(\"ints too large\"),\nelse =&gt; @compileError(\"only ints accepted\"),\n};\n}\n\ntest \"typeinfo switch\" {\nconst x = addSmallInts(u16, 20, 30);\ntry expect(@TypeOf(x) == u16);\ntry expect(x == 50);\n}\n</code></pre> <p>Podemos usar a fun\u00e7\u00e3o <code>@Type</code> para criar um tipo a partir de um <code>@typeInfo</code>. Aqui usamos structs an\u00f3nimas com <code>.{}</code>, porque o <code>T</code> em <code>T{}</code> pode ser inferido. Structs an\u00f3nimas ser\u00e3o abordadas em detalhe mais tarde. Neste examplo vamos ter um erro de compila\u00e7\u00e3o se o r\u00f3tulo <code>Int</code> n\u00e3o estiver definido.</p> <pre><code>fn GetBiggerInt(comptime T: type) type {\nreturn @Type(.{\n.Int = .{\n.bits = @typeInfo(T).Int.bits + 1,\n.signedness = @typeInfo(T).Int.signedness,\n},\n});\n}\n\ntest \"@Type\" {\ntry expect(GetBiggerInt(u8) == u9);\ntry expect(GetBiggerInt(i31) == i32);\n}\n</code></pre> <p>Em zig estruturas de dados gen\u00e9ricos s\u00e3o feitos retornando uma struct. O uso de <code>@This</code> \u00e9 necess\u00e1rio aqui, ele retorna a struct, union ou enum mais contida. Aqui tamb\u00e9m usamos <code>std.mem.eql</code> para comparar dois slices. </p> <pre><code>fn Vec(\ncomptime count: comptime_int,\ncomptime T: type,\n) type {\nreturn struct {\ndata: [count]T,\nconst Self = @This();\n\nfn abs(self: Self) Self {\nvar tmp = Self{ .data = undefined };\nfor (self.data, 0..) |elem, i| {\ntmp.data[i] = if (elem &lt; 0)\n-elem\nelse\nelem;\n}\nreturn tmp;\n}\n\nfn init(data: [count]T) Self {\nreturn Self{ .data = data };\n}\n};\n}\n\nconst eql = @import(\"std\").mem.eql;\n\ntest \"generic vector\" {\nconst x = Vec(3, f32).init([_]f32{ 10, -10, 5 });\nconst y = x.abs();\ntry expect(eql(f32, &amp;y.data, &amp;[_]f32{ 10, 10, 5 }));\n}\n</code></pre> <p>O tipo dos par\u00e2metros das fun\u00e7\u00f5es podem tamb\u00e9m ser inferidos usando <code>anytype</code> no lugar desse tipo. Ent\u00e3o <code>@TypeOf</code> pode ser usado nos par\u00e2metros. </p> <pre><code>fn plusOne(x: anytype) @TypeOf(x) {\nreturn x + 1;\n}\n\ntest \"inferred function parameter\" {\ntry expect(plusOne(@as(u32, 1)) == 2);\n}\n</code></pre> <p>O comptime introduz tamb\u00e9m alguns operadores <code>++</code> e <code>**</code> para concatenar e repetir arrays e slices. Estes operadores n\u00e3o funcionam durante a execu\u00e7\u00e3o.</p> <pre><code>test \"++\" {\nconst x: [4]u8 = undefined;\nconst y = x[0..];\n\nconst a: [6]u8 = undefined;\nconst b = a[0..];\n\nconst new = y ++ b;\ntry expect(new.len == 10);\n}\n\ntest \"**\" {\nconst pattern = [_]u8{ 0xCC, 0xAA };\nconst memory = pattern ** 3;\ntry expect(eql(u8, &amp;memory, &amp;[_]u8{ 0xCC, 0xAA, 0xCC, 0xAA, 0xCC, 0xAA }));\n}\n</code></pre>"},{"location":"pt/chapter-1/#captura-de-payloads-n","title":"Captura de payloads <code>|n|</code>","text":"<p>A captura de payloads usa a sintaxe <code>|valor|</code> e aparece em v\u00e1rios lugares, n\u00f3s j\u00e1 vimos alguns deles. Sempre que aparecem s\u00e3o usados para \"capturar\" o valor de alguma coisa.</p> <p>Com declara\u00e7\u00f5es if e opcionais. <pre><code>test \"optional-if\" {\nvar maybe_num: ?usize = 10;\nif (maybe_num) |n| {\ntry expect(@TypeOf(n) == usize);\ntry expect(n == 10);\n} else {\nunreachable;\n}\n}\n</code></pre></p> <p>With if statements and error unions. The else with the error capture is required here. Com declara\u00e7\u00f5es if e uni\u00e3o de erros <pre><code>test \"error union if\" {\nvar ent_num: error{UnknownEntity}!u32 = 5;\nif (ent_num) |entity| {\ntry expect(@TypeOf(entity) == u32);\ntry expect(entity == 5);\n} else |err| {\n_ = err catch {};\nunreachable;\n}\n}\n</code></pre></p> <p>Com loops while e opcionais. Isto pode ter um bloco else. <pre><code>test \"while optional\" {\nvar i: ?u32 = 10;\nwhile (i) |num| : (i.? -= 1) {\ntry expect(@TypeOf(num) == u32);\nif (num == 1) {\ni = null;\nbreak;\n}\n}\ntry expect(i == null);\n}\n</code></pre></p> <p>Com loops while e com uni\u00e3o de erros. O else com a captura do erro \u00e9 necess\u00e1rio aqui.</p> <pre><code>var numbers_left2: u32 = undefined;\n\nfn eventuallyErrorSequence() !u32 {\nreturn if (numbers_left2 == 0) error.ReachedZero else blk: {\nnumbers_left2 -= 1;\nbreak :blk numbers_left2;\n};\n}\n\ntest \"while error union capture\" {\nvar sum: u32 = 0;\nnumbers_left2 = 3;\nwhile (eventuallyErrorSequence()) |value| {\nsum += value;\n} else |err| {\ntry expect(err == error.ReachedZero);\n}\n}\n</code></pre> <p>Loops for. <pre><code>test \"for capture\" {\nconst x = [_]i8{ 1, 5, 120, -5 };\nfor (x) |v| try expect(@TypeOf(v) == i8);\n}\n</code></pre></p> <p>Switch com uni\u00f5es marcadas. <pre><code>const Info = union(enum) {\na: u32,\nb: []const u8,\nc,\nd: u32,\n};\n\ntest \"switch capture\" {\nvar b = Info{ .a = 10 };\nconst x = switch (b) {\n.b =&gt; |str| blk: {\ntry expect(@TypeOf(str) == []const u8);\nbreak :blk 1;\n},\n.c =&gt; 2,\n//if these are of the same type, they\n//may be inside the same capture group\n.a, .d =&gt; |num| blk: {\ntry expect(@TypeOf(num) == u32);\nbreak :blk num * 2;\n},\n};\ntry expect(x == 20);\n}\n</code></pre></p> <p>Como vimos nas sec\u00e7\u00f5es de Uni\u00f5es e Opcionais em cima, os valores capturados com a sintaxe <code>|val|</code> s\u00e3o imut\u00e1veis (como os argumentos das fun\u00e7\u00f5es), mas podemos usar um ponteiro para modificar o valor original. A captura de valores como ponteiros s\u00e3o tamb\u00e9m imut\u00e1veis, mas porque o valor \u00e9 um ponteiro, n\u00f3s podemos modificar o valor original fazendo derefer\u00eancia nele:</p> <pre><code>test \"for with pointer capture\" {\nvar data = [_]u8{ 1, 2, 3 };\nfor (&amp;data) |*byte| byte.* += 1;\ntry expect(eql(u8, &amp;data, &amp;[_]u8{ 2, 3, 4 }));\n}\n</code></pre>"},{"location":"pt/chapter-1/#loops-inline","title":"Loops Inline","text":"<p>Os loops <code>inline</code> s\u00e3o desenrolados e permitem algumas coisas que s\u00f3 podem acontecer durante a compila\u00e7\u00e3o. Aqui usamos o <code>for</code>, mas o <code>while</code> tamb\u00e9m funciona do mesmo jeito. <pre><code>test \"inline for\" {\nconst types = [_]type{ i32, f32, u8, bool };\nvar sum: usize = 0;\ninline for (types) |T| sum += @sizeOf(T);\ntry expect(sum == 10);\n}\n</code></pre></p> <p>Usar estes loops para melhorar a performance n\u00e3o \u00e9 aconselh\u00e1vel a n\u00e3o ser que tenha feito testes e desenrolar os loops foram mais perform\u00e1ticos; o compilador costuma tomar melhores decis\u00f5es que as que poderia tomar geralmente.</p>"},{"location":"pt/chapter-1/#opaque","title":"Opaque","text":"<p>Os tipos <code>opaque</code> no Zig s\u00e3o tipos que n\u00e3o t\u00eam um tamanho e um alinhamento conhecidos (mas que n\u00e3o sejam zero). Por isso estes tipos de dados n\u00e3o podem ser armazenados diretamente. Estes s\u00e3o usados para manter o seguran\u00e7a dos tipos com ponteiros para tipos de que n\u00e3o temos nenhuma informa\u00e7\u00e3o.</p> <p><pre><code>const Window = opaque {};\nconst Button = opaque {};\n\nextern fn show_window(*Window) callconv(.C) void;\n\ntest \"opaque\" {\nvar main_window: *Window = undefined;\nshow_window(main_window);\n\nvar ok_button: *Button = undefined;\nshow_window(ok_button);\n}\n</code></pre> <pre><code>tests.zig:11:17: error: expected type '*tests.Window', found '*tests.Button'\n    show_window(ok_button);\n                ^~~~~~~~~\ntests.zig:11:17: note: pointer type child 'tests.Button' cannot cast into pointer type child 'tests.Window'\ntests.zig:2:16: note: opaque declared here\nconst Button = opaque {};\n               ^~~~~~~~~\ntests.zig:1:16: note: opaque declared here\nconst Window = opaque {};\n               ^~~~~~~~~\ntests.zig:4:23: note: parameter type declared here\nextern fn show_window(*Window) callconv(.C) void;\n                      ^~~~~~~\n</code></pre></p> <p>Tipos opacos (opaque) podem ter declara\u00e7\u00f5es nas suas defini\u00e7\u00f5es (o mesmo que structs, enums, unions).</p> <pre><code>const Window = opaque {\nfn show(self: *Window) void {\nshow_window(self);\n}\n};\n\nextern fn show_window(*Window) callconv(.C) void;\n\ntest \"opaque with declarations\" {\nvar main_window: *Window = undefined;\nmain_window.show();\n}\n</code></pre> <p>O uso tipico de opaque \u00e9 para manter a seguran\u00e7a dos tipos quando se est\u00e1 interoperando com programas em C que n\u00e3o exp\u00f5em completamente a informa\u00e7\u00e3o dos seus tipos.</p>"},{"location":"pt/chapter-1/#structs-anonimas","title":"Structs an\u00f3nimas  <code>.{}</code>","text":"<p>O tipo de structs podem ser omitidos de uma struct literal. Estas literais podem coagir para outros tipos de structs.</p> <pre><code>test \"anonymous struct literal\" {\nconst Point = struct { x: i32, y: i32 };\n\nvar pt: Point = .{\n.x = 13,\n.y = 67,\n};\ntry expect(pt.x == 13);\ntry expect(pt.y == 67);\n}\n</code></pre> <p>Structs an\u00f3nimas podem ser completamente an\u00f3nimas ou seja sem serem coagidas a outro tipo de struct.</p> <pre><code>test \"fully anonymous struct\" {\ntry dump(.{\n.int = @as(u32, 1234),\n.float = @as(f64, 12.34),\n.b = true,\n.s = \"hi\",\n});\n}\n\nfn dump(args: anytype) !void {\ntry expect(args.int == 1234);\ntry expect(args.float == 12.34);\ntry expect(args.b);\ntry expect(args.s[0] == 'h');\ntry expect(args.s[1] == 'i');\n}\n</code></pre> <p>Podem ser criadas structs an\u00f3nimas sem campos nomeados, elas s\u00e3o chamadas de tuplas. Estes t\u00eam muitas das mesmas propriedades que t\u00eam os arrays; as tuplas podem ser iteradas, indexadas, usadas com os operadores <code>++</code> e <code>**</code>, t\u00eam um campo len. Internamente, eles t\u00eam campos com nomes come\u00e7ando por <code>\"0\"</code>, que podem ser acessados com a sintaxe especial <code>@\"0\"</code>que age como um escape para a sintaxe - coisas dentro do <code>@\"\"</code> s\u00e3o sempre considerados como identificadores.</p> <p>Um loop <code>inline</code> deve ser usado para iterar uma tupla aqui, j\u00e1 que o tipo de cada campo da tupla podem ser diferentes.</p> <pre><code>test \"tuple\" {\nconst values = .{\n@as(u32, 1234),\n@as(f64, 12.34),\ntrue,\n\"hi\",\n} ++ .{false} ** 2;\ntry expect(values[0] == 1234);\ntry expect(values[4] == false);\ninline for (values, 0..) |v, i| {\nif (i != 2) continue;\ntry expect(v);\n}\ntry expect(values.len == 6);\ntry expect(values.@\"3\"[0] == 'h');\n}\n</code></pre>"},{"location":"pt/chapter-1/#sentinela-de-termino-ntt-tt-and-tt","title":"Sentinela de t\u00e9rmino: <code>[N:t]T</code>, <code>[:t]T</code>, and <code>[*:t]T</code>","text":"<p>Arrays, slices e ponteiros de v\u00e1rios \u00edtens podem terminar com um valor do seu tipo base. Isto \u00e9 conhecido como sentinela de t\u00e9rmino. Eles usam a sintaxe <code>[N:t]T</code>, <code>[:t]T</code>, e <code>[*:t]T</code>, onde <code>t</code> \u00e9 um valor do tipo base <code>T</code>.</p> <p>O exemplo de um array com uma sentinela de t\u00e9rmino. O built-in <code>@bitCast</code> \u00e9 usado para fazer uma convers\u00e3o insegura de um tipo bit-a-bit. Isto mostra-nos que o \u00faltimo elemento do array \u00e9 seguido por um byte 0.</p> <pre><code>test \"sentinel termination\" {\nconst terminated = [3:0]u8{ 3, 2, 1 };\ntry expect(terminated.len == 3);\ntry expect(@as(*const [4]u8, @ptrCast(&amp;terminated))[3] == 0);\n}\n</code></pre> <p>Os tipo de strings literais \u00e9 <code>*const [N:0]u8</code>, onde N \u00e9 o comprimento da string. Isto permite que as strings literais coajam para uma slice com setinela de t\u00e9rmino e ponteiros de v\u00e1rios \u00edtens com sentinela de t\u00e9rmino. Obs: As strings literais est\u00e3o codificadas em UTF-8.</p> <pre><code>test \"string literal\" {\ntry expect(@TypeOf(\"hello\") == *const [5:0]u8);\n}\n</code></pre> <p><code>[*:0]u8</code> and <code>[*:0]const u8</code> perfectly model C's strings.</p> <pre><code>test \"C string\" {\nconst c_string: [*:0]const u8 = \"hello\";\nvar array: [5]u8 = undefined;\n\nvar i: usize = 0;\nwhile (c_string[i] != 0) : (i += 1) {\narray[i] = c_string[i];\n}\n}\n</code></pre> <p>Os tipos com sentinelas de t\u00e9rminos s\u00e3o coagidas aos seus tipos sem sentinelas.</p> <pre><code>test \"coercion\" {\nvar a: [*:0]u8 = undefined;\nconst b: [*]u8 = a;\n_ = b;\n\nvar c: [5:0]u8 = undefined;\nconst d: [5]u8 = c;\n_ = d;\n\nvar e: [:10]f32 = undefined;\nconst f = e;\n_ = f;\n}\n</code></pre> <p>\u00c9 poss\u00edvel criar slices com sentinelas de t\u00e9rmino, elas s\u00e3o criadas com a sintaxe <code>x[n..m:t]</code>, onde <code>t</code> \u00e9 o valor de t\u00e9rmino. Fazer isso \u00e9 afirmar para o programador que a mem\u00f3ria \u00e9 terminada onde \u00e9 esperado - errar isso \u00e9 um comportamento detet\u00e1vel ilegal.</p> <pre><code>test \"sentinel terminated slicing\" {\nvar x = [_:0]u8{255} ** 3;\nconst y = x[0..3 :0];\n_ = y;\n}\n</code></pre>"},{"location":"pt/chapter-1/#vetores","title":"Vetores","text":"<p>O Zig fornece tipos de vetores para SIMD. Estes n\u00e3o devem ser confundidos com vetores no seu sentido matem\u00e1tico nem com os vetores em C++ como std::vector (para isto, veja \"ArrayList\" no capitulo 2). Os vetores s\u00e3o criados com a fun\u00e7\u00e3o built-in @Vector.</p> <p>Um vetor \u00e9 um grupo de Inteiros, Floats, ou Ponteiros que s\u00e3o executados em paralelo, usando instru\u00e7\u00f5es SIMD quando poss\u00edvel.</p> <p>As opera\u00e7\u00f5es podem ser feitas com vetores que tenham o mesmo comprimento e o mesmo tipo base. As opera\u00e7\u00f5es s\u00e3o efetuadas em cada valor do vetor. O <code>std.meta.eql</code> \u00e9 usado aqui para verificar a igualdade entre os dois vetores. (\u00e9 tamb\u00e9m \u00fatil para outros tipos como structs).</p> <pre><code>const meta = @import(\"std\").meta;\n\ntest \"vector add\" {\nconst x: @Vector(4, f32) = .{ 1, -10, 20, -1 };\nconst y: @Vector(4, f32) = .{ 2, 10, 0, 1 };\nconst z = x + y;\ntry expect(meta.eql(z, @Vector(4, f32){ 3, 0, 20, 0 }));\n}\n</code></pre> <p>Os vetores s\u00e3o index\u00e1veis. <pre><code>test \"vector indexing\" {\nconst x: @Vector(4, u8) = .{ 255, 0, 255, 0 };\ntry expect(x[0] == 255);\n}\n</code></pre></p> <p>A fun\u00e7\u00e3o built-in <code>@splat</code> pode ser usada para construir um vetor onde todos os seus valores s\u00e3o iguais. Aqui o usamos para multiplicar o vetor por um escalar.</p> <pre><code>test \"vector * scalar\" {\nconst x: @Vector(3, f32) = .{ 12.5, 37.5, 2.5 };\nconst vec: @Vector(3, f32) = @splat(2);\nconst y = x * vec;\ntry expect(meta.eql(y, @Vector(3, f32){ 25, 75, 5 }));\n}\n</code></pre> <p>Os vetores n\u00e3o t\u00eam um campo <code>len</code> como os arrays, mas ainda assim podem ser usados em loops. Aqui, <code>std.mem.len</code> \u00e9 usado como um atalho para <code>@typeInfo(@TypeOf(x)).Vector.len</code>.</p> <pre><code>const len = @import(\"std\").mem.len;\n\ntest \"vector looping\" {\nconst x = @Vector(4, u8){ 255, 0, 255, 0 };\nvar sum = blk: {\nvar tmp: u10 = 0;\nvar i: u8 = 0;\nwhile (i &lt; 4) : (i += 1) tmp += x[i];\nbreak :blk tmp;\n};\ntry expect(sum == 510);\n}\n</code></pre> <p>Vetores podem coagir aos seus respetivos arrays.</p> <pre><code>const arr: [4]f32 = @Vector(4, f32){ 1, 2, 3, 4 };\n</code></pre> <p>\u00c9 importante ressaltar que usar vetores explicitamente pode resultar em perdas de performance se n\u00e3o fizer as decis\u00f5es acertadas - a auto-vetoriza\u00e7\u00e3o do compilador j\u00e1 \u00e9 inteligente o suficiente.</p>"},{"location":"pt/chapter-1/#importacoes","title":"Importa\u00e7\u00f5es","text":"<p>A fun\u00e7\u00e3o built-in <code>@import</code> recebe um ficheiro e retorna uma struct baseada no ficheiro. Todas as declara\u00e7\u00f5es marcadas como <code>pub</code> (p\u00fablico) ser\u00e3o incluidas neste novo struct.</p> <p><code>@import(\"std\")</code> \u00e9 um caso especial no compilador, ele oferece-nos acesso \u00e0 biblioteca padr\u00e3o. Outros <code>@import</code>s recebem um caminho para um ficheiro ou nome de um pacote (falaremos de pacotes num capitulo mais \u00e0 frente).</p> <p>N\u00f3s exploraremos mais sobre a biblioteca padr\u00e3o nos pr\u00f3ximos cap\u00edtulos.</p>"},{"location":"pt/chapter-1/#fim-do-capitulo","title":"Fim do Cap\u00edtulo","text":"<p>No pr\u00f3ximo cap\u00edtulo n\u00f3s vamos abordar padr\u00f5es comuns, incluindo muitas \u00e1reas \u00fateis da biblioteca padr\u00e3o.</p> <p>Feedback e PRs s\u00e3o bem-vindos.</p>"}]}