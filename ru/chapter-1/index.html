
<!doctype html>
<html lang="ru" class="no-js">
  <head>
    
      <meta charset="utf-8">
      <meta name="viewport" content="width=device-width,initial-scale=1">
      
        <meta name="description" content="Глава 1 — Здесь мы пройдёмся по основам языка программирования Zig. Приблизительное время чтения — менее 1 часа">
      
      
      
      
        <link rel="prev" href="../">
      
      
        <link rel="next" href="../chapter-2/">
      
      
      <link rel="icon" href="../../assets/images/favicon.png">
      <meta name="generator" content="mkdocs-1.5.2, mkdocs-material-9.2.3">
    
    
      
        <title>Глава 1 — Основы - zighelp.org</title>
      
    
    
      <link rel="stylesheet" href="../../assets/stylesheets/main.0e669242.min.css">
      
        
        <link rel="stylesheet" href="../../assets/stylesheets/palette.85d0ee34.min.css">
      
      


    
    
      
    
    
      
        
        
        <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
        <link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Roboto:300,300i,400,400i,700,700i%7CRoboto+Mono:400,400i,700,700i&display=fallback">
        <style>:root{--md-text-font:"Roboto";--md-code-font:"Roboto Mono"}</style>
      
    
    
      <link rel="stylesheet" href="../../stylesheets/extra.css">
    
    <script>__md_scope=new URL("../..",location),__md_hash=e=>[...e].reduce((e,_)=>(e<<5)-e+_.charCodeAt(0),0),__md_get=(e,_=localStorage,t=__md_scope)=>JSON.parse(_.getItem(t.pathname+"."+e)),__md_set=(e,_,t=localStorage,a=__md_scope)=>{try{t.setItem(a.pathname+"."+e,JSON.stringify(_))}catch(e){}}</script>
    
      

    
    
    
  </head>
  
  
    
    
      
    
    
    
    
    <body dir="ltr" data-md-color-scheme="zighelp" data-md-color-primary="indigo" data-md-color-accent="indigo">
  
    
    
      <script>var palette=__md_get("__palette");if(palette&&"object"==typeof palette.color)for(var key of Object.keys(palette.color))document.body.setAttribute("data-md-color-"+key,palette.color[key])</script>
    
    <input class="md-toggle" data-md-toggle="drawer" type="checkbox" id="__drawer" autocomplete="off">
    <input class="md-toggle" data-md-toggle="search" type="checkbox" id="__search" autocomplete="off">
    <label class="md-overlay" for="__drawer"></label>
    <div data-md-component="skip">
      
        
        <a href="#_1" class="md-skip">
          Перейти к содержанию
        </a>
      
    </div>
    <div data-md-component="announce">
      
    </div>
    
    
      

  

<header class="md-header md-header--shadow" data-md-component="header">
  <nav class="md-header__inner md-grid" aria-label="Верхний колонтитул">
    <a href="../.." title="zighelp.org" class="md-header__button md-logo" aria-label="zighelp.org" data-md-component="logo">
      
  <img src="../../assets/images/logo.svg" alt="logo">

    </a>
    <label class="md-header__button md-icon" for="__drawer">
      
      <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><path d="M3 6h18v2H3V6m0 5h18v2H3v-2m0 5h18v2H3v-2Z"/></svg>
    </label>
    <div class="md-header__title" data-md-component="header-title">
      <div class="md-header__ellipsis">
        <div class="md-header__topic">
          <span class="md-ellipsis">
            zighelp.org
          </span>
        </div>
        <div class="md-header__topic" data-md-component="header-topic">
          <span class="md-ellipsis">
            
              Глава 1 — Основы
            
          </span>
        </div>
      </div>
    </div>
    
      
        <form class="md-header__option" data-md-component="palette">
  
    
    
    
    <input class="md-option" data-md-color-media="(prefers-color-scheme)" data-md-color-scheme="zighelp" data-md-color-primary="indigo" data-md-color-accent="indigo"  aria-label="Switch to dark mode"  type="radio" name="__palette" id="__palette_1">
    
      <label class="md-header__button md-icon" title="Switch to dark mode" for="__palette_3" hidden>
        <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><path d="m14.3 16-.7-2h-3.2l-.7 2H7.8L11 7h2l3.2 9h-1.9M20 8.69V4h-4.69L12 .69 8.69 4H4v4.69L.69 12 4 15.31V20h4.69L12 23.31 15.31 20H20v-4.69L23.31 12 20 8.69m-9.15 3.96h2.3L12 9l-1.15 3.65Z"/></svg>
      </label>
    
  
    
    
    
    <input class="md-option" data-md-color-media="(prefers-color-scheme: light)" data-md-color-scheme="zighelp" data-md-color-primary="indigo" data-md-color-accent="indigo"  aria-label="Switch to system preference"  type="radio" name="__palette" id="__palette_2">
    
      <label class="md-header__button md-icon" title="Switch to system preference" for="__palette_1" hidden>
        <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><path d="M12 8a4 4 0 0 0-4 4 4 4 0 0 0 4 4 4 4 0 0 0 4-4 4 4 0 0 0-4-4m0 10a6 6 0 0 1-6-6 6 6 0 0 1 6-6 6 6 0 0 1 6 6 6 6 0 0 1-6 6m8-9.31V4h-4.69L12 .69 8.69 4H4v4.69L.69 12 4 15.31V20h4.69L12 23.31 15.31 20H20v-4.69L23.31 12 20 8.69Z"/></svg>
      </label>
    
  
    
    
    
    <input class="md-option" data-md-color-media="(prefers-color-scheme: dark)" data-md-color-scheme="slate" data-md-color-primary="indigo" data-md-color-accent="indigo"  aria-label="Switch to light mode"  type="radio" name="__palette" id="__palette_3">
    
      <label class="md-header__button md-icon" title="Switch to light mode" for="__palette_2" hidden>
        <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><path d="M12 18c-.89 0-1.74-.2-2.5-.55C11.56 16.5 13 14.42 13 12c0-2.42-1.44-4.5-3.5-5.45C10.26 6.2 11.11 6 12 6a6 6 0 0 1 6 6 6 6 0 0 1-6 6m8-9.31V4h-4.69L12 .69 8.69 4H4v4.69L.69 12 4 15.31V20h4.69L12 23.31 15.31 20H20v-4.69L23.31 12 20 8.69Z"/></svg>
      </label>
    
  
</form>
      
    
    
      <div class="md-header__option">
  <div class="md-select">
    
    <button class="md-header__button md-icon" aria-label="Выберите язык">
      <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><path d="m12.87 15.07-2.54-2.51.03-.03A17.52 17.52 0 0 0 14.07 6H17V4h-7V2H8v2H1v2h11.17C11.5 7.92 10.44 9.75 9 11.35 8.07 10.32 7.3 9.19 6.69 8h-2c.73 1.63 1.73 3.17 2.98 4.56l-5.09 5.02L4 19l5-5 3.11 3.11.76-2.04M18.5 10h-2L12 22h2l1.12-3h4.75L21 22h2l-4.5-12m-2.62 7 1.62-4.33L19.12 17h-3.24Z"/></svg>
    </button>
    <div class="md-select__inner">
      <ul class="md-select__list">
        
          <li class="md-select__item">
            <a href="../.." hreflang="en" class="md-select__link">
              English
            </a>
          </li>
        
          <li class="md-select__item">
            <a href="/ru/" hreflang="ru" class="md-select__link">
              Русский (Russian)
            </a>
          </li>
        
          <li class="md-select__item">
            <a href="/pt/" hreflang="pt" class="md-select__link">
              Português (Portuguese)
            </a>
          </li>
        
      </ul>
    </div>
  </div>
</div>
    
    
      <label class="md-header__button md-icon" for="__search">
        
        <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><path d="M9.5 3A6.5 6.5 0 0 1 16 9.5c0 1.61-.59 3.09-1.56 4.23l.27.27h.79l5 5-1.5 1.5-5-5v-.79l-.27-.27A6.516 6.516 0 0 1 9.5 16 6.5 6.5 0 0 1 3 9.5 6.5 6.5 0 0 1 9.5 3m0 2C7 5 5 7 5 9.5S7 14 9.5 14 14 12 14 9.5 12 5 9.5 5Z"/></svg>
      </label>
      <div class="md-search" data-md-component="search" role="dialog">
  <label class="md-search__overlay" for="__search"></label>
  <div class="md-search__inner" role="search">
    <form class="md-search__form" name="search">
      <input type="text" class="md-search__input" name="query" aria-label="Поиск" placeholder="Поиск" autocapitalize="off" autocorrect="off" autocomplete="off" spellcheck="false" data-md-component="search-query" required>
      <label class="md-search__icon md-icon" for="__search">
        
        <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><path d="M9.5 3A6.5 6.5 0 0 1 16 9.5c0 1.61-.59 3.09-1.56 4.23l.27.27h.79l5 5-1.5 1.5-5-5v-.79l-.27-.27A6.516 6.516 0 0 1 9.5 16 6.5 6.5 0 0 1 3 9.5 6.5 6.5 0 0 1 9.5 3m0 2C7 5 5 7 5 9.5S7 14 9.5 14 14 12 14 9.5 12 5 9.5 5Z"/></svg>
        
        <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><path d="M20 11v2H8l5.5 5.5-1.42 1.42L4.16 12l7.92-7.92L13.5 5.5 8 11h12Z"/></svg>
      </label>
      <nav class="md-search__options" aria-label="Поиск">
        
        <button type="reset" class="md-search__icon md-icon" title="Очистить" aria-label="Очистить" tabindex="-1">
          
          <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><path d="M19 6.41 17.59 5 12 10.59 6.41 5 5 6.41 10.59 12 5 17.59 6.41 19 12 13.41 17.59 19 19 17.59 13.41 12 19 6.41Z"/></svg>
        </button>
      </nav>
      
    </form>
    <div class="md-search__output">
      <div class="md-search__scrollwrap" data-md-scrollfix>
        <div class="md-search-result" data-md-component="search-result">
          <div class="md-search-result__meta">
            Инициализация поиска
          </div>
          <ol class="md-search-result__list" role="presentation"></ol>
        </div>
      </div>
    </div>
  </div>
</div>
    
    
      <div class="md-header__source">
        <a href="https://github.com/zighelp/zighelp/" title="Перейти к репозиторию" class="md-source" data-md-component="source">
  <div class="md-source__icon md-icon">
    
    <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 496 512"><!--! Font Awesome Free 6.4.2 by @fontawesome - https://fontawesome.com License - https://fontawesome.com/license/free (Icons: CC BY 4.0, Fonts: SIL OFL 1.1, Code: MIT License) Copyright 2023 Fonticons, Inc.--><path d="M165.9 397.4c0 2-2.3 3.6-5.2 3.6-3.3.3-5.6-1.3-5.6-3.6 0-2 2.3-3.6 5.2-3.6 3-.3 5.6 1.3 5.6 3.6zm-31.1-4.5c-.7 2 1.3 4.3 4.3 4.9 2.6 1 5.6 0 6.2-2s-1.3-4.3-4.3-5.2c-2.6-.7-5.5.3-6.2 2.3zm44.2-1.7c-2.9.7-4.9 2.6-4.6 4.9.3 2 2.9 3.3 5.9 2.6 2.9-.7 4.9-2.6 4.6-4.6-.3-1.9-3-3.2-5.9-2.9zM244.8 8C106.1 8 0 113.3 0 252c0 110.9 69.8 205.8 169.5 239.2 12.8 2.3 17.3-5.6 17.3-12.1 0-6.2-.3-40.4-.3-61.4 0 0-70 15-84.7-29.8 0 0-11.4-29.1-27.8-36.6 0 0-22.9-15.7 1.6-15.4 0 0 24.9 2 38.6 25.8 21.9 38.6 58.6 27.5 72.9 20.9 2.3-16 8.8-27.1 16-33.7-55.9-6.2-112.3-14.3-112.3-110.5 0-27.5 7.6-41.3 23.6-58.9-2.6-6.5-11.1-33.3 2.6-67.9 20.9-6.5 69 27 69 27 20-5.6 41.5-8.5 62.8-8.5s42.8 2.9 62.8 8.5c0 0 48.1-33.6 69-27 13.7 34.7 5.2 61.4 2.6 67.9 16 17.7 25.8 31.5 25.8 58.9 0 96.5-58.9 104.2-114.8 110.5 9.2 7.9 17 22.9 17 46.4 0 33.7-.3 75.4-.3 83.6 0 6.5 4.6 14.4 17.3 12.1C428.2 457.8 496 362.9 496 252 496 113.3 383.5 8 244.8 8zM97.2 352.9c-1.3 1-1 3.3.7 5.2 1.6 1.6 3.9 2.3 5.2 1 1.3-1 1-3.3-.7-5.2-1.6-1.6-3.9-2.3-5.2-1zm-10.8-8.1c-.7 1.3.3 2.9 2.3 3.9 1.6 1 3.6.7 4.3-.7.7-1.3-.3-2.9-2.3-3.9-2-.6-3.6-.3-4.3.7zm32.4 35.6c-1.6 1.3-1 4.3 1.3 6.2 2.3 2.3 5.2 2.6 6.5 1 1.3-1.3.7-4.3-1.3-6.2-2.2-2.3-5.2-2.6-6.5-1zm-11.4-14.7c-1.6 1-1.6 3.6 0 5.9 1.6 2.3 4.3 3.3 5.6 2.3 1.6-1.3 1.6-3.9 0-6.2-1.4-2.3-4-3.3-5.6-2z"/></svg>
  </div>
  <div class="md-source__repository">
    zighelp/zighelp
  </div>
</a>
      </div>
    
  </nav>
  
</header>
    
    <div class="md-container" data-md-component="container">
      
      
        
          
        
      
      <main class="md-main" data-md-component="main">
        <div class="md-main__inner md-grid">
          
            
              
              <div class="md-sidebar md-sidebar--primary" data-md-component="sidebar" data-md-type="navigation" >
                <div class="md-sidebar__scrollwrap">
                  <div class="md-sidebar__inner">
                    



  

<nav class="md-nav md-nav--primary md-nav--integrated" aria-label="Навигация" data-md-level="0">
  <label class="md-nav__title" for="__drawer">
    <a href="../.." title="zighelp.org" class="md-nav__button md-logo" aria-label="zighelp.org" data-md-component="logo">
      
  <img src="../../assets/images/logo.svg" alt="logo">

    </a>
    zighelp.org
  </label>
  
    <div class="md-nav__source">
      <a href="https://github.com/zighelp/zighelp/" title="Перейти к репозиторию" class="md-source" data-md-component="source">
  <div class="md-source__icon md-icon">
    
    <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 496 512"><!--! Font Awesome Free 6.4.2 by @fontawesome - https://fontawesome.com License - https://fontawesome.com/license/free (Icons: CC BY 4.0, Fonts: SIL OFL 1.1, Code: MIT License) Copyright 2023 Fonticons, Inc.--><path d="M165.9 397.4c0 2-2.3 3.6-5.2 3.6-3.3.3-5.6-1.3-5.6-3.6 0-2 2.3-3.6 5.2-3.6 3-.3 5.6 1.3 5.6 3.6zm-31.1-4.5c-.7 2 1.3 4.3 4.3 4.9 2.6 1 5.6 0 6.2-2s-1.3-4.3-4.3-5.2c-2.6-.7-5.5.3-6.2 2.3zm44.2-1.7c-2.9.7-4.9 2.6-4.6 4.9.3 2 2.9 3.3 5.9 2.6 2.9-.7 4.9-2.6 4.6-4.6-.3-1.9-3-3.2-5.9-2.9zM244.8 8C106.1 8 0 113.3 0 252c0 110.9 69.8 205.8 169.5 239.2 12.8 2.3 17.3-5.6 17.3-12.1 0-6.2-.3-40.4-.3-61.4 0 0-70 15-84.7-29.8 0 0-11.4-29.1-27.8-36.6 0 0-22.9-15.7 1.6-15.4 0 0 24.9 2 38.6 25.8 21.9 38.6 58.6 27.5 72.9 20.9 2.3-16 8.8-27.1 16-33.7-55.9-6.2-112.3-14.3-112.3-110.5 0-27.5 7.6-41.3 23.6-58.9-2.6-6.5-11.1-33.3 2.6-67.9 20.9-6.5 69 27 69 27 20-5.6 41.5-8.5 62.8-8.5s42.8 2.9 62.8 8.5c0 0 48.1-33.6 69-27 13.7 34.7 5.2 61.4 2.6 67.9 16 17.7 25.8 31.5 25.8 58.9 0 96.5-58.9 104.2-114.8 110.5 9.2 7.9 17 22.9 17 46.4 0 33.7-.3 75.4-.3 83.6 0 6.5 4.6 14.4 17.3 12.1C428.2 457.8 496 362.9 496 252 496 113.3 383.5 8 244.8 8zM97.2 352.9c-1.3 1-1 3.3.7 5.2 1.6 1.6 3.9 2.3 5.2 1 1.3-1 1-3.3-.7-5.2-1.6-1.6-3.9-2.3-5.2-1zm-10.8-8.1c-.7 1.3.3 2.9 2.3 3.9 1.6 1 3.6.7 4.3-.7.7-1.3-.3-2.9-2.3-3.9-2-.6-3.6-.3-4.3.7zm32.4 35.6c-1.6 1.3-1 4.3 1.3 6.2 2.3 2.3 5.2 2.6 6.5 1 1.3-1.3.7-4.3-1.3-6.2-2.2-2.3-5.2-2.6-6.5-1zm-11.4-14.7c-1.6 1-1.6 3.6 0 5.9 1.6 2.3 4.3 3.3 5.6 2.3 1.6-1.3 1.6-3.9 0-6.2-1.4-2.3-4-3.3-5.6-2z"/></svg>
  </div>
  <div class="md-source__repository">
    zighelp/zighelp
  </div>
</a>
    </div>
  
  <ul class="md-nav__list" data-md-scrollfix>
    
      
      
  
  
  
    <li class="md-nav__item">
      <a href="../" class="md-nav__link">
        
  
  <span class="md-ellipsis">
    Глава 0 — Начало работы
  </span>
  

      </a>
    </li>
  

    
      
      
  
  
    
  
  
    <li class="md-nav__item md-nav__item--active">
      
      <input class="md-nav__toggle md-toggle" type="checkbox" id="__toc">
      
      
      
        <label class="md-nav__link md-nav__link--active" for="__toc">
          
  
  <span class="md-ellipsis">
    Глава 1 — Основы
  </span>
  

          <span class="md-nav__icon md-icon"></span>
        </label>
      
      <a href="./" class="md-nav__link md-nav__link--active">
        
  
  <span class="md-ellipsis">
    Глава 1 — Основы
  </span>
  

      </a>
      
        

  

<nav class="md-nav md-nav--secondary" aria-label=" ">
  
  
  
  
    <label class="md-nav__title" for="__toc">
      <span class="md-nav__icon md-icon"></span>
       
    </label>
    <ul class="md-nav__list" data-md-component="toc" data-md-scrollfix>
      
        <li class="md-nav__item">
  <a href="#_1" class="md-nav__link">
    Переменные
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#nt" class="md-nav__link">
    Массивы [N]T
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#if" class="md-nav__link">
    If
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#while" class="md-nav__link">
    While
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#for" class="md-nav__link">
    For
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#_2" class="md-nav__link">
    Функции
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#defer" class="md-nav__link">
    Defer
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#_3" class="md-nav__link">
    Ошибки
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#switch" class="md-nav__link">
    Switch
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#_4" class="md-nav__link">
    Безопасность во время выполнения
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#unreachable" class="md-nav__link">
    Unreachable
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#t" class="md-nav__link">
    Указатель на один элемент (*T)
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#usize-isize" class="md-nav__link">
    Целые числа размером с указатель: usize и isize
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#t_1" class="md-nav__link">
    Указатель на неизвестное количество элементов ([*]T)
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#t_2" class="md-nav__link">
    Срезы ([]T)
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#_5" class="md-nav__link">
    Перечисления
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#structs" class="md-nav__link">
    Structs
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#unions" class="md-nav__link">
    Unions
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#integer-rules" class="md-nav__link">
    Integer Rules
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#floats" class="md-nav__link">
    Floats
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#labelled-blocks-blk" class="md-nav__link">
    Labelled Blocks :blk {}
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#labelled-loops" class="md-nav__link">
    Labelled Loops
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#loops-as-expressions" class="md-nav__link">
    Loops as expressions
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#optionals-t" class="md-nav__link">
    Optionals ?T
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#comptime" class="md-nav__link">
    Comptime
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#payload-captures-n" class="md-nav__link">
    Payload Captures |n|
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#inline-loops" class="md-nav__link">
    Inline Loops
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#opaque" class="md-nav__link">
    Opaque
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#anonymous-structs" class="md-nav__link">
    Anonymous Structs .{}
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#sentinel-termination-ntt-tt-and-tt" class="md-nav__link">
    Sentinel Termination: [N:t]T, [:t]T, and [*:t]T
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#vectors" class="md-nav__link">
    Vectors
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#imports" class="md-nav__link">
    Imports
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#end-of-chapter-1" class="md-nav__link">
    End Of Chapter 1
  </a>
  
</li>
      
    </ul>
  
</nav>
      
    </li>
  

    
      
      
  
  
  
    <li class="md-nav__item">
      <a href="../chapter-2/" class="md-nav__link">
        
  
  <span class="md-ellipsis">
    Chapter 2 - Standard Patterns
  </span>
  

      </a>
    </li>
  

    
      
      
  
  
  
    <li class="md-nav__item">
      <a href="../chapter-3/" class="md-nav__link">
        
  
  <span class="md-ellipsis">
    Chapter 3 - Build system
  </span>
  

      </a>
    </li>
  

    
      
      
  
  
  
    <li class="md-nav__item">
      <a href="../chapter-4/" class="md-nav__link">
        
  
  <span class="md-ellipsis">
    Chapter 4 - Working with C
  </span>
  

      </a>
    </li>
  

    
      
      
  
  
  
    <li class="md-nav__item">
      <a href="../chapter-5/" class="md-nav__link">
        
  
  <span class="md-ellipsis">
    Chapter 5 - Async
  </span>
  

      </a>
    </li>
  

    
  </ul>
</nav>
                  </div>
                </div>
              </div>
            
            
          
          
            <div class="md-content" data-md-component="content">
              <article class="md-content__inner md-typeset">
                
                  

  
    <a href="https://github.com/zighelp/zighelp/edit/master/docs/ru/chapter-1.md" title="Редактировать страницу" class="md-content__button md-icon">
      
      <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><path d="M10 20H6V4h7v5h5v3.1l2-2V8l-6-6H6c-1.1 0-2 .9-2 2v16c0 1.1.9 2 2 2h4v-2m10.2-7c.1 0 .3.1.4.2l1.3 1.3c.2.2.2.6 0 .8l-1 1-2.1-2.1 1-1c.1-.1.2-.2.4-.2m0 3.9L14.1 23H12v-2.1l6.1-6.1 2.1 2.1Z"/></svg>
    </a>
  
  
    
      
    
    <a href="https://github.com/zighelp/zighelp/raw/master/docs/ru/chapter-1.md" title="Посмотреть исходный код страницы" class="md-content__button md-icon">
      
      <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><path d="M17 18c.56 0 1 .44 1 1s-.44 1-1 1-1-.44-1-1 .44-1 1-1m0-3c-2.73 0-5.06 1.66-6 4 .94 2.34 3.27 4 6 4s5.06-1.66 6-4c-.94-2.34-3.27-4-6-4m0 6.5a2.5 2.5 0 0 1-2.5-2.5 2.5 2.5 0 0 1 2.5-2.5 2.5 2.5 0 0 1 2.5 2.5 2.5 2.5 0 0 1-2.5 2.5M9.27 20H6V4h7v5h5v4.07c.7.08 1.36.25 2 .49V8l-6-6H6a2 2 0 0 0-2 2v16a2 2 0 0 0 2 2h4.5a8.15 8.15 0 0 1-1.23-2Z"/></svg>
    </a>
  


  <h1>Глава 1 — Основы</h1>

<h2 id="_1">Переменные<a class="headerlink" href="#_1" title="Permanent link">§</a></h2>
<p>Так мы присваиваем значение константе или переменной: <code>(const|var) название[: тип] = значение</code>.</p>
<ul>
<li>Модификатор <code>const</code> указывает, что <code>название</code> является <strong>константой</strong>, которая не меняет своё значение.</li>
<li>Модификатор <code>var</code> указывает, что <code>название</code> является <strong>переменной</strong>, которая может изменить своё значение.</li>
<li>Аннотация <code>: тип</code> указывает тип для <code>название</code>, он может быть пропущен, если можно автоматически вывести тип.</li>
</ul>
<!--no_test-->
<div class="highlight"><pre><span></span><code><span class="kr">const</span><span class="w"> </span><span class="n">constant</span><span class="o">:</span><span class="w"> </span><span class="kt">i32</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">5</span><span class="p">;</span><span class="w"> </span><span class="c1">// константа размером 32 бит, знаковое целое число (int 32)</span>
<span class="kr">var</span><span class="w"> </span><span class="n">variable</span><span class="o">:</span><span class="w"> </span><span class="kt">u32</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">5000</span><span class="p">;</span><span class="w"> </span><span class="c1">// переменная размером 32 бит, беззнаковое целое число (unsigned int 32)</span>

<span class="c1">// @as производит явное приведение типов</span>
<span class="kr">const</span><span class="w"> </span><span class="n">inferred_constant</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="nb">@as</span><span class="p">(</span><span class="kt">i32</span><span class="p">,</span><span class="w"> </span><span class="mi">5</span><span class="p">);</span>
<span class="kr">var</span><span class="w"> </span><span class="n">inferred_variable</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="nb">@as</span><span class="p">(</span><span class="kt">u32</span><span class="p">,</span><span class="w"> </span><span class="mi">5000</span><span class="p">);</span>
</code></pre></div>
<p>Константы и переменные <em>должны</em> иметь значение. Если значение ещё неизвестно, вы можете присвоить значение <a href="https://ziglang.org/documentation/master/#undefined"><code>undefined</code></a>, которое может приводиться к любому типу, при условии, что вы явно аннотировали тип.</p>
<!--no_test-->
<div class="highlight"><pre><span></span><code><span class="kr">const</span><span class="w"> </span><span class="n">a</span><span class="o">:</span><span class="w"> </span><span class="kt">i32</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="kc">undefined</span><span class="p">;</span>
<span class="kr">var</span><span class="w"> </span><span class="n">b</span><span class="o">:</span><span class="w"> </span><span class="kt">u32</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="kc">undefined</span><span class="p">;</span>
</code></pre></div>
<p>В большинстве случаев желательно использовать <code>const</code> вместо <code>var</code>.</p>
<h2 id="nt">Массивы [N]T<a class="headerlink" href="#nt" title="Permanent link">§</a></h2>
<p>Массивы обозначаются синтаксисом <code>[N]T</code>, где <code>N</code> — количество элементов в массиве, а <code>T</code> — тип этих элементов (т.е. дочерний тип массива).</p>
<p>В литералах массива (безымянных массивах), <code>N</code> можно заменить на <code>_</code>, тогда размер массива будет выведен автоматически.</p>
<!--no_test-->
<div class="highlight"><pre><span></span><code><span class="kr">const</span><span class="w"> </span><span class="n">a</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">[</span><span class="mi">5</span><span class="p">]</span><span class="kt">u8</span><span class="p">{</span><span class="w"> </span><span class="s">&#39;h&#39;</span><span class="p">,</span><span class="w"> </span><span class="s">&#39;e&#39;</span><span class="p">,</span><span class="w"> </span><span class="s">&#39;l&#39;</span><span class="p">,</span><span class="w"> </span><span class="s">&#39;l&#39;</span><span class="p">,</span><span class="w"> </span><span class="s">&#39;o&#39;</span><span class="w"> </span><span class="p">};</span>
<span class="kr">const</span><span class="w"> </span><span class="n">b</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">[</span><span class="n">_</span><span class="p">]</span><span class="kt">u8</span><span class="p">{</span><span class="w"> </span><span class="s">&#39;w&#39;</span><span class="p">,</span><span class="w"> </span><span class="s">&#39;o&#39;</span><span class="p">,</span><span class="w"> </span><span class="s">&#39;r&#39;</span><span class="p">,</span><span class="w"> </span><span class="s">&#39;l&#39;</span><span class="p">,</span><span class="w"> </span><span class="s">&#39;d&#39;</span><span class="w"> </span><span class="p">};</span>
</code></pre></div>
<p>Чтобы получить размер массива, обратитесь к полю массива <code>len</code>.</p>
<!--no_test-->
<div class="highlight"><pre><span></span><code><span class="kr">const</span><span class="w"> </span><span class="n">array</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">[</span><span class="n">_</span><span class="p">]</span><span class="kt">u8</span><span class="p">{</span><span class="w"> </span><span class="s">&#39;h&#39;</span><span class="p">,</span><span class="w"> </span><span class="s">&#39;e&#39;</span><span class="p">,</span><span class="w"> </span><span class="s">&#39;l&#39;</span><span class="p">,</span><span class="w"> </span><span class="s">&#39;l&#39;</span><span class="p">,</span><span class="w"> </span><span class="s">&#39;o&#39;</span><span class="w"> </span><span class="p">};</span>
<span class="kr">const</span><span class="w"> </span><span class="n">length</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">array</span><span class="p">.</span><span class="n">len</span><span class="p">;</span><span class="w"> </span><span class="c1">// 5</span>
</code></pre></div>
<h2 id="if">If<a class="headerlink" href="#if" title="Permanent link">§</a></h2>
<p>Обычная версия оператора <code>if</code> в Zig принимает только значения типа <code>bool</code> (т.е. <code>true</code> — истина или <code>false</code> — ложь). В этом случае не существует истинноподобных (truthy) или ложноподобных (falsy) значений.</p>
<p>Здесь мы начинаем использовать тесты. Сохраните код ниже, а затем соберите и запустите его командой <code>zig test название-файла.zig</code>. Здесь мы используем функцию <a href="https://ziglang.org/documentation/master/std/#A;std:testing.expect"><code>expect</code></a> из стандартной библиотеки, которая выдаст ошибку, если выражение ложно. Если тест завершается с ошибкой, появится трассировка ошибки и стека.</p>
<div class="highlight"><pre><span></span><code><span class="kr">const</span><span class="w"> </span><span class="n">expect</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="nb">@import</span><span class="p">(</span><span class="s">&quot;std&quot;</span><span class="p">).</span><span class="n">testing</span><span class="p">.</span><span class="n">expect</span><span class="p">;</span>

<span class="k">test</span><span class="w"> </span><span class="s">&quot;Условный оператор if&quot;</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="kr">const</span><span class="w"> </span><span class="n">a</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="kc">true</span><span class="p">;</span>
<span class="w">    </span><span class="kr">var</span><span class="w"> </span><span class="n">x</span><span class="o">:</span><span class="w"> </span><span class="kt">u16</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">0</span><span class="p">;</span>
<span class="w">    </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="n">a</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">        </span><span class="n">x</span><span class="w"> </span><span class="o">+=</span><span class="w"> </span><span class="mi">1</span><span class="p">;</span>
<span class="w">    </span><span class="p">}</span><span class="w"> </span><span class="k">else</span><span class="w"> </span><span class="p">{</span>
<span class="w">        </span><span class="n">x</span><span class="w"> </span><span class="o">+=</span><span class="w"> </span><span class="mi">2</span><span class="p">;</span>
<span class="w">    </span><span class="p">}</span>
<span class="w">    </span><span class="k">try</span><span class="w"> </span><span class="n">expect</span><span class="p">(</span><span class="n">x</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="mi">1</span><span class="p">);</span>
<span class="p">}</span>
</code></pre></div>
<p>Оператор if также можно использовать в выражениях.</p>
<div class="highlight"><pre><span></span><code><span class="k">test</span><span class="w"> </span><span class="s">&quot;Оператор if в выражении&quot;</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="kr">const</span><span class="w"> </span><span class="n">a</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="kc">true</span><span class="p">;</span>
<span class="w">    </span><span class="kr">var</span><span class="w"> </span><span class="n">x</span><span class="o">:</span><span class="w"> </span><span class="kt">u16</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">0</span><span class="p">;</span>
<span class="w">    </span><span class="n">x</span><span class="w"> </span><span class="o">+=</span><span class="w"> </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="n">a</span><span class="p">)</span><span class="w"> </span><span class="mi">1</span><span class="w"> </span><span class="k">else</span><span class="w"> </span><span class="mi">2</span><span class="p">;</span>
<span class="w">    </span><span class="k">try</span><span class="w"> </span><span class="n">expect</span><span class="p">(</span><span class="n">x</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="mi">1</span><span class="p">);</span>
<span class="p">}</span>
</code></pre></div>
<h2 id="while">While<a class="headerlink" href="#while" title="Permanent link">§</a></h2>
<p>Цикл <code>while</code> может содержать три части — условие, выполняемый код (в блоке) и выражение, которое исполняется после каждой итерации (continue expression).</p>
<p>Пример без «continue expression».
<div class="highlight"><pre><span></span><code><span class="k">test</span><span class="w"> </span><span class="s">&quot;Цикл while&quot;</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="kr">var</span><span class="w"> </span><span class="n">i</span><span class="o">:</span><span class="w"> </span><span class="kt">u8</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">2</span><span class="p">;</span>
<span class="w">    </span><span class="k">while</span><span class="w"> </span><span class="p">(</span><span class="n">i</span><span class="w"> </span><span class="o">&lt;</span><span class="w"> </span><span class="mi">100</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">        </span><span class="n">i</span><span class="w"> </span><span class="o">*=</span><span class="w"> </span><span class="mi">2</span><span class="p">;</span>
<span class="w">    </span><span class="p">}</span>
<span class="w">    </span><span class="k">try</span><span class="w"> </span><span class="n">expect</span><span class="p">(</span><span class="n">i</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="mi">128</span><span class="p">);</span>
<span class="p">}</span>
</code></pre></div></p>
<p>Пример с «continue expression».
<div class="highlight"><pre><span></span><code><span class="k">test</span><span class="w"> </span><span class="s">&quot;Цикл while с выражением, исполняемым после каждой итерации&quot;</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="kr">var</span><span class="w"> </span><span class="n">sum</span><span class="o">:</span><span class="w"> </span><span class="kt">u8</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">0</span><span class="p">;</span>
<span class="w">    </span><span class="kr">var</span><span class="w"> </span><span class="n">i</span><span class="o">:</span><span class="w"> </span><span class="kt">u8</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">1</span><span class="p">;</span>
<span class="w">    </span><span class="k">while</span><span class="w"> </span><span class="p">(</span><span class="n">i</span><span class="w"> </span><span class="o">&lt;=</span><span class="w"> </span><span class="mi">10</span><span class="p">)</span><span class="w"> </span><span class="o">:</span><span class="w"> </span><span class="p">(</span><span class="n">i</span><span class="w"> </span><span class="o">+=</span><span class="w"> </span><span class="mi">1</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">        </span><span class="n">sum</span><span class="w"> </span><span class="o">+=</span><span class="w"> </span><span class="n">i</span><span class="p">;</span>
<span class="w">    </span><span class="p">}</span>
<span class="w">    </span><span class="k">try</span><span class="w"> </span><span class="n">expect</span><span class="p">(</span><span class="n">sum</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="mi">55</span><span class="p">);</span>
<span class="p">}</span>
</code></pre></div></p>
<p>С оператором пропуска итерации <code>continue</code>.</p>
<div class="highlight"><pre><span></span><code><span class="k">test</span><span class="w"> </span><span class="s">&quot;Цикл while с пропуском итерации&quot;</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="kr">var</span><span class="w"> </span><span class="n">sum</span><span class="o">:</span><span class="w"> </span><span class="kt">u8</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">0</span><span class="p">;</span>
<span class="w">    </span><span class="kr">var</span><span class="w"> </span><span class="n">i</span><span class="o">:</span><span class="w"> </span><span class="kt">u8</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">0</span><span class="p">;</span>
<span class="w">    </span><span class="k">while</span><span class="w"> </span><span class="p">(</span><span class="n">i</span><span class="w"> </span><span class="o">&lt;=</span><span class="w"> </span><span class="mi">3</span><span class="p">)</span><span class="w"> </span><span class="o">:</span><span class="w"> </span><span class="p">(</span><span class="n">i</span><span class="w"> </span><span class="o">+=</span><span class="w"> </span><span class="mi">1</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">        </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="n">i</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="mi">2</span><span class="p">)</span><span class="w"> </span><span class="k">continue</span><span class="p">;</span>
<span class="w">        </span><span class="n">sum</span><span class="w"> </span><span class="o">+=</span><span class="w"> </span><span class="n">i</span><span class="p">;</span>
<span class="w">    </span><span class="p">}</span>
<span class="w">    </span><span class="k">try</span><span class="w"> </span><span class="n">expect</span><span class="p">(</span><span class="n">sum</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="mi">4</span><span class="p">);</span>
<span class="p">}</span>
</code></pre></div>
<p>С оператором досрочного выхода из цикла <code>break</code>.</p>
<div class="highlight"><pre><span></span><code><span class="k">test</span><span class="w"> </span><span class="s">&quot;Цикл while с досрочным выходом&quot;</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="kr">var</span><span class="w"> </span><span class="n">sum</span><span class="o">:</span><span class="w"> </span><span class="kt">u8</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">0</span><span class="p">;</span>
<span class="w">    </span><span class="kr">var</span><span class="w"> </span><span class="n">i</span><span class="o">:</span><span class="w"> </span><span class="kt">u8</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">0</span><span class="p">;</span>
<span class="w">    </span><span class="k">while</span><span class="w"> </span><span class="p">(</span><span class="n">i</span><span class="w"> </span><span class="o">&lt;=</span><span class="w"> </span><span class="mi">3</span><span class="p">)</span><span class="w"> </span><span class="o">:</span><span class="w"> </span><span class="p">(</span><span class="n">i</span><span class="w"> </span><span class="o">+=</span><span class="w"> </span><span class="mi">1</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">        </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="n">i</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="mi">2</span><span class="p">)</span><span class="w"> </span><span class="k">break</span><span class="p">;</span>
<span class="w">        </span><span class="n">sum</span><span class="w"> </span><span class="o">+=</span><span class="w"> </span><span class="n">i</span><span class="p">;</span>
<span class="w">    </span><span class="p">}</span>
<span class="w">    </span><span class="k">try</span><span class="w"> </span><span class="n">expect</span><span class="p">(</span><span class="n">sum</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="mi">1</span><span class="p">);</span>
<span class="p">}</span>
</code></pre></div>
<h2 id="for">For<a class="headerlink" href="#for" title="Permanent link">§</a></h2>
<p>Цикл <code>for</code> используется для прохода по массивам (и другим типам, о них расскажем позже). Цикл <code>for</code> следует нижеуказанному синтаксису. Как и в цикле <code>while</code>, в цикле <code>for</code> иогут использоваться операторы <code>break</code> и <code>continue</code>. Мы присваиваем значения к <code>_</code>, т.к. Zig не разрешает <strong>молча</strong> игнорировать значения (подробнее в подразделе Функции).</p>
<div class="highlight"><pre><span></span><code><span class="k">test</span><span class="w"> </span><span class="s">&quot;Цикл for&quot;</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="c1">// Указанные ниже литералы символов эквивалентны литералам своих значений в виде чисел</span>
<span class="w">    </span><span class="kr">const</span><span class="w"> </span><span class="n">string</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">[</span><span class="n">_</span><span class="p">]</span><span class="kt">u8</span><span class="p">{</span><span class="w"> </span><span class="s">&#39;a&#39;</span><span class="p">,</span><span class="w"> </span><span class="s">&#39;b&#39;</span><span class="p">,</span><span class="w"> </span><span class="s">&#39;c&#39;</span><span class="w"> </span><span class="p">};</span>

<span class="w">    </span><span class="k">for</span><span class="w"> </span><span class="p">(</span><span class="n">string</span><span class="p">,</span><span class="w"> </span><span class="mi">0</span><span class="p">..)</span><span class="w"> </span><span class="o">|</span><span class="n">character</span><span class="p">,</span><span class="w"> </span><span class="n">index</span><span class="o">|</span><span class="w"> </span><span class="p">{</span>
<span class="w">        </span><span class="n">_</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">character</span><span class="p">;</span><span class="w"> </span><span class="c1">// текущий элемент массива</span>
<span class="w">        </span><span class="n">_</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">index</span><span class="p">;</span><span class="w"> </span><span class="c1">// текущий индекс</span>
<span class="w">    </span><span class="p">}</span>

<span class="w">    </span><span class="k">for</span><span class="w"> </span><span class="p">(</span><span class="n">string</span><span class="p">)</span><span class="w"> </span><span class="o">|</span><span class="n">character</span><span class="o">|</span><span class="w"> </span><span class="p">{</span>
<span class="w">        </span><span class="n">_</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">character</span><span class="p">;</span>
<span class="w">    </span><span class="p">}</span>

<span class="w">    </span><span class="k">for</span><span class="w"> </span><span class="p">(</span><span class="n">string</span><span class="p">,</span><span class="w"> </span><span class="mi">0</span><span class="p">..)</span><span class="w"> </span><span class="o">|</span><span class="n">_</span><span class="p">,</span><span class="w"> </span><span class="n">index</span><span class="o">|</span><span class="w"> </span><span class="p">{</span>
<span class="w">        </span><span class="n">_</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">index</span><span class="p">;</span>
<span class="w">    </span><span class="p">}</span>

<span class="w">    </span><span class="k">for</span><span class="w"> </span><span class="p">(</span><span class="n">string</span><span class="p">)</span><span class="w"> </span><span class="o">|</span><span class="n">_</span><span class="o">|</span><span class="w"> </span><span class="p">{}</span>
<span class="p">}</span>
</code></pre></div>
<h2 id="_2">Функции<a class="headerlink" href="#_2" title="Permanent link">§</a></h2>
<p><strong>Все аргументы функции являются неизменяемыми</strong> — если вам нужна копия, необходимо явно создать её. Переменные принято оформлять в змеином_регистре (snake_case), а функции в нижнеВерблюжемРегистре (lowerCamelCase). Ниже мы объявляем и вызываем простую фукнцию.</p>
<div class="highlight"><pre><span></span><code><span class="k">fn</span><span class="w"> </span><span class="n">addFive</span><span class="p">(</span><span class="n">x</span><span class="o">:</span><span class="w"> </span><span class="kt">u32</span><span class="p">)</span><span class="w"> </span><span class="kt">u32</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="k">return</span><span class="w"> </span><span class="n">x</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="mi">5</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">test</span><span class="w"> </span><span class="s">&quot;Вызов функции addFive&quot;</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="kr">const</span><span class="w"> </span><span class="n">y</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">addFive</span><span class="p">(</span><span class="mi">0</span><span class="p">);</span>
<span class="w">    </span><span class="k">try</span><span class="w"> </span><span class="n">expect</span><span class="p">(</span><span class="nb">@TypeOf</span><span class="p">(</span><span class="n">y</span><span class="p">)</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="kt">u32</span><span class="p">);</span>
<span class="w">    </span><span class="k">try</span><span class="w"> </span><span class="n">expect</span><span class="p">(</span><span class="n">y</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="mi">5</span><span class="p">);</span>
<span class="p">}</span>
</code></pre></div>
<p>Вы также можете использовать рекурсию (вызывать функцию внутри себя):</p>
<div class="highlight"><pre><span></span><code><span class="k">fn</span><span class="w"> </span><span class="n">fibonacci</span><span class="p">(</span><span class="n">n</span><span class="o">:</span><span class="w"> </span><span class="kt">u16</span><span class="p">)</span><span class="w"> </span><span class="kt">u16</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="n">n</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="mi">0</span><span class="w"> </span><span class="k">or</span><span class="w"> </span><span class="n">n</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="mi">1</span><span class="p">)</span><span class="w"> </span><span class="k">return</span><span class="w"> </span><span class="n">n</span><span class="p">;</span>
<span class="w">    </span><span class="k">return</span><span class="w"> </span><span class="n">fibonacci</span><span class="p">(</span><span class="n">n</span><span class="w"> </span><span class="o">-</span><span class="w"> </span><span class="mi">1</span><span class="p">)</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="n">fibonacci</span><span class="p">(</span><span class="n">n</span><span class="w"> </span><span class="o">-</span><span class="w"> </span><span class="mi">2</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">test</span><span class="w"> </span><span class="s">&quot;Вызов рекурсивной функции fibonacci&quot;</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="kr">const</span><span class="w"> </span><span class="n">x</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">fibonacci</span><span class="p">(</span><span class="mi">10</span><span class="p">);</span>
<span class="w">    </span><span class="k">try</span><span class="w"> </span><span class="n">expect</span><span class="p">(</span><span class="n">x</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="mi">55</span><span class="p">);</span>
<span class="p">}</span>
</code></pre></div>
<p>Когда случается рекурсия, компилятор уже не может предварительно рассчитать максимальный размер стека. Это может привести к небезопасному поведению — стек может переполниться. О том, как добиться безопасной рекурсии, будет написано в будущем.</p>
<p>Значения можно игнорировать, используя <code>_</code> вместо объявления переменной или константы. Это не работает и не нужно в глобальной области видимости (т.е. работает только внутри функций и блоков) и полезно для игнорирования значений, если они вам не нужны.</p>
<!--no_test-->
<div class="highlight"><pre><span></span><code><span class="n">_</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">10</span><span class="p">;</span>
</code></pre></div>
<h2 id="defer">Defer<a class="headerlink" href="#defer" title="Permanent link">§</a></h2>
<p>Оператор defer используется для выполнения выражения во время выхода из текущей области видимости.</p>
<div class="highlight"><pre><span></span><code><span class="k">test</span><span class="w"> </span><span class="s">&quot;Оператор defer&quot;</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="kr">var</span><span class="w"> </span><span class="n">x</span><span class="o">:</span><span class="w"> </span><span class="kt">i16</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">5</span><span class="p">;</span>
<span class="w">    </span><span class="p">{</span>
<span class="w">        </span><span class="k">defer</span><span class="w"> </span><span class="n">x</span><span class="w"> </span><span class="o">+=</span><span class="w"> </span><span class="mi">2</span><span class="p">;</span>
<span class="w">        </span><span class="k">try</span><span class="w"> </span><span class="n">expect</span><span class="p">(</span><span class="n">x</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="mi">5</span><span class="p">);</span>
<span class="w">    </span><span class="p">}</span>
<span class="w">    </span><span class="k">try</span><span class="w"> </span><span class="n">expect</span><span class="p">(</span><span class="n">x</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="mi">7</span><span class="p">);</span>
<span class="p">}</span>
</code></pre></div>
<p>Если в одном блоке находятся несколько операторов defer, они выполняются в обратном порядке (снизу вверх).</p>
<div class="highlight"><pre><span></span><code><span class="k">test</span><span class="w"> </span><span class="s">&quot;Множество операторов defer&quot;</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="kr">var</span><span class="w"> </span><span class="n">x</span><span class="o">:</span><span class="w"> </span><span class="kt">f32</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">5</span><span class="p">;</span>
<span class="w">    </span><span class="p">{</span>
<span class="w">        </span><span class="k">defer</span><span class="w"> </span><span class="n">x</span><span class="w"> </span><span class="o">+=</span><span class="w"> </span><span class="mi">2</span><span class="p">;</span>
<span class="w">        </span><span class="k">defer</span><span class="w"> </span><span class="n">x</span><span class="w"> </span><span class="o">/=</span><span class="w"> </span><span class="mi">2</span><span class="p">;</span>
<span class="w">    </span><span class="p">}</span>
<span class="w">    </span><span class="k">try</span><span class="w"> </span><span class="n">expect</span><span class="p">(</span><span class="n">x</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="mf">4.5</span><span class="p">);</span>
<span class="p">}</span>
</code></pre></div>
<h2 id="_3">Ошибки<a class="headerlink" href="#_3" title="Permanent link">§</a></h2>
<p>Множество ошибок (error set) похоже на перечисления (подробнее о перечислениях в Zig позже), но в качестве элементов используются коды ошибок. В Zig не существует исключений — ошибки обрабатываются как обычные значения. Давайте создадим множество ошибок.</p>
<div class="highlight"><pre><span></span><code><span class="kr">const</span><span class="w"> </span><span class="n">FileOpenError</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="k">error</span><span class="p">{</span>
<span class="w">    </span><span class="n">AccessDenied</span><span class="p">,</span>
<span class="w">    </span><span class="n">OutOfMemory</span><span class="p">,</span>
<span class="w">    </span><span class="n">FileNotFound</span><span class="p">,</span>
<span class="p">};</span>
</code></pre></div>
<p>Множество ошибок можно привести к его надмножеству.</p>
<div class="highlight"><pre><span></span><code><span class="kr">const</span><span class="w"> </span><span class="n">AllocationError</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="k">error</span><span class="p">{</span><span class="n">OutOfMemory</span><span class="p">};</span>

<span class="k">test</span><span class="w"> </span><span class="s">&quot;Приведение ошибки из подмножества к надмножеству&quot;</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="kr">const</span><span class="w"> </span><span class="n">err</span><span class="o">:</span><span class="w"> </span><span class="n">FileOpenError</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">AllocationError</span><span class="p">.</span><span class="n">OutOfMemory</span><span class="p">;</span>
<span class="w">    </span><span class="k">try</span><span class="w"> </span><span class="n">expect</span><span class="p">(</span><span class="n">err</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="n">FileOpenError</span><span class="p">.</span><span class="n">OutOfMemory</span><span class="p">);</span>
<span class="p">}</span>
</code></pre></div>
<p>Тип «множество ошибок» и тип обычных значений можно соединить с помощью оператора <code>!</code> для формирования типа «объединение с ошибкой» (error union type). Этот тип содержит или ошибку, или обычное значение.</p>
<p>Давайте создадим значение с этим типом. Здесь используется оператор <a href="https://ziglang.org/documentation/master/#catch"><code>catch</code></a>, за которым должно следовать выражение, которое выполняется, если значение является ошибкой. Здесь мы используем этот оператор для выставления резервного значения на случай ошибки, но вместо него может идти тип <a href="https://ziglang.org/documentation/master/#noreturn"><code>noreturn</code></a> — тип выражений <code>return</code>, <code>while (true)</code> и т.д, означающий, что здесь находится точка невозврата.</p>
<div class="highlight"><pre><span></span><code><span class="k">test</span><span class="w"> </span><span class="s">&quot;Объединение с ошибкой&quot;</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="kr">const</span><span class="w"> </span><span class="n">maybe_error</span><span class="o">:</span><span class="w"> </span><span class="n">AllocationError</span><span class="o">!</span><span class="kt">u16</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">10</span><span class="p">;</span>
<span class="w">    </span><span class="kr">const</span><span class="w"> </span><span class="n">no_error</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">maybe_error</span><span class="w"> </span><span class="k">catch</span><span class="w"> </span><span class="mi">0</span><span class="p">;</span>

<span class="w">    </span><span class="k">try</span><span class="w"> </span><span class="n">expect</span><span class="p">(</span><span class="nb">@TypeOf</span><span class="p">(</span><span class="n">no_error</span><span class="p">)</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="kt">u16</span><span class="p">);</span>
<span class="w">    </span><span class="k">try</span><span class="w"> </span><span class="n">expect</span><span class="p">(</span><span class="n">no_error</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="mi">10</span><span class="p">);</span>
<span class="p">}</span>
</code></pre></div>
<p>Функции часто возвращают объединение с ошибкой. Вот пример использования оператора catch, где в <code>|err|</code> передаётся код ошибки. Этот синтаксис называется <strong>захватом значения</strong> (payload capturing) и используется аналогичным образом во многих местах. Далее в главе мы поговорим об этом подробнее. Примечание: некоторые языки используют подобный синтаксис для лямбда-выражений — это не относится к Zig.</p>
<div class="highlight"><pre><span></span><code><span class="k">fn</span><span class="w"> </span><span class="n">failingFunction</span><span class="p">()</span><span class="w"> </span><span class="k">error</span><span class="p">{</span><span class="n">Oops</span><span class="p">}</span><span class="o">!</span><span class="kt">void</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="k">return</span><span class="w"> </span><span class="k">error</span><span class="p">.</span><span class="n">Oops</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">test</span><span class="w"> </span><span class="s">&quot;Возврат ошибки и её захват с помощью catch&quot;</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="n">failingFunction</span><span class="p">()</span><span class="w"> </span><span class="k">catch</span><span class="w"> </span><span class="o">|</span><span class="n">err</span><span class="o">|</span><span class="w"> </span><span class="p">{</span>
<span class="w">        </span><span class="k">try</span><span class="w"> </span><span class="n">expect</span><span class="p">(</span><span class="n">err</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="k">error</span><span class="p">.</span><span class="n">Oops</span><span class="p">);</span>
<span class="w">        </span><span class="k">return</span><span class="p">;</span>
<span class="w">    </span><span class="p">};</span>
<span class="p">}</span>
</code></pre></div>
<p><code>try x</code> является краткой записью выражения <code>x catch |err| return err</code> и обычно используется в местах, где обработка ошибки неуместна. Операторы <a href="https://ziglang.org/documentation/master/#try"><code>try</code></a> и <a href="https://ziglang.org/documentation/master/#catch"><code>catch</code></a> в Zig не связаны с конструкцией try-catch в других языках.</p>
<div class="highlight"><pre><span></span><code><span class="k">fn</span><span class="w"> </span><span class="n">failFn</span><span class="p">()</span><span class="w"> </span><span class="k">error</span><span class="p">{</span><span class="n">Oops</span><span class="p">}</span><span class="o">!</span><span class="kt">i32</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="k">try</span><span class="w"> </span><span class="n">failingFunction</span><span class="p">();</span>
<span class="w">    </span><span class="k">return</span><span class="w"> </span><span class="mi">12</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">test</span><span class="w"> </span><span class="s">&quot;Оператор try&quot;</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="kr">var</span><span class="w"> </span><span class="n">v</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">failFn</span><span class="p">()</span><span class="w"> </span><span class="k">catch</span><span class="w"> </span><span class="o">|</span><span class="n">err</span><span class="o">|</span><span class="w"> </span><span class="p">{</span>
<span class="w">        </span><span class="k">try</span><span class="w"> </span><span class="n">expect</span><span class="p">(</span><span class="n">err</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="k">error</span><span class="p">.</span><span class="n">Oops</span><span class="p">);</span>
<span class="w">        </span><span class="k">return</span><span class="p">;</span>
<span class="w">    </span><span class="p">};</span>
<span class="w">    </span><span class="k">try</span><span class="w"> </span><span class="n">expect</span><span class="p">(</span><span class="n">v</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="mi">12</span><span class="p">);</span><span class="w"> </span><span class="c1">// тест не доходит до этой строки</span>
<span class="p">}</span>
</code></pre></div>
<p>Оператор <a href="https://ziglang.org/documentation/master/#errdefer"><code>errdefer</code></a> схож с <a href="https://ziglang.org/documentation/master/#defer"><code>defer</code></a>, но выполняет выражение только в том случае, если в блоке функции с <a href="https://ziglang.org/documentation/master/#errdefer"><code>errdefer</code></a> была возвращена ошибка.</p>
<div class="highlight"><pre><span></span><code><span class="kr">var</span><span class="w"> </span><span class="n">problems</span><span class="o">:</span><span class="w"> </span><span class="kt">u32</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">98</span><span class="p">;</span>

<span class="k">fn</span><span class="w"> </span><span class="n">failFnCounter</span><span class="p">()</span><span class="w"> </span><span class="k">error</span><span class="p">{</span><span class="n">Oops</span><span class="p">}</span><span class="o">!</span><span class="kt">void</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="k">errdefer</span><span class="w"> </span><span class="n">problems</span><span class="w"> </span><span class="o">+=</span><span class="w"> </span><span class="mi">1</span><span class="p">;</span>
<span class="w">    </span><span class="k">try</span><span class="w"> </span><span class="n">failingFunction</span><span class="p">();</span>
<span class="p">}</span>

<span class="k">test</span><span class="w"> </span><span class="s">&quot;Оператор errdefer&quot;</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="n">failFnCounter</span><span class="p">()</span><span class="w"> </span><span class="k">catch</span><span class="w"> </span><span class="o">|</span><span class="n">err</span><span class="o">|</span><span class="w"> </span><span class="p">{</span>
<span class="w">        </span><span class="k">try</span><span class="w"> </span><span class="n">expect</span><span class="p">(</span><span class="n">err</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="k">error</span><span class="p">.</span><span class="n">Oops</span><span class="p">);</span>
<span class="w">        </span><span class="k">try</span><span class="w"> </span><span class="n">expect</span><span class="p">(</span><span class="n">problems</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="mi">99</span><span class="p">);</span>
<span class="w">        </span><span class="k">return</span><span class="p">;</span>
<span class="w">    </span><span class="p">};</span>
<span class="p">}</span>
</code></pre></div>
<p>Если функция возвращает объединение с ошибкой и множество ошибок не указано явно, оно будет выведено. Это выведенное множество содержит все возможные ошибки, которые может вернуть эта функция.</p>
<div class="highlight"><pre><span></span><code><span class="k">fn</span><span class="w"> </span><span class="n">createFile</span><span class="p">()</span><span class="w"> </span><span class="o">!</span><span class="kt">void</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="k">return</span><span class="w"> </span><span class="k">error</span><span class="p">.</span><span class="n">AccessDenied</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">test</span><span class="w"> </span><span class="s">&quot;Выведенное множество ошибок&quot;</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="c1">// Здесь происходит приведение типа</span>
<span class="w">    </span><span class="kr">const</span><span class="w"> </span><span class="n">x</span><span class="o">:</span><span class="w"> </span><span class="k">error</span><span class="p">{</span><span class="n">AccessDenied</span><span class="p">}</span><span class="o">!</span><span class="kt">void</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">createFile</span><span class="p">();</span>

<span class="w">    </span><span class="c1">// Zig не позволяет нам игнорировать объединение с ошибкой</span>
<span class="w">    </span><span class="c1">// синтаксисом _ = x;</span>
<span class="w">    </span><span class="c1">// Мы обязаны «распаковать» (unwrap) возможную ошибку с помощью `try`, `catch` или версией `if` для ошибок</span>
<span class="w">    </span><span class="n">_</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">x</span><span class="w"> </span><span class="k">catch</span><span class="w"> </span><span class="p">{};</span>
<span class="p">}</span>
</code></pre></div>
<p>Множества ошибок можно объединять вместе.</p>
<div class="highlight"><pre><span></span><code><span class="kr">const</span><span class="w"> </span><span class="n">A</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="k">error</span><span class="p">{</span><span class="w"> </span><span class="n">NotDir</span><span class="p">,</span><span class="w"> </span><span class="n">PathNotFound</span><span class="w"> </span><span class="p">};</span>
<span class="kr">const</span><span class="w"> </span><span class="n">B</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="k">error</span><span class="p">{</span><span class="w"> </span><span class="n">OutOfMemory</span><span class="p">,</span><span class="w"> </span><span class="n">PathNotFound</span><span class="w"> </span><span class="p">};</span>
<span class="kr">const</span><span class="w"> </span><span class="n">C</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">A</span><span class="w"> </span><span class="o">||</span><span class="w"> </span><span class="n">B</span><span class="p">;</span>
</code></pre></div>
<p><code>anyerror</code> — это глобальное множество ошибок. Оно является надмножеством для всех множеств ошибок и содержит все возможные коды ошибок. В большинстве случаев его следует избегать.</p>
<h2 id="switch">Switch<a class="headerlink" href="#switch" title="Permanent link">§</a></h2>
<p>Конструкция <code>switch</code> в Zig работает как оператор, так выражение. Результат во всех ветвях должен приводиться к типу результата. Все возможные значения должны быть явно сопоставлены с какой-то ветвью. Из одних ветвей нельзя попасть в другие.</p>
<p>Ниже показан пример использования <code>switch</code> в качестве оператора. Ветвь <code>else</code> используется для всех оставшихся (не покрытых) случаев <code>x</code>.</p>
<div class="highlight"><pre><span></span><code><span class="k">test</span><span class="w"> </span><span class="s">&quot;Оператор многозначного выбора switch&quot;</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="kr">var</span><span class="w"> </span><span class="n">x</span><span class="o">:</span><span class="w"> </span><span class="n">i8</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">10</span><span class="p">;</span>
<span class="w">    </span><span class="k">switch</span><span class="w"> </span><span class="p">(</span><span class="n">x</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">        </span><span class="o">-</span><span class="mi">1</span><span class="p">...</span><span class="mi">1</span><span class="w"> </span><span class="o">=&gt;</span><span class="w"> </span><span class="p">{</span>
<span class="w">            </span><span class="n">x</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="o">-</span><span class="n">x</span><span class="p">;</span>
<span class="w">        </span><span class="p">},</span>
<span class="w">        </span><span class="mi">10</span><span class="p">,</span><span class="w"> </span><span class="mi">100</span><span class="w"> </span><span class="o">=&gt;</span><span class="w"> </span><span class="p">{</span>
<span class="w">            </span><span class="c1">// Следует уделять особое внимание</span>
<span class="w">            </span><span class="c1">// при делении знаковых чисел</span>
<span class="w">            </span><span class="n">x</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="nb">@divExact</span><span class="p">(</span><span class="n">x</span><span class="p">,</span><span class="w"> </span><span class="mi">10</span><span class="p">);</span>
<span class="w">        </span><span class="p">},</span>
<span class="w">        </span><span class="k">else</span><span class="w"> </span><span class="o">=&gt;</span><span class="w"> </span><span class="p">{},</span>
<span class="w">    </span><span class="p">}</span>
<span class="w">    </span><span class="k">try</span><span class="w"> </span><span class="n">expect</span><span class="p">(</span><span class="n">x</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="mi">1</span><span class="p">);</span>
<span class="p">}</span>
</code></pre></div>
<p>Тот же пример, но с <code>switch</code> в качестве выражения.</p>
<div class="highlight"><pre><span></span><code><span class="k">test</span><span class="w"> </span><span class="s">&quot;Выражение с switch&quot;</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="kr">var</span><span class="w"> </span><span class="n">x</span><span class="o">:</span><span class="w"> </span><span class="n">i8</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">10</span><span class="p">;</span>
<span class="w">    </span><span class="n">x</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="k">switch</span><span class="w"> </span><span class="p">(</span><span class="n">x</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">        </span><span class="o">-</span><span class="mi">1</span><span class="p">...</span><span class="mi">1</span><span class="w"> </span><span class="o">=&gt;</span><span class="w"> </span><span class="o">-</span><span class="n">x</span><span class="p">,</span>
<span class="w">        </span><span class="mi">10</span><span class="p">,</span><span class="w"> </span><span class="mi">100</span><span class="w"> </span><span class="o">=&gt;</span><span class="w"> </span><span class="nb">@divExact</span><span class="p">(</span><span class="n">x</span><span class="p">,</span><span class="w"> </span><span class="mi">10</span><span class="p">),</span>
<span class="w">        </span><span class="k">else</span><span class="w"> </span><span class="o">=&gt;</span><span class="w"> </span><span class="n">x</span><span class="p">,</span>
<span class="w">    </span><span class="p">};</span>
<span class="w">    </span><span class="k">try</span><span class="w"> </span><span class="n">expect</span><span class="p">(</span><span class="n">x</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="mi">1</span><span class="p">);</span>
<span class="p">}</span>
</code></pre></div>
<h2 id="_4">Безопасность во время выполнения<a class="headerlink" href="#_4" title="Permanent link">§</a></h2>
<p>Zig предоставляет уровень безопасности «во время выполнения» (runtime safety), при котором проблемы могут быть найдены во время выполнения. Эти проверки можно включить или отключить. В Zig существует концепция <strong>обнаруживаемого недопустимого поведения</strong> (detectable illegal behaviour) — такое поведение при включенных проверках будет обнаружено (вызывая панику), а при отключенных становится неопределенным поведением (undefined behaviour). Пользователям строго рекомендуется разрабатывать и тестировать разрабатываемое ПО с включенными проверками, несмотря на ухудшение производительности.</p>
<p>Одним из примеров обнаруживаемого недопустимого поведения является «выход за диапазон допустимых индексов».</p>
<!--fail_test-->
<p><div class="highlight"><pre><span></span><code><span class="k">test</span><span class="w"> </span><span class="s">&quot;Выход за границы массива во время выполнения&quot;</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="kr">const</span><span class="w"> </span><span class="n">a</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">[</span><span class="mi">3</span><span class="p">]</span><span class="kt">u8</span><span class="p">{</span><span class="w"> </span><span class="mi">1</span><span class="p">,</span><span class="w"> </span><span class="mi">2</span><span class="p">,</span><span class="w"> </span><span class="mi">3</span><span class="w"> </span><span class="p">};</span>
<span class="w">    </span><span class="kr">var</span><span class="w"> </span><span class="n">index</span><span class="o">:</span><span class="w"> </span><span class="kt">u8</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">5</span><span class="p">;</span>
<span class="w">    </span><span class="kr">const</span><span class="w"> </span><span class="n">b</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">a</span><span class="p">[</span><span class="n">index</span><span class="p">];</span>
<span class="w">    </span><span class="n">_</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">b</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></div>
<div class="highlight"><pre><span></span><code>Test [1/1] test.Выход за границы массива во время выполнени... thread 8964 panic: index out of bounds: index 5, len 3
./tests.zig:4:16: 0x2246e1 in test.Выход за границы массива во время выполнения (test)
    const b = a[index];
               ^
</code></pre></div></p>
<p>По умолчанию проверки включены для режимов сборки <code>Debug</code> и <code>ReleaseSafe</code> и отключены для <code>ReleaseFast</code> и <code>ReleaseSmall</code> (подробнее о режимах сборки в следующих главах).
Пользователь может принудительно (для любого режима сборки) включить или отключить эти проверки, используя в нужном блоке встроенную функцию <a href="https://ziglang.org/documentation/master/#setRuntimeSafety"><code>@setRuntimeSafety</code></a>.</p>
<div class="highlight"><pre><span></span><code><span class="k">test</span><span class="w"> </span><span class="s">&quot;Выход за пределы массива во время выполнения, без проверки&quot;</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="nb">@setRuntimeSafety</span><span class="p">(</span><span class="kc">false</span><span class="p">);</span>
<span class="w">    </span><span class="kr">const</span><span class="w"> </span><span class="n">a</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">[</span><span class="mi">3</span><span class="p">]</span><span class="kt">u8</span><span class="p">{</span><span class="w"> </span><span class="mi">1</span><span class="p">,</span><span class="w"> </span><span class="mi">2</span><span class="p">,</span><span class="w"> </span><span class="mi">3</span><span class="w"> </span><span class="p">};</span>
<span class="w">    </span><span class="kr">var</span><span class="w"> </span><span class="n">index</span><span class="o">:</span><span class="w"> </span><span class="kt">u8</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">5</span><span class="p">;</span>
<span class="w">    </span><span class="kr">const</span><span class="w"> </span><span class="n">b</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">a</span><span class="p">[</span><span class="n">index</span><span class="p">];</span>
<span class="w">    </span><span class="n">_</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">b</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></div>
<h2 id="unreachable">Unreachable<a class="headerlink" href="#unreachable" title="Permanent link">§</a></h2>
<p>Оператор <a href="https://ziglang.org/documentation/master/#unreachable"><code>unreachable</code></a> утверждает, что эта инструкция недостижима. С помощью него вы обещаете компилятору, что данная ветвь никогда не выполнится, благодаря чему он может производить более умные оптимизации. Достижение <a href="https://ziglang.org/documentation/master/#unreachable"><code>unreachable</code></a> считается нарушением обещания/контракта и обнаруживаемым недопустимым поведением.</p>
<p>Так как этот оператор имеет тип <a href="https://ziglang.org/documentation/master/#noreturn"><code>noreturn</code></a> (точки невозврата), он совместим со всеми другими типами. Здесь он совместим с типом u32 и приводится к нему.</p>
<!--fail_test-->
<p><div class="highlight"><pre><span></span><code><span class="k">test</span><span class="w"> </span><span class="s">&quot;Достижение unreachable&quot;</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="kr">const</span><span class="w"> </span><span class="n">x</span><span class="o">:</span><span class="w"> </span><span class="kt">i32</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">1</span><span class="p">;</span>
<span class="w">    </span><span class="kr">const</span><span class="w"> </span><span class="n">y</span><span class="o">:</span><span class="w"> </span><span class="kt">u32</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="n">x</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="mi">2</span><span class="p">)</span><span class="w"> </span><span class="mi">5</span><span class="w"> </span><span class="k">else</span><span class="w"> </span><span class="k">unreachable</span><span class="p">;</span>
<span class="w">    </span><span class="n">_</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">y</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></div>
<div class="highlight"><pre><span></span><code>Test [1/1] test.Достижение unreachable... thread 14125 panic: reached unreachable code
./tests.zig:3:39: 0x2246f0 in test.Достижение unreachable (test)
    const y: u32 = if (x == 2) 5 else unreachable;
                                      ^
</code></pre></div></p>
<p>В примере ниже unreachable используется для утверждения «ветвь else никогда не выполнится».
<div class="highlight"><pre><span></span><code><span class="k">fn</span><span class="w"> </span><span class="n">asciiToUpper</span><span class="p">(</span><span class="n">x</span><span class="o">:</span><span class="w"> </span><span class="kt">u8</span><span class="p">)</span><span class="w"> </span><span class="kt">u8</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="k">return</span><span class="w"> </span><span class="k">switch</span><span class="w"> </span><span class="p">(</span><span class="n">x</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">        </span><span class="s">&#39;a&#39;</span><span class="p">...</span><span class="s">&#39;z&#39;</span><span class="w"> </span><span class="o">=&gt;</span><span class="w"> </span><span class="n">x</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="s">&#39;A&#39;</span><span class="w"> </span><span class="o">-</span><span class="w"> </span><span class="s">&#39;a&#39;</span><span class="p">,</span>
<span class="w">        </span><span class="s">&#39;A&#39;</span><span class="p">...</span><span class="s">&#39;Z&#39;</span><span class="w"> </span><span class="o">=&gt;</span><span class="w"> </span><span class="n">x</span><span class="p">,</span>
<span class="w">        </span><span class="k">else</span><span class="w"> </span><span class="o">=&gt;</span><span class="w"> </span><span class="k">unreachable</span><span class="p">,</span>
<span class="w">    </span><span class="p">};</span>
<span class="p">}</span>

<span class="k">test</span><span class="w"> </span><span class="s">&quot;Оператор unreachable в ветви switch&quot;</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="k">try</span><span class="w"> </span><span class="n">expect</span><span class="p">(</span><span class="n">asciiToUpper</span><span class="p">(</span><span class="s">&#39;a&#39;</span><span class="p">)</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="s">&#39;A&#39;</span><span class="p">);</span>
<span class="w">    </span><span class="k">try</span><span class="w"> </span><span class="n">expect</span><span class="p">(</span><span class="n">asciiToUpper</span><span class="p">(</span><span class="s">&#39;A&#39;</span><span class="p">)</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="s">&#39;A&#39;</span><span class="p">);</span>
<span class="p">}</span>
</code></pre></div></p>
<h2 id="t">Указатель на один элемент (<code>*T</code>)<a class="headerlink" href="#t" title="Permanent link">§</a></h2>
<p>Обычные указатели в Zig не могут иметь значение 0 или null. Они следуют синтаксису <code>*T</code>, что означает «указатель на одно значение типа T».</p>
<p>Указатель создаётся при помощи синтаксиса <code>&amp;variable</code>, а разыменовывается при помощи <code>pointer.*</code>.</p>
<div class="highlight"><pre><span></span><code><span class="k">fn</span><span class="w"> </span><span class="n">increment</span><span class="p">(</span><span class="n">num</span><span class="o">:</span><span class="w"> </span><span class="o">*</span><span class="kt">u8</span><span class="p">)</span><span class="w"> </span><span class="kt">void</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="n">num</span><span class="p">.</span><span class="o">*</span><span class="w"> </span><span class="o">+=</span><span class="w"> </span><span class="mi">1</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">test</span><span class="w"> </span><span class="s">&quot;Указатель на переменную&quot;</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="kr">var</span><span class="w"> </span><span class="n">x</span><span class="o">:</span><span class="w"> </span><span class="kt">u8</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">1</span><span class="p">;</span>
<span class="w">    </span><span class="n">increment</span><span class="p">(</span><span class="o">&amp;</span><span class="n">x</span><span class="p">);</span>
<span class="w">    </span><span class="k">try</span><span class="w"> </span><span class="n">expect</span><span class="p">(</span><span class="n">x</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="mi">2</span><span class="p">);</span>
<span class="p">}</span>
</code></pre></div>
<p>Попытка установить значение 0 для указателя <code>*T</code> считается обнаруживаемым недопустимым поведением.</p>
<!--fail_test-->
<p><div class="highlight"><pre><span></span><code><span class="k">test</span><span class="w"> </span><span class="s">&quot;Непослушный указатель&quot;</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="kr">var</span><span class="w"> </span><span class="n">x</span><span class="o">:</span><span class="w"> </span><span class="kt">u16</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">0</span><span class="p">;</span>
<span class="w">    </span><span class="kr">var</span><span class="w"> </span><span class="n">y</span><span class="o">:</span><span class="w"> </span><span class="o">*</span><span class="kt">u8</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="nb">@ptrFromInt</span><span class="p">(</span><span class="n">x</span><span class="p">);</span>
<span class="w">    </span><span class="n">_</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">y</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></div>
<div class="highlight"><pre><span></span><code>Test [1/1] test.Непослушный указатель... thread 15237 panic: cast causes pointer to be null
/home/bratishkaerik/github.com/zighelp/tests.zig:3:18: 0x224711 in test.Непослушный указатель (test)
    var y: *u8 = @ptrFromInt(x);
                 ^
</code></pre></div></p>
<p>Zig также содержит указатели на константы (const pointers) в виде <code>*const T</code>, которые нельзя использовать для изменения указываемого значения.</p>
<!--fail_test-->
<p><div class="highlight"><pre><span></span><code><span class="k">test</span><span class="w"> </span><span class="s">&quot;Указатель на константу&quot;</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="kr">const</span><span class="w"> </span><span class="n">x</span><span class="o">:</span><span class="w"> </span><span class="kt">u8</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">1</span><span class="p">;</span>
<span class="w">    </span><span class="kr">var</span><span class="w"> </span><span class="n">y</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="o">&amp;</span><span class="n">x</span><span class="p">;</span>
<span class="w">    </span><span class="n">y</span><span class="p">.</span><span class="o">*</span><span class="w"> </span><span class="o">+=</span><span class="w"> </span><span class="mi">1</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></div>
<div class="highlight"><pre><span></span><code>error: cannot assign to constant
    y.* += 1;
    ~~~~^~~~
</code></pre></div></p>
<p>Тип <code>*T</code> может быть автоматически приведён к типу <code>*const T</code>, но не наоборот.</p>
<h2 id="usize-isize">Целые числа размером с указатель: <code>usize</code> и <code>isize</code><a class="headerlink" href="#usize-isize" title="Permanent link">§</a></h2>
<p>Типы <code>usize</code> и <code>isize</code> используются для объявления беззнаковых и знаковых целых чисел соотвественно и имеют тот же размер, что и указатели на данной архитектуре.</p>
<div class="highlight"><pre><span></span><code><span class="k">test</span><span class="w"> </span><span class="s">&quot;Размеры usize и isize&quot;</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="k">try</span><span class="w"> </span><span class="n">expect</span><span class="p">(</span><span class="nb">@sizeOf</span><span class="p">(</span><span class="kt">usize</span><span class="p">)</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="nb">@sizeOf</span><span class="p">(</span><span class="o">*</span><span class="kt">u8</span><span class="p">));</span>
<span class="w">    </span><span class="k">try</span><span class="w"> </span><span class="n">expect</span><span class="p">(</span><span class="nb">@sizeOf</span><span class="p">(</span><span class="kt">isize</span><span class="p">)</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="nb">@sizeOf</span><span class="p">(</span><span class="o">*</span><span class="kt">u8</span><span class="p">));</span>
<span class="p">}</span>
</code></pre></div>
<h2 id="t_1">Указатель на неизвестное количество элементов (<code>[*]T</code>)<a class="headerlink" href="#t_1" title="Permanent link">§</a></h2>
<p>Иногда вам может понадобиться указатель на неизвестное количество элементов. В этом случае используется синтаксис <code>[*]T</code> (указатель на неизвестное количество элементов с типом T), который схож с указателем <code>*T</code>. В отличии от последнего. этот указатель поддерживает доступ по индексу, арифметику указателей и обрезание (slicing). Также он <strong>не</strong> поддерживает типы с неизвестным размером. Тип <code>*T</code> приводится к типу <code>[*]T</code>.</p>
<p>Они могут указывать на любое количество элементов, включая 0 и 1.</p>
<h2 id="t_2">Срезы (<code>[]T</code>)<a class="headerlink" href="#t_2" title="Permanent link">§</a></h2>
<p>Срезы (slices) можно рассматривать как объединение <code>[*]T</code> (указатель на данные) и <code>usize</code> (кол-во элементов). Синтаксис выглядит подобным образом: <code>[]T</code>, где <code>T</code> является типом дочернего элемента. Срезы широко используются в яZig, когда необходимо оперировать с данными разной длины. Срезы могут содержать те же атрибуты, что и указатели, напр. константность элемента (<code>[*]const T</code> и <code>[]const T</code>). Как и массивы, срезы можно использовать в циклах for. Строковые литералы в Zig могут быть приведены к типу <code>[]const u8</code>.</p>
<p>Для обрезания части массива используется синтаксис <code>x[n..m]</code>. Эта операция называется <strong>обрезанием</strong> и создаёт срез элементов с <code>x[n]</code> и до <code>x[m - 1]</code>. В этом примере мы используем неизменяемый срез, т.к. мы не изменяем значения, на которые он указывает.</p>
<div class="highlight"><pre><span></span><code><span class="k">fn</span><span class="w"> </span><span class="n">total</span><span class="p">(</span><span class="n">values</span><span class="o">:</span><span class="w"> </span><span class="p">[]</span><span class="kr">const</span><span class="w"> </span><span class="kt">u8</span><span class="p">)</span><span class="w"> </span><span class="kt">usize</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="kr">var</span><span class="w"> </span><span class="n">sum</span><span class="o">:</span><span class="w"> </span><span class="kt">usize</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">0</span><span class="p">;</span>
<span class="w">    </span><span class="k">for</span><span class="w"> </span><span class="p">(</span><span class="n">values</span><span class="p">)</span><span class="w"> </span><span class="o">|</span><span class="n">v</span><span class="o">|</span><span class="w"> </span><span class="n">sum</span><span class="w"> </span><span class="o">+=</span><span class="w"> </span><span class="n">v</span><span class="p">;</span>
<span class="w">    </span><span class="k">return</span><span class="w"> </span><span class="n">sum</span><span class="p">;</span>
<span class="p">}</span>
<span class="k">test</span><span class="w"> </span><span class="s">&quot;Срезы&quot;</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="kr">const</span><span class="w"> </span><span class="n">array</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">[</span><span class="n">_</span><span class="p">]</span><span class="kt">u8</span><span class="p">{</span><span class="w"> </span><span class="mi">1</span><span class="p">,</span><span class="w"> </span><span class="mi">2</span><span class="p">,</span><span class="w"> </span><span class="mi">3</span><span class="p">,</span><span class="w"> </span><span class="mi">4</span><span class="p">,</span><span class="w"> </span><span class="mi">5</span><span class="w"> </span><span class="p">};</span>
<span class="w">    </span><span class="kr">const</span><span class="w"> </span><span class="n">slice</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">array</span><span class="p">[</span><span class="mi">0</span><span class="p">..</span><span class="mi">3</span><span class="p">];</span>
<span class="w">    </span><span class="k">try</span><span class="w"> </span><span class="n">expect</span><span class="p">(</span><span class="n">total</span><span class="p">(</span><span class="n">slice</span><span class="p">)</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="mi">6</span><span class="p">);</span>
<span class="p">}</span>
</code></pre></div>
<p>Если значения <code>n</code> и <code>m</code> известны во время компиляции, вместо среза будет создан указатель на подмассив. Так как этот указатель может быть приведён к срезу, это не является проблемой (т.е. <code>*[N]T</code> приводим к <code>[]T</code>).</p>
<div class="highlight"><pre><span></span><code><span class="k">test</span><span class="w"> </span><span class="s">&quot;Срезы 2&quot;</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="kr">const</span><span class="w"> </span><span class="n">array</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">[</span><span class="n">_</span><span class="p">]</span><span class="kt">u8</span><span class="p">{</span><span class="w"> </span><span class="mi">1</span><span class="p">,</span><span class="w"> </span><span class="mi">2</span><span class="p">,</span><span class="w"> </span><span class="mi">3</span><span class="p">,</span><span class="w"> </span><span class="mi">4</span><span class="p">,</span><span class="w"> </span><span class="mi">5</span><span class="w"> </span><span class="p">};</span>
<span class="w">    </span><span class="kr">const</span><span class="w"> </span><span class="n">slice</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">array</span><span class="p">[</span><span class="mi">0</span><span class="p">..</span><span class="mi">3</span><span class="p">];</span>
<span class="w">    </span><span class="k">try</span><span class="w"> </span><span class="n">expect</span><span class="p">(</span><span class="nb">@TypeOf</span><span class="p">(</span><span class="n">slice</span><span class="p">)</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="o">*</span><span class="kr">const</span><span class="w"> </span><span class="p">[</span><span class="mi">3</span><span class="p">]</span><span class="kt">u8</span><span class="p">);</span>
<span class="p">}</span>
</code></pre></div>
<p>Вы можете пропустить второе значение, если вы обрезаете до конца — <code>x[n..]</code>.</p>
<div class="highlight"><pre><span></span><code><span class="k">test</span><span class="w"> </span><span class="s">&quot;Срезы 3&quot;</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="kr">var</span><span class="w"> </span><span class="n">array</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">[</span><span class="n">_</span><span class="p">]</span><span class="kt">u8</span><span class="p">{</span><span class="w"> </span><span class="mi">1</span><span class="p">,</span><span class="w"> </span><span class="mi">2</span><span class="p">,</span><span class="w"> </span><span class="mi">3</span><span class="p">,</span><span class="w"> </span><span class="mi">4</span><span class="p">,</span><span class="w"> </span><span class="mi">5</span><span class="w"> </span><span class="p">};</span>
<span class="w">    </span><span class="kr">var</span><span class="w"> </span><span class="n">slice</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">array</span><span class="p">[</span><span class="mi">0</span><span class="p">..];</span>
<span class="w">    </span><span class="n">_</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">slice</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></div>
<p>Кроме массивов, также можно обрезать указатели на неизвестное кол-во элементов и сами срезы.</p>
<h2 id="_5">Перечисления<a class="headerlink" href="#_5" title="Permanent link">§</a></h2>
<p>Перечисления (enumerations) в Zig являются набором идентификаторов с целочисленными значениями.</p>
<p>Давайте создадим тип для перечисления направления.
<div class="highlight"><pre><span></span><code><span class="kr">const</span><span class="w"> </span><span class="n">Direction</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="k">enum</span><span class="w"> </span><span class="p">{</span><span class="w"> </span><span class="n">north</span><span class="p">,</span><span class="w"> </span><span class="n">south</span><span class="p">,</span><span class="w"> </span><span class="n">east</span><span class="p">,</span><span class="w"> </span><span class="n">west</span><span class="w"> </span><span class="p">};</span>
</code></pre></div></p>
<p>В перечислениях можно явно указать (численный) тип находящихся внутри элементов.
<div class="highlight"><pre><span></span><code><span class="kr">const</span><span class="w"> </span><span class="n">Value</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="k">enum</span><span class="p">(</span><span class="n">u2</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w"> </span><span class="n">zero</span><span class="p">,</span><span class="w"> </span><span class="n">one</span><span class="p">,</span><span class="w"> </span><span class="n">two</span><span class="w"> </span><span class="p">};</span>
</code></pre></div></p>
<p>По умолчанию, численные значения элементов начинаются с нуля. Элементы можно преобразовать в числа при помощи встроенной функции <a href="https://ziglang.org/documentation/master/#intFromEnum"><code>@intFromEnum</code></a>.
<div class="highlight"><pre><span></span><code><span class="k">test</span><span class="w"> </span><span class="s">&quot;Получение численных значений из элементов&quot;</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="k">try</span><span class="w"> </span><span class="n">expect</span><span class="p">(</span><span class="nb">@intFromEnum</span><span class="p">(</span><span class="n">Value</span><span class="p">.</span><span class="n">zero</span><span class="p">)</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="mi">0</span><span class="p">);</span>
<span class="w">    </span><span class="k">try</span><span class="w"> </span><span class="n">expect</span><span class="p">(</span><span class="nb">@intFromEnum</span><span class="p">(</span><span class="n">Value</span><span class="p">.</span><span class="n">one</span><span class="p">)</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="mi">1</span><span class="p">);</span>
<span class="w">    </span><span class="k">try</span><span class="w"> </span><span class="n">expect</span><span class="p">(</span><span class="nb">@intFromEnum</span><span class="p">(</span><span class="n">Value</span><span class="p">.</span><span class="n">two</span><span class="p">)</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="mi">2</span><span class="p">);</span>
<span class="p">}</span>
</code></pre></div></p>
<p>Значения элементов можно переопределять, при этом значения следующих элементов всё так же продолжают численный ряд.</p>
<div class="highlight"><pre><span></span><code><span class="kr">const</span><span class="w"> </span><span class="n">Value2</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="k">enum</span><span class="p">(</span><span class="kt">u32</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="n">hundred</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">100</span><span class="p">,</span>
<span class="w">    </span><span class="n">thousand</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">1000</span><span class="p">,</span>
<span class="w">    </span><span class="n">million</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">1000000</span><span class="p">,</span>
<span class="w">    </span><span class="n">next</span><span class="p">,</span>
<span class="p">};</span>

<span class="k">test</span><span class="w"> </span><span class="s">&quot;Переопределение численных значений&quot;</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="k">try</span><span class="w"> </span><span class="n">expect</span><span class="p">(</span><span class="nb">@intFromEnum</span><span class="p">(</span><span class="n">Value2</span><span class="p">.</span><span class="n">hundred</span><span class="p">)</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="mi">100</span><span class="p">);</span>
<span class="w">    </span><span class="k">try</span><span class="w"> </span><span class="n">expect</span><span class="p">(</span><span class="nb">@intFromEnum</span><span class="p">(</span><span class="n">Value2</span><span class="p">.</span><span class="n">thousand</span><span class="p">)</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="mi">1000</span><span class="p">);</span>
<span class="w">    </span><span class="k">try</span><span class="w"> </span><span class="n">expect</span><span class="p">(</span><span class="nb">@intFromEnum</span><span class="p">(</span><span class="n">Value2</span><span class="p">.</span><span class="n">million</span><span class="p">)</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="mi">1000000</span><span class="p">);</span>
<span class="w">    </span><span class="k">try</span><span class="w"> </span><span class="n">expect</span><span class="p">(</span><span class="nb">@intFromEnum</span><span class="p">(</span><span class="n">Value2</span><span class="p">.</span><span class="n">next</span><span class="p">)</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="mi">1000001</span><span class="p">);</span>
<span class="p">}</span>
</code></pre></div>
<p>В объявлении перечисляемого типа можно добавить функции, при этом они будут ограничены окружающим пространством имён. Их можно вызвать как обычную функцию, либо в стиле методов используя синтаксис <code>элемент.вызываемаяФункция(a, b)</code> (dot syntax), при этом элемент перечисления автоматически становится первым параметром функции (т.е. данная запись эквивалента <code>Перечисление.вызываемаяФункция(элемент, a, b)</code>).</p>
<div class="highlight"><pre><span></span><code><span class="kr">const</span><span class="w"> </span><span class="n">Suit</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="k">enum</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="n">clubs</span><span class="p">,</span>
<span class="w">    </span><span class="n">spades</span><span class="p">,</span>
<span class="w">    </span><span class="n">diamonds</span><span class="p">,</span>
<span class="w">    </span><span class="n">hearts</span><span class="p">,</span>

<span class="w">    </span><span class="kr">pub</span><span class="w"> </span><span class="k">fn</span><span class="w"> </span><span class="n">isClubs</span><span class="p">(</span><span class="n">self</span><span class="o">:</span><span class="w"> </span><span class="n">Suit</span><span class="p">)</span><span class="w"> </span><span class="kt">bool</span><span class="w"> </span><span class="p">{</span>
<span class="w">        </span><span class="k">return</span><span class="w"> </span><span class="n">self</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="n">Suit</span><span class="p">.</span><span class="n">clubs</span><span class="p">;</span>
<span class="w">    </span><span class="p">}</span>
<span class="p">};</span>

<span class="k">test</span><span class="w"> </span><span class="s">&quot;Вызов функции из пространства имён перечисления&quot;</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="kr">const</span><span class="w"> </span><span class="n">element</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">Suit</span><span class="p">.</span><span class="n">spades</span><span class="p">;</span><span class="w"> </span><span class="c1">// экземпляр перечисления Suit</span>
<span class="w">    </span><span class="k">try</span><span class="w"> </span><span class="n">expect</span><span class="p">(</span><span class="n">element</span><span class="p">.</span><span class="n">isClubs</span><span class="p">()</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="kc">true</span><span class="p">);</span>
<span class="w">    </span><span class="k">try</span><span class="w"> </span><span class="n">expect</span><span class="p">(</span><span class="n">Suit</span><span class="p">.</span><span class="n">isClubs</span><span class="p">(</span><span class="n">element</span><span class="p">)</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="kc">true</span><span class="p">);</span>
<span class="p">}</span>
</code></pre></div>
<p>Перечисления также могут иметь объявления значений с помощью <code>var</code> и <code>const</code>. Они действуют как глобальные переменные (или константы) в этом пространстве имён, и их значения не связаны и не привязаны к экземплярам самого перечисления.</p>
<div class="highlight"><pre><span></span><code><span class="kr">const</span><span class="w"> </span><span class="n">Mode</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="k">enum</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="kr">var</span><span class="w"> </span><span class="n">count</span><span class="o">:</span><span class="w"> </span><span class="kt">u32</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">0</span><span class="p">;</span>

<span class="w">    </span><span class="n">on</span><span class="p">,</span>
<span class="w">    </span><span class="n">off</span><span class="p">,</span>
<span class="p">};</span>

<span class="k">test</span><span class="w"> </span><span class="s">&quot;Изменение глобальной переменной перечисления Mode&quot;</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="n">Mode</span><span class="p">.</span><span class="n">count</span><span class="w"> </span><span class="o">+=</span><span class="w"> </span><span class="mi">1</span><span class="p">;</span>
<span class="w">    </span><span class="k">try</span><span class="w"> </span><span class="n">expect</span><span class="p">(</span><span class="n">Mode</span><span class="p">.</span><span class="n">count</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="mi">1</span><span class="p">);</span>
<span class="p">}</span>
</code></pre></div>
<h2 id="structs">Structs<a class="headerlink" href="#structs" title="Permanent link">§</a></h2>
<p>Structs are Zig's most common kind of composite data type, allowing you to define types that can store a fixed set of named fields. Zig gives no guarantees about the in-memory order of fields in a struct, or its size. Like arrays, structs are also neatly constructed with <code>T{}</code> syntax. Here is an example of declaring and filling a struct.
<div class="highlight"><pre><span></span><code><span class="kr">const</span><span class="w"> </span><span class="n">Vec3</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="k">struct</span><span class="w"> </span><span class="p">{</span><span class="w"> </span><span class="n">x</span><span class="o">:</span><span class="w"> </span><span class="kt">f32</span><span class="p">,</span><span class="w"> </span><span class="n">y</span><span class="o">:</span><span class="w"> </span><span class="kt">f32</span><span class="p">,</span><span class="w"> </span><span class="n">z</span><span class="o">:</span><span class="w"> </span><span class="kt">f32</span><span class="w"> </span><span class="p">};</span>

<span class="k">test</span><span class="w"> </span><span class="s">&quot;struct usage&quot;</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="kr">const</span><span class="w"> </span><span class="n">my_vector</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">Vec3</span><span class="p">{</span>
<span class="w">        </span><span class="p">.</span><span class="n">x</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">0</span><span class="p">,</span>
<span class="w">        </span><span class="p">.</span><span class="n">y</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">100</span><span class="p">,</span>
<span class="w">        </span><span class="p">.</span><span class="n">z</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">50</span><span class="p">,</span>
<span class="w">    </span><span class="p">};</span>
<span class="w">    </span><span class="n">_</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">my_vector</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></div></p>
<p>All fields must be given a value.</p>
<!--fail_test-->
<p><div class="highlight"><pre><span></span><code><span class="k">test</span><span class="w"> </span><span class="s">&quot;missing struct field&quot;</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="kr">const</span><span class="w"> </span><span class="n">my_vector</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">Vec3</span><span class="p">{</span>
<span class="w">        </span><span class="p">.</span><span class="n">x</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">0</span><span class="p">,</span>
<span class="w">        </span><span class="p">.</span><span class="n">z</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">50</span><span class="p">,</span>
<span class="w">    </span><span class="p">};</span>
<span class="w">    </span><span class="n">_</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">my_vector</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></div>
<div class="highlight"><pre><span></span><code>error: missing field: &#39;y&#39;
    const my_vector = Vec3{
                        ^
</code></pre></div></p>
<p>Fields may be given defaults:
<div class="highlight"><pre><span></span><code><span class="kr">const</span><span class="w"> </span><span class="n">Vec4</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="k">struct</span><span class="w"> </span><span class="p">{</span><span class="w"> </span><span class="n">x</span><span class="o">:</span><span class="w"> </span><span class="kt">f32</span><span class="p">,</span><span class="w"> </span><span class="n">y</span><span class="o">:</span><span class="w"> </span><span class="kt">f32</span><span class="p">,</span><span class="w"> </span><span class="n">z</span><span class="o">:</span><span class="w"> </span><span class="kt">f32</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">0</span><span class="p">,</span><span class="w"> </span><span class="n">w</span><span class="o">:</span><span class="w"> </span><span class="kt">f32</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="kc">undefined</span><span class="w"> </span><span class="p">};</span>

<span class="k">test</span><span class="w"> </span><span class="s">&quot;struct defaults&quot;</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="kr">const</span><span class="w"> </span><span class="n">my_vector</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">Vec4</span><span class="p">{</span>
<span class="w">        </span><span class="p">.</span><span class="n">x</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">25</span><span class="p">,</span>
<span class="w">        </span><span class="p">.</span><span class="n">y</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="o">-</span><span class="mi">50</span><span class="p">,</span>
<span class="w">    </span><span class="p">};</span>
<span class="w">    </span><span class="n">_</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">my_vector</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></div></p>
<p>Like enums, structs may also contain functions and declarations.</p>
<p>Structs have the unique property that when given a pointer to a struct, one level of dereferencing is done automatically when accessing fields. Notice how in this example, self.x and self.y are accessed in the swap function without needing to dereference the self pointer.</p>
<div class="highlight"><pre><span></span><code><span class="kr">const</span><span class="w"> </span><span class="n">Stuff</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="k">struct</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="n">x</span><span class="o">:</span><span class="w"> </span><span class="kt">i32</span><span class="p">,</span>
<span class="w">    </span><span class="n">y</span><span class="o">:</span><span class="w"> </span><span class="kt">i32</span><span class="p">,</span>
<span class="w">    </span><span class="k">fn</span><span class="w"> </span><span class="n">swap</span><span class="p">(</span><span class="n">self</span><span class="o">:</span><span class="w"> </span><span class="o">*</span><span class="n">Stuff</span><span class="p">)</span><span class="w"> </span><span class="kt">void</span><span class="w"> </span><span class="p">{</span>
<span class="w">        </span><span class="kr">const</span><span class="w"> </span><span class="n">tmp</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">self</span><span class="p">.</span><span class="n">x</span><span class="p">;</span>
<span class="w">        </span><span class="n">self</span><span class="p">.</span><span class="n">x</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">self</span><span class="p">.</span><span class="n">y</span><span class="p">;</span>
<span class="w">        </span><span class="n">self</span><span class="p">.</span><span class="n">y</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">tmp</span><span class="p">;</span>
<span class="w">    </span><span class="p">}</span>
<span class="p">};</span>

<span class="k">test</span><span class="w"> </span><span class="s">&quot;automatic dereference&quot;</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="kr">var</span><span class="w"> </span><span class="n">thing</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">Stuff</span><span class="p">{</span><span class="w"> </span><span class="p">.</span><span class="n">x</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">10</span><span class="p">,</span><span class="w"> </span><span class="p">.</span><span class="n">y</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">20</span><span class="w"> </span><span class="p">};</span>
<span class="w">    </span><span class="n">thing</span><span class="p">.</span><span class="n">swap</span><span class="p">();</span>
<span class="w">    </span><span class="k">try</span><span class="w"> </span><span class="n">expect</span><span class="p">(</span><span class="n">thing</span><span class="p">.</span><span class="n">x</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="mi">20</span><span class="p">);</span>
<span class="w">    </span><span class="k">try</span><span class="w"> </span><span class="n">expect</span><span class="p">(</span><span class="n">thing</span><span class="p">.</span><span class="n">y</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="mi">10</span><span class="p">);</span>
<span class="p">}</span>
</code></pre></div>
<h2 id="unions">Unions<a class="headerlink" href="#unions" title="Permanent link">§</a></h2>
<p>Zig's unions allow you to define types which store one value of many possible typed fields; only one field may be active at one time.</p>
<p>Bare union types do not have a guaranteed memory layout. Because of this, bare unions cannot be used to reinterpret memory. Accessing a field in a union which is not active is detectable illegal behaviour.</p>
<!--fail_test-->
<p><div class="highlight"><pre><span></span><code><span class="kr">const</span><span class="w"> </span><span class="n">Result</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="k">union</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="n">int</span><span class="o">:</span><span class="w"> </span><span class="kt">i64</span><span class="p">,</span>
<span class="w">    </span><span class="n">float</span><span class="o">:</span><span class="w"> </span><span class="kt">f64</span><span class="p">,</span>
<span class="w">    </span><span class="kt">bool</span><span class="o">:</span><span class="w"> </span><span class="kt">bool</span><span class="p">,</span>
<span class="p">};</span>

<span class="k">test</span><span class="w"> </span><span class="s">&quot;simple union&quot;</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="kr">var</span><span class="w"> </span><span class="n">result</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">Result</span><span class="p">{</span><span class="w"> </span><span class="p">.</span><span class="n">int</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">1234</span><span class="w"> </span><span class="p">};</span>
<span class="w">    </span><span class="n">result</span><span class="p">.</span><span class="n">float</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mf">12.34</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></div>
<div class="highlight"><pre><span></span><code>Test [1/1] test.simple union... thread 6604310 panic: access of union field &#39;float&#39; while field &#39;int&#39; is active
./tests.zig:9:11: 0x10487c807 in test.simple union (test)
    result.float = 12.34;
</code></pre></div></p>
<p>Tagged unions are unions which use an enum to detect which field is active. Here we make use of payload capturing again, to switch on the tag type of a union while also capturing the value it contains. Here we use a <em>pointer capture</em>; captured values are immutable, but with the <code>|*value|</code> syntax we can capture a pointer to the values instead of the values themselves. This allows us to use dereferencing to mutate the original value.</p>
<div class="highlight"><pre><span></span><code><span class="kr">const</span><span class="w"> </span><span class="n">Tag</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="k">enum</span><span class="w"> </span><span class="p">{</span><span class="w"> </span><span class="n">a</span><span class="p">,</span><span class="w"> </span><span class="n">b</span><span class="p">,</span><span class="w"> </span><span class="n">c</span><span class="w"> </span><span class="p">};</span>

<span class="kr">const</span><span class="w"> </span><span class="n">Tagged</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="k">union</span><span class="p">(</span><span class="n">Tag</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w"> </span><span class="n">a</span><span class="o">:</span><span class="w"> </span><span class="kt">u8</span><span class="p">,</span><span class="w"> </span><span class="n">b</span><span class="o">:</span><span class="w"> </span><span class="kt">f32</span><span class="p">,</span><span class="w"> </span><span class="n">c</span><span class="o">:</span><span class="w"> </span><span class="kt">bool</span><span class="w"> </span><span class="p">};</span>

<span class="k">test</span><span class="w"> </span><span class="s">&quot;switch on tagged union&quot;</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="kr">var</span><span class="w"> </span><span class="n">value</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">Tagged</span><span class="p">{</span><span class="w"> </span><span class="p">.</span><span class="n">b</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mf">1.5</span><span class="w"> </span><span class="p">};</span>
<span class="w">    </span><span class="k">switch</span><span class="w"> </span><span class="p">(</span><span class="n">value</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">        </span><span class="p">.</span><span class="n">a</span><span class="w"> </span><span class="o">=&gt;</span><span class="w"> </span><span class="o">|*</span><span class="n">byte</span><span class="o">|</span><span class="w"> </span><span class="n">byte</span><span class="p">.</span><span class="o">*</span><span class="w"> </span><span class="o">+=</span><span class="w"> </span><span class="mi">1</span><span class="p">,</span>
<span class="w">        </span><span class="p">.</span><span class="n">b</span><span class="w"> </span><span class="o">=&gt;</span><span class="w"> </span><span class="o">|*</span><span class="n">float</span><span class="o">|</span><span class="w"> </span><span class="n">float</span><span class="p">.</span><span class="o">*</span><span class="w"> </span><span class="o">*=</span><span class="w"> </span><span class="mi">2</span><span class="p">,</span>
<span class="w">        </span><span class="p">.</span><span class="n">c</span><span class="w"> </span><span class="o">=&gt;</span><span class="w"> </span><span class="o">|*</span><span class="n">b</span><span class="o">|</span><span class="w"> </span><span class="n">b</span><span class="p">.</span><span class="o">*</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="o">!</span><span class="n">b</span><span class="p">.</span><span class="o">*</span><span class="p">,</span>
<span class="w">    </span><span class="p">}</span>
<span class="w">    </span><span class="k">try</span><span class="w"> </span><span class="n">expect</span><span class="p">(</span><span class="n">value</span><span class="p">.</span><span class="n">b</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="mi">3</span><span class="p">);</span>
<span class="p">}</span>
</code></pre></div>
<p>The tag type of a tagged union can also be inferred. This is equivalent to the Tagged type above.</p>
<!--no_test-->
<div class="highlight"><pre><span></span><code><span class="kr">const</span><span class="w"> </span><span class="n">Tagged</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="k">union</span><span class="p">(</span><span class="k">enum</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w"> </span><span class="n">a</span><span class="o">:</span><span class="w"> </span><span class="kt">u8</span><span class="p">,</span><span class="w"> </span><span class="n">b</span><span class="o">:</span><span class="w"> </span><span class="kt">f32</span><span class="p">,</span><span class="w"> </span><span class="n">c</span><span class="o">:</span><span class="w"> </span><span class="kt">bool</span><span class="w"> </span><span class="p">};</span>
</code></pre></div>
<p><code>void</code> member types can have their type omitted from the syntax. Here, none is of type <code>void</code>.</p>
<div class="highlight"><pre><span></span><code><span class="kr">const</span><span class="w"> </span><span class="n">Tagged2</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="k">union</span><span class="p">(</span><span class="k">enum</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w"> </span><span class="n">a</span><span class="o">:</span><span class="w"> </span><span class="kt">u8</span><span class="p">,</span><span class="w"> </span><span class="n">b</span><span class="o">:</span><span class="w"> </span><span class="kt">f32</span><span class="p">,</span><span class="w"> </span><span class="n">c</span><span class="o">:</span><span class="w"> </span><span class="kt">bool</span><span class="p">,</span><span class="w"> </span><span class="n">none</span><span class="w"> </span><span class="p">};</span>
</code></pre></div>
<h2 id="integer-rules">Integer Rules<a class="headerlink" href="#integer-rules" title="Permanent link">§</a></h2>
<p>Zig supports hex, octal and binary integer literals.
<div class="highlight"><pre><span></span><code><span class="kr">const</span><span class="w"> </span><span class="n">decimal_int</span><span class="o">:</span><span class="w"> </span><span class="kt">i32</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">98222</span><span class="p">;</span>
<span class="kr">const</span><span class="w"> </span><span class="n">hex_int</span><span class="o">:</span><span class="w"> </span><span class="kt">u8</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mh">0xff</span><span class="p">;</span>
<span class="kr">const</span><span class="w"> </span><span class="n">another_hex_int</span><span class="o">:</span><span class="w"> </span><span class="kt">u8</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mh">0xFF</span><span class="p">;</span>
<span class="kr">const</span><span class="w"> </span><span class="n">octal_int</span><span class="o">:</span><span class="w"> </span><span class="kt">u16</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mo">0o755</span><span class="p">;</span>
<span class="kr">const</span><span class="w"> </span><span class="n">binary_int</span><span class="o">:</span><span class="w"> </span><span class="kt">u8</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mb">0b11110000</span><span class="p">;</span>
</code></pre></div>
Underscores may also be placed between digits as a visual separator.
<div class="highlight"><pre><span></span><code><span class="kr">const</span><span class="w"> </span><span class="n">one_billion</span><span class="o">:</span><span class="w"> </span><span class="kt">u64</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">1</span><span class="n">_000_000_000</span><span class="p">;</span>
<span class="kr">const</span><span class="w"> </span><span class="n">binary_mask</span><span class="o">:</span><span class="w"> </span><span class="kt">u64</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mb">0b1</span><span class="n">_1111_1111</span><span class="p">;</span>
<span class="kr">const</span><span class="w"> </span><span class="n">permissions</span><span class="o">:</span><span class="w"> </span><span class="kt">u64</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mo">0o7</span><span class="n">_5_5</span><span class="p">;</span>
<span class="kr">const</span><span class="w"> </span><span class="n">big_address</span><span class="o">:</span><span class="w"> </span><span class="kt">u64</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mh">0xFF80</span><span class="n">_0000_0000_0000</span><span class="p">;</span>
</code></pre></div></p>
<p>"Integer Widening" is allowed, which means that integers of a type may coerce to an integer of another type, providing that the new type can fit all of the values that the old type can.</p>
<div class="highlight"><pre><span></span><code><span class="k">test</span><span class="w"> </span><span class="s">&quot;integer widening&quot;</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="kr">const</span><span class="w"> </span><span class="n">a</span><span class="o">:</span><span class="w"> </span><span class="kt">u8</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">250</span><span class="p">;</span>
<span class="w">    </span><span class="kr">const</span><span class="w"> </span><span class="n">b</span><span class="o">:</span><span class="w"> </span><span class="kt">u16</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">a</span><span class="p">;</span>
<span class="w">    </span><span class="kr">const</span><span class="w"> </span><span class="n">c</span><span class="o">:</span><span class="w"> </span><span class="kt">u32</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">b</span><span class="p">;</span>
<span class="w">    </span><span class="k">try</span><span class="w"> </span><span class="n">expect</span><span class="p">(</span><span class="n">c</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="n">a</span><span class="p">);</span>
<span class="p">}</span>
</code></pre></div>
<p>If you have a value stored in an integer that cannot coerce to the type that you want, <a href="https://ziglang.org/documentation/master/#intCast"><code>@intCast</code></a> may be used to explicitly convert from one type to the other. If the value given is out of the range of the destination type, this is detectable illegal behaviour.</p>
<div class="highlight"><pre><span></span><code><span class="k">test</span><span class="w"> </span><span class="s">&quot;@intCast&quot;</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="kr">const</span><span class="w"> </span><span class="n">x</span><span class="o">:</span><span class="w"> </span><span class="kt">u64</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">200</span><span class="p">;</span>
<span class="w">    </span><span class="kr">const</span><span class="w"> </span><span class="n">y</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="nb">@as</span><span class="p">(</span><span class="kt">u8</span><span class="p">,</span><span class="w"> </span><span class="nb">@intCast</span><span class="p">(</span><span class="n">x</span><span class="p">));</span>
<span class="w">    </span><span class="k">try</span><span class="w"> </span><span class="n">expect</span><span class="p">(</span><span class="nb">@TypeOf</span><span class="p">(</span><span class="n">y</span><span class="p">)</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="kt">u8</span><span class="p">);</span>
<span class="p">}</span>
</code></pre></div>
<p>Integers by default are not allowed to overflow. Overflows are detectable illegal behaviour. Sometimes being able to overflow integers in a well defined manner is wanted behaviour. For this use case, Zig provides overflow operators.</p>
<table>
<thead>
<tr>
<th>Normal Operator</th>
<th>Wrapping Operator</th>
</tr>
</thead>
<tbody>
<tr>
<td>+</td>
<td>+%</td>
</tr>
<tr>
<td>-</td>
<td>-%</td>
</tr>
<tr>
<td>*</td>
<td>*%</td>
</tr>
<tr>
<td>+=</td>
<td>+%=</td>
</tr>
<tr>
<td>-=</td>
<td>-%=</td>
</tr>
<tr>
<td>*=</td>
<td>*%=</td>
</tr>
</tbody>
</table>
<div class="highlight"><pre><span></span><code><span class="k">test</span><span class="w"> </span><span class="s">&quot;well defined overflow&quot;</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="kr">var</span><span class="w"> </span><span class="n">a</span><span class="o">:</span><span class="w"> </span><span class="kt">u8</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">255</span><span class="p">;</span>
<span class="w">    </span><span class="n">a</span><span class="w"> </span><span class="o">+%=</span><span class="w"> </span><span class="mi">1</span><span class="p">;</span>
<span class="w">    </span><span class="k">try</span><span class="w"> </span><span class="n">expect</span><span class="p">(</span><span class="n">a</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="mi">0</span><span class="p">);</span>
<span class="p">}</span>
</code></pre></div>
<h2 id="floats">Floats<a class="headerlink" href="#floats" title="Permanent link">§</a></h2>
<p>Zig's floats are strictly IEEE compliant unless <a href="https://ziglang.org/documentation/master/#setFloatMode"><code>@setFloatMode(.Optimized)</code></a> is used, which is equivalent to GCC's <code>-ffast-math</code>. Floats coerce to larger float types.</p>
<div class="highlight"><pre><span></span><code><span class="k">test</span><span class="w"> </span><span class="s">&quot;float widening&quot;</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="kr">const</span><span class="w"> </span><span class="n">a</span><span class="o">:</span><span class="w"> </span><span class="kt">f16</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">0</span><span class="p">;</span>
<span class="w">    </span><span class="kr">const</span><span class="w"> </span><span class="n">b</span><span class="o">:</span><span class="w"> </span><span class="kt">f32</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">a</span><span class="p">;</span>
<span class="w">    </span><span class="kr">const</span><span class="w"> </span><span class="n">c</span><span class="o">:</span><span class="w"> </span><span class="kt">f128</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">b</span><span class="p">;</span>
<span class="w">    </span><span class="k">try</span><span class="w"> </span><span class="n">expect</span><span class="p">(</span><span class="n">c</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="nb">@as</span><span class="p">(</span><span class="kt">f128</span><span class="p">,</span><span class="w"> </span><span class="n">a</span><span class="p">));</span>
<span class="p">}</span>
</code></pre></div>
<p>Floats support multiple kinds of literal.
<div class="highlight"><pre><span></span><code><span class="kr">const</span><span class="w"> </span><span class="n">floating_point</span><span class="o">:</span><span class="w"> </span><span class="kt">f64</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mf">123.0E+77</span><span class="p">;</span>
<span class="kr">const</span><span class="w"> </span><span class="n">another_float</span><span class="o">:</span><span class="w"> </span><span class="kt">f64</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mf">123.0</span><span class="p">;</span>
<span class="kr">const</span><span class="w"> </span><span class="n">yet_another</span><span class="o">:</span><span class="w"> </span><span class="kt">f64</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mf">123.0e+77</span><span class="p">;</span>

<span class="kr">const</span><span class="w"> </span><span class="n">hex_floating_point</span><span class="o">:</span><span class="w"> </span><span class="kt">f64</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mf">0x103.70p-5</span><span class="p">;</span>
<span class="kr">const</span><span class="w"> </span><span class="n">another_hex_float</span><span class="o">:</span><span class="w"> </span><span class="kt">f64</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mf">0x103.70</span><span class="p">;</span>
<span class="kr">const</span><span class="w"> </span><span class="n">yet_another_hex_float</span><span class="o">:</span><span class="w"> </span><span class="kt">f64</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mf">0x103.70P-5</span><span class="p">;</span>
</code></pre></div>
Underscores may also be placed between digits.
<div class="highlight"><pre><span></span><code><span class="kr">const</span><span class="w"> </span><span class="n">lightspeed</span><span class="o">:</span><span class="w"> </span><span class="kt">f64</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">299</span><span class="n">_792_458</span><span class="p">.</span><span class="mi">000</span><span class="n">_000</span><span class="p">;</span>
<span class="kr">const</span><span class="w"> </span><span class="n">nanosecond</span><span class="o">:</span><span class="w"> </span><span class="kt">f64</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mf">0.000</span><span class="n">_000_001</span><span class="p">;</span>
<span class="kr">const</span><span class="w"> </span><span class="n">more_hex</span><span class="o">:</span><span class="w"> </span><span class="kt">f64</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mh">0x1234</span><span class="n">_5678</span><span class="p">.</span><span class="mi">9</span><span class="n">ABC_CDEFp</span><span class="o">-</span><span class="mi">10</span><span class="p">;</span>
</code></pre></div></p>
<p>Integers and floats may be converted using the built-in functions <a href="https://ziglang.org/documentation/master/#floatFromInt"><code>@floatFromInt</code></a> and <a href="https://ziglang.org/documentation/master/#intFromFloat"><code>@intFromFloat</code></a>. <a href="https://ziglang.org/documentation/master/#floatFromInt"><code>@floatFromInt</code></a> is always safe, whereas <a href="https://ziglang.org/documentation/master/#intFromFloat"><code>@intFromFloat</code></a> is detectable illegal behaviour if the float value cannot fit in the integer destination type.</p>
<div class="highlight"><pre><span></span><code><span class="k">test</span><span class="w"> </span><span class="s">&quot;int-float conversion&quot;</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="kr">const</span><span class="w"> </span><span class="n">a</span><span class="o">:</span><span class="w"> </span><span class="kt">i32</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">0</span><span class="p">;</span>
<span class="w">    </span><span class="kr">const</span><span class="w"> </span><span class="n">b</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="nb">@as</span><span class="p">(</span><span class="kt">f32</span><span class="p">,</span><span class="w"> </span><span class="nb">@floatFromInt</span><span class="p">(</span><span class="n">a</span><span class="p">));</span>
<span class="w">    </span><span class="kr">const</span><span class="w"> </span><span class="n">c</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="nb">@as</span><span class="p">(</span><span class="kt">i32</span><span class="p">,</span><span class="w"> </span><span class="nb">@intFromFloat</span><span class="p">(</span><span class="n">b</span><span class="p">));</span>
<span class="w">    </span><span class="k">try</span><span class="w"> </span><span class="n">expect</span><span class="p">(</span><span class="n">c</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="n">a</span><span class="p">);</span>
<span class="p">}</span>
</code></pre></div>
<h2 id="labelled-blocks-blk">Labelled Blocks <code>:blk {}</code><a class="headerlink" href="#labelled-blocks-blk" title="Permanent link">§</a></h2>
<p>Blocks in Zig are expressions and can be given labels, which are used to yield values. Here, we are using a label called blk. Blocks yield values, meaning that they can be used in place of a value. The value of an empty block <code>{}</code> is a value of the type <code>void</code>.</p>
<div class="highlight"><pre><span></span><code><span class="k">test</span><span class="w"> </span><span class="s">&quot;labelled blocks&quot;</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="kr">const</span><span class="w"> </span><span class="n">count</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">blk</span><span class="o">:</span><span class="w"> </span><span class="p">{</span>
<span class="w">        </span><span class="kr">var</span><span class="w"> </span><span class="n">sum</span><span class="o">:</span><span class="w"> </span><span class="kt">u32</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">0</span><span class="p">;</span>
<span class="w">        </span><span class="kr">var</span><span class="w"> </span><span class="n">i</span><span class="o">:</span><span class="w"> </span><span class="kt">u32</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">0</span><span class="p">;</span>
<span class="w">        </span><span class="k">while</span><span class="w"> </span><span class="p">(</span><span class="n">i</span><span class="w"> </span><span class="o">&lt;</span><span class="w"> </span><span class="mi">10</span><span class="p">)</span><span class="w"> </span><span class="o">:</span><span class="w"> </span><span class="p">(</span><span class="n">i</span><span class="w"> </span><span class="o">+=</span><span class="w"> </span><span class="mi">1</span><span class="p">)</span><span class="w"> </span><span class="n">sum</span><span class="w"> </span><span class="o">+=</span><span class="w"> </span><span class="n">i</span><span class="p">;</span>
<span class="w">        </span><span class="k">break</span><span class="w"> </span><span class="o">:</span><span class="n">blk</span><span class="w"> </span><span class="n">sum</span><span class="p">;</span>
<span class="w">    </span><span class="p">};</span>
<span class="w">    </span><span class="k">try</span><span class="w"> </span><span class="n">expect</span><span class="p">(</span><span class="n">count</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="mi">45</span><span class="p">);</span>
<span class="w">    </span><span class="k">try</span><span class="w"> </span><span class="n">expect</span><span class="p">(</span><span class="nb">@TypeOf</span><span class="p">(</span><span class="n">count</span><span class="p">)</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="kt">u32</span><span class="p">);</span>
<span class="p">}</span>
</code></pre></div>
<p>This can be seen as being equivalent to C's <code>i++</code>.</p>
<!--no_test-->
<div class="highlight"><pre><span></span><code><span class="n">blk</span><span class="o">:</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="kr">const</span><span class="w"> </span><span class="n">tmp</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">i</span><span class="p">;</span>
<span class="w">    </span><span class="n">i</span><span class="w"> </span><span class="o">+=</span><span class="w"> </span><span class="mi">1</span><span class="p">;</span>
<span class="w">    </span><span class="k">break</span><span class="w"> </span><span class="o">:</span><span class="n">blk</span><span class="w"> </span><span class="n">tmp</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></div>
<h2 id="labelled-loops">Labelled Loops<a class="headerlink" href="#labelled-loops" title="Permanent link">§</a></h2>
<p>Loops can be given labels, allowing you to <code>break</code> and <code>continue</code> to outer loops.</p>
<div class="highlight"><pre><span></span><code><span class="k">test</span><span class="w"> </span><span class="s">&quot;nested continue&quot;</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="kr">var</span><span class="w"> </span><span class="n">count</span><span class="o">:</span><span class="w"> </span><span class="kt">usize</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">0</span><span class="p">;</span>
<span class="w">    </span><span class="n">outer</span><span class="o">:</span><span class="w"> </span><span class="k">for</span><span class="w"> </span><span class="p">([</span><span class="n">_</span><span class="p">]</span><span class="kt">i32</span><span class="p">{</span><span class="w"> </span><span class="mi">1</span><span class="p">,</span><span class="w"> </span><span class="mi">2</span><span class="p">,</span><span class="w"> </span><span class="mi">3</span><span class="p">,</span><span class="w"> </span><span class="mi">4</span><span class="p">,</span><span class="w"> </span><span class="mi">5</span><span class="p">,</span><span class="w"> </span><span class="mi">6</span><span class="p">,</span><span class="w"> </span><span class="mi">7</span><span class="p">,</span><span class="w"> </span><span class="mi">8</span><span class="w"> </span><span class="p">})</span><span class="w"> </span><span class="o">|</span><span class="n">_</span><span class="o">|</span><span class="w"> </span><span class="p">{</span>
<span class="w">        </span><span class="k">for</span><span class="w"> </span><span class="p">([</span><span class="n">_</span><span class="p">]</span><span class="kt">i32</span><span class="p">{</span><span class="w"> </span><span class="mi">1</span><span class="p">,</span><span class="w"> </span><span class="mi">2</span><span class="p">,</span><span class="w"> </span><span class="mi">3</span><span class="p">,</span><span class="w"> </span><span class="mi">4</span><span class="p">,</span><span class="w"> </span><span class="mi">5</span><span class="w"> </span><span class="p">})</span><span class="w"> </span><span class="o">|</span><span class="n">_</span><span class="o">|</span><span class="w"> </span><span class="p">{</span>
<span class="w">            </span><span class="n">count</span><span class="w"> </span><span class="o">+=</span><span class="w"> </span><span class="mi">1</span><span class="p">;</span>
<span class="w">            </span><span class="k">continue</span><span class="w"> </span><span class="o">:</span><span class="n">outer</span><span class="p">;</span>
<span class="w">        </span><span class="p">}</span>
<span class="w">    </span><span class="p">}</span>
<span class="w">    </span><span class="k">try</span><span class="w"> </span><span class="n">expect</span><span class="p">(</span><span class="n">count</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="mi">8</span><span class="p">);</span>
<span class="p">}</span>
</code></pre></div>
<h2 id="loops-as-expressions">Loops as expressions<a class="headerlink" href="#loops-as-expressions" title="Permanent link">§</a></h2>
<p>Like <code>return</code>, <code>break</code> accepts a value. This can be used to yield a value from a loop. Loops in Zig also have an <code>else</code> branch on loops, which is evaluated when the loop is not exited from with a <code>break</code>.</p>
<div class="highlight"><pre><span></span><code><span class="k">fn</span><span class="w"> </span><span class="n">rangeHasNumber</span><span class="p">(</span><span class="n">begin</span><span class="o">:</span><span class="w"> </span><span class="kt">usize</span><span class="p">,</span><span class="w"> </span><span class="n">end</span><span class="o">:</span><span class="w"> </span><span class="kt">usize</span><span class="p">,</span><span class="w"> </span><span class="n">number</span><span class="o">:</span><span class="w"> </span><span class="kt">usize</span><span class="p">)</span><span class="w"> </span><span class="kt">bool</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="kr">var</span><span class="w"> </span><span class="n">i</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">begin</span><span class="p">;</span>
<span class="w">    </span><span class="k">return</span><span class="w"> </span><span class="k">while</span><span class="w"> </span><span class="p">(</span><span class="n">i</span><span class="w"> </span><span class="o">&lt;</span><span class="w"> </span><span class="n">end</span><span class="p">)</span><span class="w"> </span><span class="o">:</span><span class="w"> </span><span class="p">(</span><span class="n">i</span><span class="w"> </span><span class="o">+=</span><span class="w"> </span><span class="mi">1</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">        </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="n">i</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="n">number</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">            </span><span class="k">break</span><span class="w"> </span><span class="kc">true</span><span class="p">;</span>
<span class="w">        </span><span class="p">}</span>
<span class="w">    </span><span class="p">}</span><span class="w"> </span><span class="k">else</span><span class="w"> </span><span class="kc">false</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">test</span><span class="w"> </span><span class="s">&quot;while loop expression&quot;</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="k">try</span><span class="w"> </span><span class="n">expect</span><span class="p">(</span><span class="n">rangeHasNumber</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span><span class="w"> </span><span class="mi">10</span><span class="p">,</span><span class="w"> </span><span class="mi">3</span><span class="p">));</span>
<span class="p">}</span>
</code></pre></div>
<h2 id="optionals-t">Optionals <code>?T</code><a class="headerlink" href="#optionals-t" title="Permanent link">§</a></h2>
<p>Optionals use the syntax <code>?T</code> and are used to store the data <a href="https://ziglang.org/documentation/master/#null"><code>null</code></a>, or a value of type <code>T</code>.</p>
<div class="highlight"><pre><span></span><code><span class="k">test</span><span class="w"> </span><span class="s">&quot;optional&quot;</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="kr">var</span><span class="w"> </span><span class="n">found_index</span><span class="o">:</span><span class="w"> </span><span class="o">?</span><span class="kt">usize</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="kc">null</span><span class="p">;</span>
<span class="w">    </span><span class="kr">const</span><span class="w"> </span><span class="n">data</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">[</span><span class="n">_</span><span class="p">]</span><span class="kt">i32</span><span class="p">{</span><span class="w"> </span><span class="mi">1</span><span class="p">,</span><span class="w"> </span><span class="mi">2</span><span class="p">,</span><span class="w"> </span><span class="mi">3</span><span class="p">,</span><span class="w"> </span><span class="mi">4</span><span class="p">,</span><span class="w"> </span><span class="mi">5</span><span class="p">,</span><span class="w"> </span><span class="mi">6</span><span class="p">,</span><span class="w"> </span><span class="mi">7</span><span class="p">,</span><span class="w"> </span><span class="mi">8</span><span class="p">,</span><span class="w"> </span><span class="mi">12</span><span class="w"> </span><span class="p">};</span>
<span class="w">    </span><span class="k">for</span><span class="w"> </span><span class="p">(</span><span class="n">data</span><span class="p">,</span><span class="w"> </span><span class="mi">0</span><span class="p">..)</span><span class="w"> </span><span class="o">|</span><span class="n">v</span><span class="p">,</span><span class="w"> </span><span class="n">i</span><span class="o">|</span><span class="w"> </span><span class="p">{</span>
<span class="w">        </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="n">v</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="mi">10</span><span class="p">)</span><span class="w"> </span><span class="n">found_index</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">i</span><span class="p">;</span>
<span class="w">    </span><span class="p">}</span>
<span class="w">    </span><span class="k">try</span><span class="w"> </span><span class="n">expect</span><span class="p">(</span><span class="n">found_index</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="kc">null</span><span class="p">);</span>
<span class="p">}</span>
</code></pre></div>
<p>Optionals support the <code>orelse</code> expression, which acts when the optional is <a href="https://ziglang.org/documentation/master/#null"><code>null</code></a>. This unwraps the optional to its child type.</p>
<div class="highlight"><pre><span></span><code><span class="k">test</span><span class="w"> </span><span class="s">&quot;orelse&quot;</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="kr">var</span><span class="w"> </span><span class="n">a</span><span class="o">:</span><span class="w"> </span><span class="o">?</span><span class="kt">f32</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="kc">null</span><span class="p">;</span>
<span class="w">    </span><span class="kr">var</span><span class="w"> </span><span class="n">b</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">a</span><span class="w"> </span><span class="k">orelse</span><span class="w"> </span><span class="mi">0</span><span class="p">;</span>
<span class="w">    </span><span class="k">try</span><span class="w"> </span><span class="n">expect</span><span class="p">(</span><span class="n">b</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="mi">0</span><span class="p">);</span>
<span class="w">    </span><span class="k">try</span><span class="w"> </span><span class="n">expect</span><span class="p">(</span><span class="nb">@TypeOf</span><span class="p">(</span><span class="n">b</span><span class="p">)</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="kt">f32</span><span class="p">);</span>
<span class="p">}</span>
</code></pre></div>
<p><code>.?</code> is a shorthand for <code>orelse unreachable</code>. This is used for when you know it is impossible for an optional value to be null, and using this to unwrap a <a href="https://ziglang.org/documentation/master/#null"><code>null</code></a> value is detectable illegal behaviour.</p>
<div class="highlight"><pre><span></span><code><span class="k">test</span><span class="w"> </span><span class="s">&quot;orelse unreachable&quot;</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="kr">const</span><span class="w"> </span><span class="n">a</span><span class="o">:</span><span class="w"> </span><span class="o">?</span><span class="kt">f32</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">5</span><span class="p">;</span>
<span class="w">    </span><span class="kr">const</span><span class="w"> </span><span class="n">b</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">a</span><span class="w"> </span><span class="k">orelse</span><span class="w"> </span><span class="k">unreachable</span><span class="p">;</span>
<span class="w">    </span><span class="kr">const</span><span class="w"> </span><span class="n">c</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">a</span><span class="p">.</span><span class="o">?</span><span class="p">;</span>
<span class="w">    </span><span class="k">try</span><span class="w"> </span><span class="n">expect</span><span class="p">(</span><span class="n">b</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="n">c</span><span class="p">);</span>
<span class="w">    </span><span class="k">try</span><span class="w"> </span><span class="n">expect</span><span class="p">(</span><span class="nb">@TypeOf</span><span class="p">(</span><span class="n">c</span><span class="p">)</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="kt">f32</span><span class="p">);</span>
<span class="p">}</span>
</code></pre></div>
<p>Payload capturing works in many places for optionals, meaning that in the event that it is non-null we can "capture" its non-null value.</p>
<p>Here we use an <code>if</code> optional payload capture; a and b are equivalent here. <code>if (b) |value|</code> captures the value of <code>b</code> (in the cases where <code>b</code> is not null), and makes it available as <code>value</code>. As in the union example, the captured value is immutable, but we can still use a pointer capture to modify the value stored in <code>b</code>.</p>
<div class="highlight"><pre><span></span><code><span class="k">test</span><span class="w"> </span><span class="s">&quot;if optional payload capture&quot;</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="kr">const</span><span class="w"> </span><span class="n">a</span><span class="o">:</span><span class="w"> </span><span class="o">?</span><span class="kt">i32</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">5</span><span class="p">;</span>
<span class="w">    </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="n">a</span><span class="w"> </span><span class="o">!=</span><span class="w"> </span><span class="kc">null</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">        </span><span class="kr">const</span><span class="w"> </span><span class="n">value</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">a</span><span class="p">.</span><span class="o">?</span><span class="p">;</span>
<span class="w">        </span><span class="n">_</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">value</span><span class="p">;</span>
<span class="w">    </span><span class="p">}</span>

<span class="w">    </span><span class="kr">var</span><span class="w"> </span><span class="n">b</span><span class="o">:</span><span class="w"> </span><span class="o">?</span><span class="kt">i32</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">5</span><span class="p">;</span>
<span class="w">    </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="n">b</span><span class="p">)</span><span class="w"> </span><span class="o">|*</span><span class="n">value</span><span class="o">|</span><span class="w"> </span><span class="p">{</span>
<span class="w">        </span><span class="n">value</span><span class="p">.</span><span class="o">*</span><span class="w"> </span><span class="o">+=</span><span class="w"> </span><span class="mi">1</span><span class="p">;</span>
<span class="w">    </span><span class="p">}</span>
<span class="w">    </span><span class="k">try</span><span class="w"> </span><span class="n">expect</span><span class="p">(</span><span class="n">b</span><span class="p">.</span><span class="o">?</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="mi">6</span><span class="p">);</span>
<span class="p">}</span>
</code></pre></div>
<p>And with <code>while</code>:
<div class="highlight"><pre><span></span><code><span class="kr">var</span><span class="w"> </span><span class="n">numbers_left</span><span class="o">:</span><span class="w"> </span><span class="kt">u32</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">4</span><span class="p">;</span>
<span class="k">fn</span><span class="w"> </span><span class="n">eventuallyNullSequence</span><span class="p">()</span><span class="w"> </span><span class="o">?</span><span class="kt">u32</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="n">numbers_left</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="mi">0</span><span class="p">)</span><span class="w"> </span><span class="k">return</span><span class="w"> </span><span class="kc">null</span><span class="p">;</span>
<span class="w">    </span><span class="n">numbers_left</span><span class="w"> </span><span class="o">-=</span><span class="w"> </span><span class="mi">1</span><span class="p">;</span>
<span class="w">    </span><span class="k">return</span><span class="w"> </span><span class="n">numbers_left</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">test</span><span class="w"> </span><span class="s">&quot;while null capture&quot;</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="kr">var</span><span class="w"> </span><span class="n">sum</span><span class="o">:</span><span class="w"> </span><span class="kt">u32</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">0</span><span class="p">;</span>
<span class="w">    </span><span class="k">while</span><span class="w"> </span><span class="p">(</span><span class="n">eventuallyNullSequence</span><span class="p">())</span><span class="w"> </span><span class="o">|</span><span class="n">value</span><span class="o">|</span><span class="w"> </span><span class="p">{</span>
<span class="w">        </span><span class="n">sum</span><span class="w"> </span><span class="o">+=</span><span class="w"> </span><span class="n">value</span><span class="p">;</span>
<span class="w">    </span><span class="p">}</span>
<span class="w">    </span><span class="k">try</span><span class="w"> </span><span class="n">expect</span><span class="p">(</span><span class="n">sum</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="mi">6</span><span class="p">);</span><span class="w"> </span><span class="c1">// 3 + 2 + 1</span>
<span class="p">}</span>
</code></pre></div></p>
<p>Optional pointer and optional slice types do not take up any extra memory, compared to non-optional ones. This is because internally they use the 0 value of the pointer for <code>null</code>.</p>
<p>This is how null pointers in Zig work - they must be unwrapped to a non-optional before dereferencing, which stops null pointer dereferences from happening accidentally.</p>
<h2 id="comptime">Comptime<a class="headerlink" href="#comptime" title="Permanent link">§</a></h2>
<p>Blocks of code may be forcibly executed at compile time using the <a href="https://ziglang.org/documentation/master/#comptime"><code>comptime</code></a> keyword. In this example, the variables x and y are equivalent.</p>
<div class="highlight"><pre><span></span><code><span class="k">test</span><span class="w"> </span><span class="s">&quot;comptime blocks&quot;</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="kr">var</span><span class="w"> </span><span class="n">x</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="kr">comptime</span><span class="w"> </span><span class="n">fibonacci</span><span class="p">(</span><span class="mi">10</span><span class="p">);</span>
<span class="w">    </span><span class="n">_</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">x</span><span class="p">;</span>

<span class="w">    </span><span class="kr">var</span><span class="w"> </span><span class="n">y</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="kr">comptime</span><span class="w"> </span><span class="n">blk</span><span class="o">:</span><span class="w"> </span><span class="p">{</span>
<span class="w">        </span><span class="k">break</span><span class="w"> </span><span class="o">:</span><span class="n">blk</span><span class="w"> </span><span class="n">fibonacci</span><span class="p">(</span><span class="mi">10</span><span class="p">);</span>
<span class="w">    </span><span class="p">};</span>
<span class="w">    </span><span class="n">_</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">y</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></div>
<p>Integer literals are of the type <code>comptime_int</code>. These are special in that they have no size (they cannot be used at runtime!), and they have arbitrary precision. <code>comptime_int</code> values coerce to any integer type that can hold them. They also coerce to floats. Character literals are of this type.</p>
<div class="highlight"><pre><span></span><code><span class="k">test</span><span class="w"> </span><span class="s">&quot;comptime_int&quot;</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="kr">const</span><span class="w"> </span><span class="n">a</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">12</span><span class="p">;</span>
<span class="w">    </span><span class="kr">const</span><span class="w"> </span><span class="n">b</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">a</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="mi">10</span><span class="p">;</span>

<span class="w">    </span><span class="kr">const</span><span class="w"> </span><span class="n">c</span><span class="o">:</span><span class="w"> </span><span class="n">u4</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">a</span><span class="p">;</span>
<span class="w">    </span><span class="n">_</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">c</span><span class="p">;</span>
<span class="w">    </span><span class="kr">const</span><span class="w"> </span><span class="n">d</span><span class="o">:</span><span class="w"> </span><span class="kt">f32</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">b</span><span class="p">;</span>
<span class="w">    </span><span class="n">_</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">d</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></div>
<p><code>comptime_float</code> is also available, which internally is an <code>f128</code>. These cannot be coerced to integers, even if they hold an integer value.</p>
<p>Types in Zig are values of the type <code>type</code>. These are available at compile time. We have previously encountered them by checking <a href="https://ziglang.org/documentation/master/#TypeOf"><code>@TypeOf</code></a> and comparing with other types, but we can do more.</p>
<div class="highlight"><pre><span></span><code><span class="k">test</span><span class="w"> </span><span class="s">&quot;branching on types&quot;</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="kr">const</span><span class="w"> </span><span class="n">a</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">5</span><span class="p">;</span>
<span class="w">    </span><span class="kr">const</span><span class="w"> </span><span class="n">b</span><span class="o">:</span><span class="w"> </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="n">a</span><span class="w"> </span><span class="o">&lt;</span><span class="w"> </span><span class="mi">10</span><span class="p">)</span><span class="w"> </span><span class="kt">f32</span><span class="w"> </span><span class="k">else</span><span class="w"> </span><span class="kt">i32</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">5</span><span class="p">;</span>
<span class="w">    </span><span class="n">_</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">b</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></div>
<p>Function parameters in Zig can be tagged as being <a href="https://ziglang.org/documentation/master/#comptime"><code>comptime</code></a>. This means that the value passed to that function parameter must be known at compile time. Let's make a function that returns a type. Notice how this function is PascalCase, as it returns a type.</p>
<div class="highlight"><pre><span></span><code><span class="k">fn</span><span class="w"> </span><span class="n">Matrix</span><span class="p">(</span>
<span class="w">    </span><span class="kr">comptime</span><span class="w"> </span><span class="n">T</span><span class="o">:</span><span class="w"> </span><span class="kt">type</span><span class="p">,</span>
<span class="w">    </span><span class="kr">comptime</span><span class="w"> </span><span class="n">width</span><span class="o">:</span><span class="w"> </span><span class="kt">comptime_int</span><span class="p">,</span>
<span class="w">    </span><span class="kr">comptime</span><span class="w"> </span><span class="n">height</span><span class="o">:</span><span class="w"> </span><span class="kt">comptime_int</span><span class="p">,</span>
<span class="p">)</span><span class="w"> </span><span class="kt">type</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="k">return</span><span class="w"> </span><span class="p">[</span><span class="n">height</span><span class="p">][</span><span class="n">width</span><span class="p">]</span><span class="n">T</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">test</span><span class="w"> </span><span class="s">&quot;returning a type&quot;</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="k">try</span><span class="w"> </span><span class="n">expect</span><span class="p">(</span><span class="n">Matrix</span><span class="p">(</span><span class="kt">f32</span><span class="p">,</span><span class="w"> </span><span class="mi">4</span><span class="p">,</span><span class="w"> </span><span class="mi">4</span><span class="p">)</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="p">[</span><span class="mi">4</span><span class="p">][</span><span class="mi">4</span><span class="p">]</span><span class="kt">f32</span><span class="p">);</span>
<span class="p">}</span>
</code></pre></div>
<p>We can reflect upon types using the built-in <a href="https://ziglang.org/documentation/master/#typeInfo"><code>@typeInfo</code></a>, which takes in a <code>type</code> and returns a tagged union. This tagged union type can be found in <a href="https://ziglang.org/documentation/master/std/#std;builtin.Type"><code>std.builtin.Type</code></a> (info on how to make use of imports and std later).</p>
<div class="highlight"><pre><span></span><code><span class="k">fn</span><span class="w"> </span><span class="n">addSmallInts</span><span class="p">(</span><span class="kr">comptime</span><span class="w"> </span><span class="n">T</span><span class="o">:</span><span class="w"> </span><span class="kt">type</span><span class="p">,</span><span class="w"> </span><span class="n">a</span><span class="o">:</span><span class="w"> </span><span class="n">T</span><span class="p">,</span><span class="w"> </span><span class="n">b</span><span class="o">:</span><span class="w"> </span><span class="n">T</span><span class="p">)</span><span class="w"> </span><span class="n">T</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="k">return</span><span class="w"> </span><span class="k">switch</span><span class="w"> </span><span class="p">(</span><span class="nb">@typeInfo</span><span class="p">(</span><span class="n">T</span><span class="p">))</span><span class="w"> </span><span class="p">{</span>
<span class="w">        </span><span class="p">.</span><span class="n">ComptimeInt</span><span class="w"> </span><span class="o">=&gt;</span><span class="w"> </span><span class="n">a</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="n">b</span><span class="p">,</span>
<span class="w">        </span><span class="p">.</span><span class="n">Int</span><span class="w"> </span><span class="o">=&gt;</span><span class="w"> </span><span class="o">|</span><span class="n">info</span><span class="o">|</span><span class="w"> </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="n">info</span><span class="p">.</span><span class="n">bits</span><span class="w"> </span><span class="o">&lt;=</span><span class="w"> </span><span class="mi">16</span><span class="p">)</span>
<span class="w">            </span><span class="n">a</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="n">b</span>
<span class="w">        </span><span class="k">else</span>
<span class="w">            </span><span class="nb">@compileError</span><span class="p">(</span><span class="s">&quot;ints too large&quot;</span><span class="p">),</span>
<span class="w">        </span><span class="k">else</span><span class="w"> </span><span class="o">=&gt;</span><span class="w"> </span><span class="nb">@compileError</span><span class="p">(</span><span class="s">&quot;only ints accepted&quot;</span><span class="p">),</span>
<span class="w">    </span><span class="p">};</span>
<span class="p">}</span>

<span class="k">test</span><span class="w"> </span><span class="s">&quot;typeinfo switch&quot;</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="kr">const</span><span class="w"> </span><span class="n">x</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">addSmallInts</span><span class="p">(</span><span class="kt">u16</span><span class="p">,</span><span class="w"> </span><span class="mi">20</span><span class="p">,</span><span class="w"> </span><span class="mi">30</span><span class="p">);</span>
<span class="w">    </span><span class="k">try</span><span class="w"> </span><span class="n">expect</span><span class="p">(</span><span class="nb">@TypeOf</span><span class="p">(</span><span class="n">x</span><span class="p">)</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="kt">u16</span><span class="p">);</span>
<span class="w">    </span><span class="k">try</span><span class="w"> </span><span class="n">expect</span><span class="p">(</span><span class="n">x</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="mi">50</span><span class="p">);</span>
<span class="p">}</span>
</code></pre></div>
<p>We can use the <a href="https://ziglang.org/documentation/master/#Type"><code>@Type</code></a> function to create a type from a <a href="https://ziglang.org/documentation/master/#typeInfo"><code>@typeInfo</code></a>.</p>
<p>Here anonymous struct syntax is used with <code>.{}</code>, because the <code>T</code> in <code>T{}</code> can be inferred. Anonymous structs will be covered in detail later. In this example we will get a compile error if the <code>Int</code> tag isn't set.</p>
<div class="highlight"><pre><span></span><code><span class="k">fn</span><span class="w"> </span><span class="n">GetBiggerInt</span><span class="p">(</span><span class="kr">comptime</span><span class="w"> </span><span class="n">T</span><span class="o">:</span><span class="w"> </span><span class="kt">type</span><span class="p">)</span><span class="w"> </span><span class="kt">type</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="k">return</span><span class="w"> </span><span class="nb">@Type</span><span class="p">(.{</span>
<span class="w">        </span><span class="p">.</span><span class="n">Int</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">.{</span>
<span class="w">            </span><span class="p">.</span><span class="n">bits</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="nb">@typeInfo</span><span class="p">(</span><span class="n">T</span><span class="p">).</span><span class="n">Int</span><span class="p">.</span><span class="n">bits</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="mi">1</span><span class="p">,</span>
<span class="w">            </span><span class="p">.</span><span class="n">signedness</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="nb">@typeInfo</span><span class="p">(</span><span class="n">T</span><span class="p">).</span><span class="n">Int</span><span class="p">.</span><span class="n">signedness</span><span class="p">,</span>
<span class="w">        </span><span class="p">},</span>
<span class="w">    </span><span class="p">});</span>
<span class="p">}</span>

<span class="k">test</span><span class="w"> </span><span class="s">&quot;@Type&quot;</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="k">try</span><span class="w"> </span><span class="n">expect</span><span class="p">(</span><span class="n">GetBiggerInt</span><span class="p">(</span><span class="kt">u8</span><span class="p">)</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="n">u9</span><span class="p">);</span>
<span class="w">    </span><span class="k">try</span><span class="w"> </span><span class="n">expect</span><span class="p">(</span><span class="n">GetBiggerInt</span><span class="p">(</span><span class="n">i31</span><span class="p">)</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="kt">i32</span><span class="p">);</span>
<span class="p">}</span>
</code></pre></div>
<p>Returning a struct type is how you make generic data structures in Zig. The usage of <a href="https://ziglang.org/documentation/master/#This"><code>@This</code></a> is required here, which gets the type of the innermost struct, union, or enum. Here <a href="https://ziglang.org/documentation/master/std/#A;std:mem.eql"><code>std.mem.eql</code></a> is also used which compares two slices.</p>
<div class="highlight"><pre><span></span><code><span class="k">fn</span><span class="w"> </span><span class="n">Vec</span><span class="p">(</span>
<span class="w">    </span><span class="kr">comptime</span><span class="w"> </span><span class="n">count</span><span class="o">:</span><span class="w"> </span><span class="kt">comptime_int</span><span class="p">,</span>
<span class="w">    </span><span class="kr">comptime</span><span class="w"> </span><span class="n">T</span><span class="o">:</span><span class="w"> </span><span class="kt">type</span><span class="p">,</span>
<span class="p">)</span><span class="w"> </span><span class="kt">type</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="k">return</span><span class="w"> </span><span class="k">struct</span><span class="w"> </span><span class="p">{</span>
<span class="w">        </span><span class="n">data</span><span class="o">:</span><span class="w"> </span><span class="p">[</span><span class="n">count</span><span class="p">]</span><span class="n">T</span><span class="p">,</span>
<span class="w">        </span><span class="kr">const</span><span class="w"> </span><span class="n">Self</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="nb">@This</span><span class="p">();</span>

<span class="w">        </span><span class="k">fn</span><span class="w"> </span><span class="n">abs</span><span class="p">(</span><span class="n">self</span><span class="o">:</span><span class="w"> </span><span class="n">Self</span><span class="p">)</span><span class="w"> </span><span class="n">Self</span><span class="w"> </span><span class="p">{</span>
<span class="w">            </span><span class="kr">var</span><span class="w"> </span><span class="n">tmp</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">Self</span><span class="p">{</span><span class="w"> </span><span class="p">.</span><span class="n">data</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="kc">undefined</span><span class="w"> </span><span class="p">};</span>
<span class="w">            </span><span class="k">for</span><span class="w"> </span><span class="p">(</span><span class="n">self</span><span class="p">.</span><span class="n">data</span><span class="p">,</span><span class="w"> </span><span class="mi">0</span><span class="p">..)</span><span class="w"> </span><span class="o">|</span><span class="n">elem</span><span class="p">,</span><span class="w"> </span><span class="n">i</span><span class="o">|</span><span class="w"> </span><span class="p">{</span>
<span class="w">                </span><span class="n">tmp</span><span class="p">.</span><span class="n">data</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="n">elem</span><span class="w"> </span><span class="o">&lt;</span><span class="w"> </span><span class="mi">0</span><span class="p">)</span>
<span class="w">                    </span><span class="o">-</span><span class="n">elem</span>
<span class="w">                </span><span class="k">else</span>
<span class="w">                    </span><span class="n">elem</span><span class="p">;</span>
<span class="w">            </span><span class="p">}</span>
<span class="w">            </span><span class="k">return</span><span class="w"> </span><span class="n">tmp</span><span class="p">;</span>
<span class="w">        </span><span class="p">}</span>

<span class="w">        </span><span class="k">fn</span><span class="w"> </span><span class="n">init</span><span class="p">(</span><span class="n">data</span><span class="o">:</span><span class="w"> </span><span class="p">[</span><span class="n">count</span><span class="p">]</span><span class="n">T</span><span class="p">)</span><span class="w"> </span><span class="n">Self</span><span class="w"> </span><span class="p">{</span>
<span class="w">            </span><span class="k">return</span><span class="w"> </span><span class="n">Self</span><span class="p">{</span><span class="w"> </span><span class="p">.</span><span class="n">data</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">data</span><span class="w"> </span><span class="p">};</span>
<span class="w">        </span><span class="p">}</span>
<span class="w">    </span><span class="p">};</span>
<span class="p">}</span>

<span class="kr">const</span><span class="w"> </span><span class="n">eql</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="nb">@import</span><span class="p">(</span><span class="s">&quot;std&quot;</span><span class="p">).</span><span class="n">mem</span><span class="p">.</span><span class="n">eql</span><span class="p">;</span>

<span class="k">test</span><span class="w"> </span><span class="s">&quot;generic vector&quot;</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="kr">const</span><span class="w"> </span><span class="n">x</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">Vec</span><span class="p">(</span><span class="mi">3</span><span class="p">,</span><span class="w"> </span><span class="kt">f32</span><span class="p">).</span><span class="n">init</span><span class="p">([</span><span class="n">_</span><span class="p">]</span><span class="kt">f32</span><span class="p">{</span><span class="w"> </span><span class="mi">10</span><span class="p">,</span><span class="w"> </span><span class="o">-</span><span class="mi">10</span><span class="p">,</span><span class="w"> </span><span class="mi">5</span><span class="w"> </span><span class="p">});</span>
<span class="w">    </span><span class="kr">const</span><span class="w"> </span><span class="n">y</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">x</span><span class="p">.</span><span class="n">abs</span><span class="p">();</span>
<span class="w">    </span><span class="k">try</span><span class="w"> </span><span class="n">expect</span><span class="p">(</span><span class="n">eql</span><span class="p">(</span><span class="kt">f32</span><span class="p">,</span><span class="w"> </span><span class="o">&amp;</span><span class="n">y</span><span class="p">.</span><span class="n">data</span><span class="p">,</span><span class="w"> </span><span class="o">&amp;</span><span class="p">[</span><span class="n">_</span><span class="p">]</span><span class="kt">f32</span><span class="p">{</span><span class="w"> </span><span class="mi">10</span><span class="p">,</span><span class="w"> </span><span class="mi">10</span><span class="p">,</span><span class="w"> </span><span class="mi">5</span><span class="w"> </span><span class="p">}));</span>
<span class="p">}</span>
</code></pre></div>
<p>The types of function parameters can also be inferred by using <code>anytype</code> in place of a type. <a href="https://ziglang.org/documentation/master/#TypeOf"><code>@TypeOf</code></a> can then be used on the parameter.</p>
<div class="highlight"><pre><span></span><code><span class="k">fn</span><span class="w"> </span><span class="n">plusOne</span><span class="p">(</span><span class="n">x</span><span class="o">:</span><span class="w"> </span><span class="n">anytype</span><span class="p">)</span><span class="w"> </span><span class="nb">@TypeOf</span><span class="p">(</span><span class="n">x</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="k">return</span><span class="w"> </span><span class="n">x</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="mi">1</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">test</span><span class="w"> </span><span class="s">&quot;inferred function parameter&quot;</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="k">try</span><span class="w"> </span><span class="n">expect</span><span class="p">(</span><span class="n">plusOne</span><span class="p">(</span><span class="nb">@as</span><span class="p">(</span><span class="kt">u32</span><span class="p">,</span><span class="w"> </span><span class="mi">1</span><span class="p">))</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="mi">2</span><span class="p">);</span>
<span class="p">}</span>
</code></pre></div>
<p>Comptime also introduces the operators <code>++</code> and <code>**</code> for concatenating and repeating arrays and slices. These operators do not work at runtime.</p>
<div class="highlight"><pre><span></span><code><span class="k">test</span><span class="w"> </span><span class="s">&quot;++&quot;</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="kr">const</span><span class="w"> </span><span class="n">x</span><span class="o">:</span><span class="w"> </span><span class="p">[</span><span class="mi">4</span><span class="p">]</span><span class="kt">u8</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="kc">undefined</span><span class="p">;</span>
<span class="w">    </span><span class="kr">const</span><span class="w"> </span><span class="n">y</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">x</span><span class="p">[</span><span class="mi">0</span><span class="p">..];</span>

<span class="w">    </span><span class="kr">const</span><span class="w"> </span><span class="n">a</span><span class="o">:</span><span class="w"> </span><span class="p">[</span><span class="mi">6</span><span class="p">]</span><span class="kt">u8</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="kc">undefined</span><span class="p">;</span>
<span class="w">    </span><span class="kr">const</span><span class="w"> </span><span class="n">b</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">a</span><span class="p">[</span><span class="mi">0</span><span class="p">..];</span>

<span class="w">    </span><span class="kr">const</span><span class="w"> </span><span class="n">new</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">y</span><span class="w"> </span><span class="o">++</span><span class="w"> </span><span class="n">b</span><span class="p">;</span>
<span class="w">    </span><span class="k">try</span><span class="w"> </span><span class="n">expect</span><span class="p">(</span><span class="n">new</span><span class="p">.</span><span class="n">len</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="mi">10</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">test</span><span class="w"> </span><span class="s">&quot;**&quot;</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="kr">const</span><span class="w"> </span><span class="n">pattern</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">[</span><span class="n">_</span><span class="p">]</span><span class="kt">u8</span><span class="p">{</span><span class="w"> </span><span class="mh">0xCC</span><span class="p">,</span><span class="w"> </span><span class="mh">0xAA</span><span class="w"> </span><span class="p">};</span>
<span class="w">    </span><span class="kr">const</span><span class="w"> </span><span class="n">memory</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">pattern</span><span class="w"> </span><span class="o">**</span><span class="w"> </span><span class="mi">3</span><span class="p">;</span>
<span class="w">    </span><span class="k">try</span><span class="w"> </span><span class="n">expect</span><span class="p">(</span><span class="n">eql</span><span class="p">(</span><span class="kt">u8</span><span class="p">,</span><span class="w"> </span><span class="o">&amp;</span><span class="n">memory</span><span class="p">,</span><span class="w"> </span><span class="o">&amp;</span><span class="p">[</span><span class="n">_</span><span class="p">]</span><span class="kt">u8</span><span class="p">{</span><span class="w"> </span><span class="mh">0xCC</span><span class="p">,</span><span class="w"> </span><span class="mh">0xAA</span><span class="p">,</span><span class="w"> </span><span class="mh">0xCC</span><span class="p">,</span><span class="w"> </span><span class="mh">0xAA</span><span class="p">,</span><span class="w"> </span><span class="mh">0xCC</span><span class="p">,</span><span class="w"> </span><span class="mh">0xAA</span><span class="w"> </span><span class="p">}));</span>
<span class="p">}</span>
</code></pre></div>
<h2 id="payload-captures-n">Payload Captures <code>|n|</code><a class="headerlink" href="#payload-captures-n" title="Permanent link">§</a></h2>
<p>Payload captures use the syntax <code>|value|</code> and appear in many places, some of which we've seen already. Wherever they appear, they are used to "capture" the value from something.</p>
<p>With if statements and optionals.
<div class="highlight"><pre><span></span><code><span class="k">test</span><span class="w"> </span><span class="s">&quot;optional-if&quot;</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="kr">var</span><span class="w"> </span><span class="n">maybe_num</span><span class="o">:</span><span class="w"> </span><span class="o">?</span><span class="kt">usize</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">10</span><span class="p">;</span>
<span class="w">    </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="n">maybe_num</span><span class="p">)</span><span class="w"> </span><span class="o">|</span><span class="n">n</span><span class="o">|</span><span class="w"> </span><span class="p">{</span>
<span class="w">        </span><span class="k">try</span><span class="w"> </span><span class="n">expect</span><span class="p">(</span><span class="nb">@TypeOf</span><span class="p">(</span><span class="n">n</span><span class="p">)</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="kt">usize</span><span class="p">);</span>
<span class="w">        </span><span class="k">try</span><span class="w"> </span><span class="n">expect</span><span class="p">(</span><span class="n">n</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="mi">10</span><span class="p">);</span>
<span class="w">    </span><span class="p">}</span><span class="w"> </span><span class="k">else</span><span class="w"> </span><span class="p">{</span>
<span class="w">        </span><span class="k">unreachable</span><span class="p">;</span>
<span class="w">    </span><span class="p">}</span>
<span class="p">}</span>
</code></pre></div></p>
<p>With if statements and error unions. The else with the error capture is required here.
<div class="highlight"><pre><span></span><code><span class="k">test</span><span class="w"> </span><span class="s">&quot;error union if&quot;</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="kr">var</span><span class="w"> </span><span class="n">ent_num</span><span class="o">:</span><span class="w"> </span><span class="k">error</span><span class="p">{</span><span class="n">UnknownEntity</span><span class="p">}</span><span class="o">!</span><span class="kt">u32</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">5</span><span class="p">;</span>
<span class="w">    </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="n">ent_num</span><span class="p">)</span><span class="w"> </span><span class="o">|</span><span class="n">entity</span><span class="o">|</span><span class="w"> </span><span class="p">{</span>
<span class="w">        </span><span class="k">try</span><span class="w"> </span><span class="n">expect</span><span class="p">(</span><span class="nb">@TypeOf</span><span class="p">(</span><span class="n">entity</span><span class="p">)</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="kt">u32</span><span class="p">);</span>
<span class="w">        </span><span class="k">try</span><span class="w"> </span><span class="n">expect</span><span class="p">(</span><span class="n">entity</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="mi">5</span><span class="p">);</span>
<span class="w">    </span><span class="p">}</span><span class="w"> </span><span class="k">else</span><span class="w"> </span><span class="o">|</span><span class="n">err</span><span class="o">|</span><span class="w"> </span><span class="p">{</span>
<span class="w">        </span><span class="n">_</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">err</span><span class="w"> </span><span class="k">catch</span><span class="w"> </span><span class="p">{};</span>
<span class="w">        </span><span class="k">unreachable</span><span class="p">;</span>
<span class="w">    </span><span class="p">}</span>
<span class="p">}</span>
</code></pre></div></p>
<p>With while loops and optionals. This may have an else block.
<div class="highlight"><pre><span></span><code><span class="k">test</span><span class="w"> </span><span class="s">&quot;while optional&quot;</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="kr">var</span><span class="w"> </span><span class="n">i</span><span class="o">:</span><span class="w"> </span><span class="o">?</span><span class="kt">u32</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">10</span><span class="p">;</span>
<span class="w">    </span><span class="k">while</span><span class="w"> </span><span class="p">(</span><span class="n">i</span><span class="p">)</span><span class="w"> </span><span class="o">|</span><span class="n">num</span><span class="o">|</span><span class="w"> </span><span class="o">:</span><span class="w"> </span><span class="p">(</span><span class="n">i</span><span class="p">.</span><span class="o">?</span><span class="w"> </span><span class="o">-=</span><span class="w"> </span><span class="mi">1</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">        </span><span class="k">try</span><span class="w"> </span><span class="n">expect</span><span class="p">(</span><span class="nb">@TypeOf</span><span class="p">(</span><span class="n">num</span><span class="p">)</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="kt">u32</span><span class="p">);</span>
<span class="w">        </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="n">num</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="mi">1</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">            </span><span class="n">i</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="kc">null</span><span class="p">;</span>
<span class="w">            </span><span class="k">break</span><span class="p">;</span>
<span class="w">        </span><span class="p">}</span>
<span class="w">    </span><span class="p">}</span>
<span class="w">    </span><span class="k">try</span><span class="w"> </span><span class="n">expect</span><span class="p">(</span><span class="n">i</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="kc">null</span><span class="p">);</span>
<span class="p">}</span>
</code></pre></div></p>
<p>With while loops and error unions. The else with the error capture is required here.</p>
<div class="highlight"><pre><span></span><code><span class="kr">var</span><span class="w"> </span><span class="n">numbers_left2</span><span class="o">:</span><span class="w"> </span><span class="kt">u32</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="kc">undefined</span><span class="p">;</span>

<span class="k">fn</span><span class="w"> </span><span class="n">eventuallyErrorSequence</span><span class="p">()</span><span class="w"> </span><span class="o">!</span><span class="kt">u32</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="k">return</span><span class="w"> </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="n">numbers_left2</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="mi">0</span><span class="p">)</span><span class="w"> </span><span class="k">error</span><span class="p">.</span><span class="n">ReachedZero</span><span class="w"> </span><span class="k">else</span><span class="w"> </span><span class="n">blk</span><span class="o">:</span><span class="w"> </span><span class="p">{</span>
<span class="w">        </span><span class="n">numbers_left2</span><span class="w"> </span><span class="o">-=</span><span class="w"> </span><span class="mi">1</span><span class="p">;</span>
<span class="w">        </span><span class="k">break</span><span class="w"> </span><span class="o">:</span><span class="n">blk</span><span class="w"> </span><span class="n">numbers_left2</span><span class="p">;</span>
<span class="w">    </span><span class="p">};</span>
<span class="p">}</span>

<span class="k">test</span><span class="w"> </span><span class="s">&quot;while error union capture&quot;</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="kr">var</span><span class="w"> </span><span class="n">sum</span><span class="o">:</span><span class="w"> </span><span class="kt">u32</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">0</span><span class="p">;</span>
<span class="w">    </span><span class="n">numbers_left2</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">3</span><span class="p">;</span>
<span class="w">    </span><span class="k">while</span><span class="w"> </span><span class="p">(</span><span class="n">eventuallyErrorSequence</span><span class="p">())</span><span class="w"> </span><span class="o">|</span><span class="n">value</span><span class="o">|</span><span class="w"> </span><span class="p">{</span>
<span class="w">        </span><span class="n">sum</span><span class="w"> </span><span class="o">+=</span><span class="w"> </span><span class="n">value</span><span class="p">;</span>
<span class="w">    </span><span class="p">}</span><span class="w"> </span><span class="k">else</span><span class="w"> </span><span class="o">|</span><span class="n">err</span><span class="o">|</span><span class="w"> </span><span class="p">{</span>
<span class="w">        </span><span class="k">try</span><span class="w"> </span><span class="n">expect</span><span class="p">(</span><span class="n">err</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="k">error</span><span class="p">.</span><span class="n">ReachedZero</span><span class="p">);</span>
<span class="w">    </span><span class="p">}</span>
<span class="p">}</span>
</code></pre></div>
<p>For loops.
<div class="highlight"><pre><span></span><code><span class="k">test</span><span class="w"> </span><span class="s">&quot;for capture&quot;</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="kr">const</span><span class="w"> </span><span class="n">x</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">[</span><span class="n">_</span><span class="p">]</span><span class="n">i8</span><span class="p">{</span><span class="w"> </span><span class="mi">1</span><span class="p">,</span><span class="w"> </span><span class="mi">5</span><span class="p">,</span><span class="w"> </span><span class="mi">120</span><span class="p">,</span><span class="w"> </span><span class="o">-</span><span class="mi">5</span><span class="w"> </span><span class="p">};</span>
<span class="w">    </span><span class="k">for</span><span class="w"> </span><span class="p">(</span><span class="n">x</span><span class="p">)</span><span class="w"> </span><span class="o">|</span><span class="n">v</span><span class="o">|</span><span class="w"> </span><span class="k">try</span><span class="w"> </span><span class="n">expect</span><span class="p">(</span><span class="nb">@TypeOf</span><span class="p">(</span><span class="n">v</span><span class="p">)</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="n">i8</span><span class="p">);</span>
<span class="p">}</span>
</code></pre></div></p>
<p>Switch cases on tagged unions.
<div class="highlight"><pre><span></span><code><span class="kr">const</span><span class="w"> </span><span class="n">Info</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="k">union</span><span class="p">(</span><span class="k">enum</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="n">a</span><span class="o">:</span><span class="w"> </span><span class="kt">u32</span><span class="p">,</span>
<span class="w">    </span><span class="n">b</span><span class="o">:</span><span class="w"> </span><span class="p">[]</span><span class="kr">const</span><span class="w"> </span><span class="kt">u8</span><span class="p">,</span>
<span class="w">    </span><span class="n">c</span><span class="p">,</span>
<span class="w">    </span><span class="n">d</span><span class="o">:</span><span class="w"> </span><span class="kt">u32</span><span class="p">,</span>
<span class="p">};</span>

<span class="k">test</span><span class="w"> </span><span class="s">&quot;switch capture&quot;</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="kr">var</span><span class="w"> </span><span class="n">b</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">Info</span><span class="p">{</span><span class="w"> </span><span class="p">.</span><span class="n">a</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">10</span><span class="w"> </span><span class="p">};</span>
<span class="w">    </span><span class="kr">const</span><span class="w"> </span><span class="n">x</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="k">switch</span><span class="w"> </span><span class="p">(</span><span class="n">b</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">        </span><span class="p">.</span><span class="n">b</span><span class="w"> </span><span class="o">=&gt;</span><span class="w"> </span><span class="o">|</span><span class="n">str</span><span class="o">|</span><span class="w"> </span><span class="n">blk</span><span class="o">:</span><span class="w"> </span><span class="p">{</span>
<span class="w">            </span><span class="k">try</span><span class="w"> </span><span class="n">expect</span><span class="p">(</span><span class="nb">@TypeOf</span><span class="p">(</span><span class="n">str</span><span class="p">)</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="p">[]</span><span class="kr">const</span><span class="w"> </span><span class="kt">u8</span><span class="p">);</span>
<span class="w">            </span><span class="k">break</span><span class="w"> </span><span class="o">:</span><span class="n">blk</span><span class="w"> </span><span class="mi">1</span><span class="p">;</span>
<span class="w">        </span><span class="p">},</span>
<span class="w">        </span><span class="p">.</span><span class="n">c</span><span class="w"> </span><span class="o">=&gt;</span><span class="w"> </span><span class="mi">2</span><span class="p">,</span>
<span class="w">        </span><span class="c1">//if these are of the same type, they</span>
<span class="w">        </span><span class="c1">//may be inside the same capture group</span>
<span class="w">        </span><span class="p">.</span><span class="n">a</span><span class="p">,</span><span class="w"> </span><span class="p">.</span><span class="n">d</span><span class="w"> </span><span class="o">=&gt;</span><span class="w"> </span><span class="o">|</span><span class="n">num</span><span class="o">|</span><span class="w"> </span><span class="n">blk</span><span class="o">:</span><span class="w"> </span><span class="p">{</span>
<span class="w">            </span><span class="k">try</span><span class="w"> </span><span class="n">expect</span><span class="p">(</span><span class="nb">@TypeOf</span><span class="p">(</span><span class="n">num</span><span class="p">)</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="kt">u32</span><span class="p">);</span>
<span class="w">            </span><span class="k">break</span><span class="w"> </span><span class="o">:</span><span class="n">blk</span><span class="w"> </span><span class="n">num</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="mi">2</span><span class="p">;</span>
<span class="w">        </span><span class="p">},</span>
<span class="w">    </span><span class="p">};</span>
<span class="w">    </span><span class="k">try</span><span class="w"> </span><span class="n">expect</span><span class="p">(</span><span class="n">x</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="mi">20</span><span class="p">);</span>
<span class="p">}</span>
</code></pre></div></p>
<p>As we saw in the Union and Optional sections above, values captured with the <code>|val|</code> syntax are immutable (similar to function arguments), but we can use pointer capture to modify the original values. This captures the values as pointers that are themselves still immutable, but because the value is now a pointer, we can modify the original value by dereferencing it:</p>
<div class="highlight"><pre><span></span><code><span class="k">test</span><span class="w"> </span><span class="s">&quot;for with pointer capture&quot;</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="kr">var</span><span class="w"> </span><span class="n">data</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">[</span><span class="n">_</span><span class="p">]</span><span class="kt">u8</span><span class="p">{</span><span class="w"> </span><span class="mi">1</span><span class="p">,</span><span class="w"> </span><span class="mi">2</span><span class="p">,</span><span class="w"> </span><span class="mi">3</span><span class="w"> </span><span class="p">};</span>
<span class="w">    </span><span class="k">for</span><span class="w"> </span><span class="p">(</span><span class="o">&amp;</span><span class="n">data</span><span class="p">)</span><span class="w"> </span><span class="o">|*</span><span class="n">byte</span><span class="o">|</span><span class="w"> </span><span class="n">byte</span><span class="p">.</span><span class="o">*</span><span class="w"> </span><span class="o">+=</span><span class="w"> </span><span class="mi">1</span><span class="p">;</span>
<span class="w">    </span><span class="k">try</span><span class="w"> </span><span class="n">expect</span><span class="p">(</span><span class="n">eql</span><span class="p">(</span><span class="kt">u8</span><span class="p">,</span><span class="w"> </span><span class="o">&amp;</span><span class="n">data</span><span class="p">,</span><span class="w"> </span><span class="o">&amp;</span><span class="p">[</span><span class="n">_</span><span class="p">]</span><span class="kt">u8</span><span class="p">{</span><span class="w"> </span><span class="mi">2</span><span class="p">,</span><span class="w"> </span><span class="mi">3</span><span class="p">,</span><span class="w"> </span><span class="mi">4</span><span class="w"> </span><span class="p">}));</span>
<span class="p">}</span>
</code></pre></div>
<h2 id="inline-loops">Inline Loops<a class="headerlink" href="#inline-loops" title="Permanent link">§</a></h2>
<p><code>inline</code> loops are unrolled, and allow some things to happen which only work at compile time. Here we use a <a href="https://ziglang.org/documentation/master/#inline-for"><code>for</code></a>, but a <a href="https://ziglang.org/documentation/master/#inline-while"><code>while</code></a> works similarly.
<div class="highlight"><pre><span></span><code><span class="k">test</span><span class="w"> </span><span class="s">&quot;inline for&quot;</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="kr">const</span><span class="w"> </span><span class="n">types</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">[</span><span class="n">_</span><span class="p">]</span><span class="kt">type</span><span class="p">{</span><span class="w"> </span><span class="kt">i32</span><span class="p">,</span><span class="w"> </span><span class="kt">f32</span><span class="p">,</span><span class="w"> </span><span class="kt">u8</span><span class="p">,</span><span class="w"> </span><span class="kt">bool</span><span class="w"> </span><span class="p">};</span>
<span class="w">    </span><span class="kr">var</span><span class="w"> </span><span class="n">sum</span><span class="o">:</span><span class="w"> </span><span class="kt">usize</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">0</span><span class="p">;</span>
<span class="w">    </span><span class="kr">inline</span><span class="w"> </span><span class="k">for</span><span class="w"> </span><span class="p">(</span><span class="n">types</span><span class="p">)</span><span class="w"> </span><span class="o">|</span><span class="n">T</span><span class="o">|</span><span class="w"> </span><span class="n">sum</span><span class="w"> </span><span class="o">+=</span><span class="w"> </span><span class="nb">@sizeOf</span><span class="p">(</span><span class="n">T</span><span class="p">);</span>
<span class="w">    </span><span class="k">try</span><span class="w"> </span><span class="n">expect</span><span class="p">(</span><span class="n">sum</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="mi">10</span><span class="p">);</span>
<span class="p">}</span>
</code></pre></div></p>
<p>Using these for performance reasons is inadvisable unless you've tested that explicitly unrolling is faster; the compiler tends to make better decisions here than you.</p>
<h2 id="opaque">Opaque<a class="headerlink" href="#opaque" title="Permanent link">§</a></h2>
<p><a href="https://ziglang.org/documentation/master/#opaque"><code>opaque</code></a> types in Zig have an unknown (albeit non-zero) size and alignment. Because of this these data types cannot be stored directly. These are used to maintain type safety with pointers to types that we don't have information about.</p>
<!--fail_test-->
<p><div class="highlight"><pre><span></span><code><span class="kr">const</span><span class="w"> </span><span class="n">Window</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">opaque</span><span class="w"> </span><span class="p">{};</span>
<span class="kr">const</span><span class="w"> </span><span class="n">Button</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">opaque</span><span class="w"> </span><span class="p">{};</span>

<span class="kr">extern</span><span class="w"> </span><span class="k">fn</span><span class="w"> </span><span class="n">show_window</span><span class="p">(</span><span class="o">*</span><span class="n">Window</span><span class="p">)</span><span class="w"> </span><span class="n">callconv</span><span class="p">(.</span><span class="n">C</span><span class="p">)</span><span class="w"> </span><span class="kt">void</span><span class="p">;</span>

<span class="k">test</span><span class="w"> </span><span class="s">&quot;opaque&quot;</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="kr">var</span><span class="w"> </span><span class="n">main_window</span><span class="o">:</span><span class="w"> </span><span class="o">*</span><span class="n">Window</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="kc">undefined</span><span class="p">;</span>
<span class="w">    </span><span class="n">show_window</span><span class="p">(</span><span class="n">main_window</span><span class="p">);</span>

<span class="w">    </span><span class="kr">var</span><span class="w"> </span><span class="n">ok_button</span><span class="o">:</span><span class="w"> </span><span class="o">*</span><span class="n">Button</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="kc">undefined</span><span class="p">;</span>
<span class="w">    </span><span class="n">show_window</span><span class="p">(</span><span class="n">ok_button</span><span class="p">);</span>
<span class="p">}</span>
</code></pre></div>
<div class="highlight"><pre><span></span><code>tests.zig:11:17: error: expected type &#39;*tests.Window&#39;, found &#39;*tests.Button&#39;
    show_window(ok_button);
                ^~~~~~~~~
tests.zig:11:17: note: pointer type child &#39;tests.Button&#39; cannot cast into pointer type child &#39;tests.Window&#39;
tests.zig:2:16: note: opaque declared here
const Button = opaque {};
               ^~~~~~~~~
tests.zig:1:16: note: opaque declared here
const Window = opaque {};
               ^~~~~~~~~
tests.zig:4:23: note: parameter type declared here
extern fn show_window(*Window) callconv(.C) void;
                      ^~~~~~~
</code></pre></div></p>
<p>Opaque types may have declarations in their definitions (the same as structs, enums and unions).</p>
<!--no_test-->
<div class="highlight"><pre><span></span><code><span class="kr">const</span><span class="w"> </span><span class="n">Window</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">opaque</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="k">fn</span><span class="w"> </span><span class="n">show</span><span class="p">(</span><span class="n">self</span><span class="o">:</span><span class="w"> </span><span class="o">*</span><span class="n">Window</span><span class="p">)</span><span class="w"> </span><span class="kt">void</span><span class="w"> </span><span class="p">{</span>
<span class="w">        </span><span class="n">show_window</span><span class="p">(</span><span class="n">self</span><span class="p">);</span>
<span class="w">    </span><span class="p">}</span>
<span class="p">};</span>

<span class="kr">extern</span><span class="w"> </span><span class="k">fn</span><span class="w"> </span><span class="n">show_window</span><span class="p">(</span><span class="o">*</span><span class="n">Window</span><span class="p">)</span><span class="w"> </span><span class="n">callconv</span><span class="p">(.</span><span class="n">C</span><span class="p">)</span><span class="w"> </span><span class="kt">void</span><span class="p">;</span>

<span class="k">test</span><span class="w"> </span><span class="s">&quot;opaque with declarations&quot;</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="kr">var</span><span class="w"> </span><span class="n">main_window</span><span class="o">:</span><span class="w"> </span><span class="o">*</span><span class="n">Window</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="kc">undefined</span><span class="p">;</span>
<span class="w">    </span><span class="n">main_window</span><span class="p">.</span><span class="n">show</span><span class="p">();</span>
<span class="p">}</span>
</code></pre></div>
<p>The typical usecase of opaque is to maintain type safety when interoperating with C code that does not expose complete type information.</p>
<h2 id="anonymous-structs">Anonymous Structs <code>.{}</code><a class="headerlink" href="#anonymous-structs" title="Permanent link">§</a></h2>
<p>The struct type may be omitted from a struct literal. These literals may coerce to other struct types.</p>
<div class="highlight"><pre><span></span><code><span class="k">test</span><span class="w"> </span><span class="s">&quot;anonymous struct literal&quot;</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="kr">const</span><span class="w"> </span><span class="n">Point</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="k">struct</span><span class="w"> </span><span class="p">{</span><span class="w"> </span><span class="n">x</span><span class="o">:</span><span class="w"> </span><span class="kt">i32</span><span class="p">,</span><span class="w"> </span><span class="n">y</span><span class="o">:</span><span class="w"> </span><span class="kt">i32</span><span class="w"> </span><span class="p">};</span>

<span class="w">    </span><span class="kr">var</span><span class="w"> </span><span class="n">pt</span><span class="o">:</span><span class="w"> </span><span class="n">Point</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">.{</span>
<span class="w">        </span><span class="p">.</span><span class="n">x</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">13</span><span class="p">,</span>
<span class="w">        </span><span class="p">.</span><span class="n">y</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">67</span><span class="p">,</span>
<span class="w">    </span><span class="p">};</span>
<span class="w">    </span><span class="k">try</span><span class="w"> </span><span class="n">expect</span><span class="p">(</span><span class="n">pt</span><span class="p">.</span><span class="n">x</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="mi">13</span><span class="p">);</span>
<span class="w">    </span><span class="k">try</span><span class="w"> </span><span class="n">expect</span><span class="p">(</span><span class="n">pt</span><span class="p">.</span><span class="n">y</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="mi">67</span><span class="p">);</span>
<span class="p">}</span>
</code></pre></div>
<p>Anonymous structs may be completely anonymous i.e. without being coerced to another struct type.</p>
<div class="highlight"><pre><span></span><code><span class="k">test</span><span class="w"> </span><span class="s">&quot;fully anonymous struct&quot;</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="k">try</span><span class="w"> </span><span class="n">dump</span><span class="p">(.{</span>
<span class="w">        </span><span class="p">.</span><span class="n">int</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="nb">@as</span><span class="p">(</span><span class="kt">u32</span><span class="p">,</span><span class="w"> </span><span class="mi">1234</span><span class="p">),</span>
<span class="w">        </span><span class="p">.</span><span class="n">float</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="nb">@as</span><span class="p">(</span><span class="kt">f64</span><span class="p">,</span><span class="w"> </span><span class="mf">12.34</span><span class="p">),</span>
<span class="w">        </span><span class="p">.</span><span class="n">b</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="kc">true</span><span class="p">,</span>
<span class="w">        </span><span class="p">.</span><span class="n">s</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="s">&quot;hi&quot;</span><span class="p">,</span>
<span class="w">    </span><span class="p">});</span>
<span class="p">}</span>

<span class="k">fn</span><span class="w"> </span><span class="n">dump</span><span class="p">(</span><span class="n">args</span><span class="o">:</span><span class="w"> </span><span class="n">anytype</span><span class="p">)</span><span class="w"> </span><span class="o">!</span><span class="kt">void</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="k">try</span><span class="w"> </span><span class="n">expect</span><span class="p">(</span><span class="n">args</span><span class="p">.</span><span class="n">int</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="mi">1234</span><span class="p">);</span>
<span class="w">    </span><span class="k">try</span><span class="w"> </span><span class="n">expect</span><span class="p">(</span><span class="n">args</span><span class="p">.</span><span class="n">float</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="mf">12.34</span><span class="p">);</span>
<span class="w">    </span><span class="k">try</span><span class="w"> </span><span class="n">expect</span><span class="p">(</span><span class="n">args</span><span class="p">.</span><span class="n">b</span><span class="p">);</span>
<span class="w">    </span><span class="k">try</span><span class="w"> </span><span class="n">expect</span><span class="p">(</span><span class="n">args</span><span class="p">.</span><span class="n">s</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="s">&#39;h&#39;</span><span class="p">);</span>
<span class="w">    </span><span class="k">try</span><span class="w"> </span><span class="n">expect</span><span class="p">(</span><span class="n">args</span><span class="p">.</span><span class="n">s</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="s">&#39;i&#39;</span><span class="p">);</span>
<span class="p">}</span>
</code></pre></div>
<!-- TODO: mention tuple slicing when it's implemented -->

<p>Anonymous structs without field names may be created, and are referred to as <strong>tuples</strong>. These have many of the properties that arrays do; tuples can be iterated over, indexed, can be used with the <code>++</code> and <code>**</code> operators, and have a len field. Internally, these have numbered field names starting at <code>"0"</code>, which may be accessed with the special syntax <code>@"0"</code> which acts as an escape for the syntax - things inside <code>@""</code> are always recognised as identifiers.</p>
<p>An <code>inline</code> loop must be used to iterate over the tuple here, as the type of each tuple field may differ.</p>
<div class="highlight"><pre><span></span><code><span class="k">test</span><span class="w"> </span><span class="s">&quot;tuple&quot;</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="kr">const</span><span class="w"> </span><span class="n">values</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">.{</span>
<span class="w">        </span><span class="nb">@as</span><span class="p">(</span><span class="kt">u32</span><span class="p">,</span><span class="w"> </span><span class="mi">1234</span><span class="p">),</span>
<span class="w">        </span><span class="nb">@as</span><span class="p">(</span><span class="kt">f64</span><span class="p">,</span><span class="w"> </span><span class="mf">12.34</span><span class="p">),</span>
<span class="w">        </span><span class="kc">true</span><span class="p">,</span>
<span class="w">        </span><span class="s">&quot;hi&quot;</span><span class="p">,</span>
<span class="w">    </span><span class="p">}</span><span class="w"> </span><span class="o">++</span><span class="w"> </span><span class="p">.{</span><span class="kc">false</span><span class="p">}</span><span class="w"> </span><span class="o">**</span><span class="w"> </span><span class="mi">2</span><span class="p">;</span>
<span class="w">    </span><span class="k">try</span><span class="w"> </span><span class="n">expect</span><span class="p">(</span><span class="n">values</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="mi">1234</span><span class="p">);</span>
<span class="w">    </span><span class="k">try</span><span class="w"> </span><span class="n">expect</span><span class="p">(</span><span class="n">values</span><span class="p">[</span><span class="mi">4</span><span class="p">]</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="kc">false</span><span class="p">);</span>
<span class="w">    </span><span class="kr">inline</span><span class="w"> </span><span class="k">for</span><span class="w"> </span><span class="p">(</span><span class="n">values</span><span class="p">,</span><span class="w"> </span><span class="mi">0</span><span class="p">..)</span><span class="w"> </span><span class="o">|</span><span class="n">v</span><span class="p">,</span><span class="w"> </span><span class="n">i</span><span class="o">|</span><span class="w"> </span><span class="p">{</span>
<span class="w">        </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="n">i</span><span class="w"> </span><span class="o">!=</span><span class="w"> </span><span class="mi">2</span><span class="p">)</span><span class="w"> </span><span class="k">continue</span><span class="p">;</span>
<span class="w">        </span><span class="k">try</span><span class="w"> </span><span class="n">expect</span><span class="p">(</span><span class="n">v</span><span class="p">);</span>
<span class="w">    </span><span class="p">}</span>
<span class="w">    </span><span class="k">try</span><span class="w"> </span><span class="n">expect</span><span class="p">(</span><span class="n">values</span><span class="p">.</span><span class="n">len</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="mi">6</span><span class="p">);</span>
<span class="w">    </span><span class="k">try</span><span class="w"> </span><span class="n">expect</span><span class="p">(</span><span class="n">values</span><span class="p">.</span><span class="err">@</span><span class="s">&quot;3&quot;</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="s">&#39;h&#39;</span><span class="p">);</span>
<span class="p">}</span>
</code></pre></div>
<h2 id="sentinel-termination-ntt-tt-and-tt">Sentinel Termination: <code>[N:t]T</code>, <code>[:t]T</code>, and <code>[*:t]T</code><a class="headerlink" href="#sentinel-termination-ntt-tt-and-tt" title="Permanent link">§</a></h2>
<p>Arrays, slices and many pointers may be terminated by a value of their child type. This is known as sentinel termination. These follow the syntax <code>[N:t]T</code>, <code>[:t]T</code>, and <code>[*:t]T</code>, where <code>t</code> is a value of the child type <code>T</code>.</p>
<p>An example of a sentinel terminated array. The built-in <a href="https://ziglang.org/documentation/master/#bitCast"><code>@bitCast</code></a> is used to perform an unsafe bitwise type conversion. This shows us that the last element of the array is followed by a 0 byte.</p>
<div class="highlight"><pre><span></span><code><span class="k">test</span><span class="w"> </span><span class="s">&quot;sentinel termination&quot;</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="kr">const</span><span class="w"> </span><span class="n">terminated</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">[</span><span class="mi">3</span><span class="o">:</span><span class="mi">0</span><span class="p">]</span><span class="kt">u8</span><span class="p">{</span><span class="w"> </span><span class="mi">3</span><span class="p">,</span><span class="w"> </span><span class="mi">2</span><span class="p">,</span><span class="w"> </span><span class="mi">1</span><span class="w"> </span><span class="p">};</span>
<span class="w">    </span><span class="k">try</span><span class="w"> </span><span class="n">expect</span><span class="p">(</span><span class="n">terminated</span><span class="p">.</span><span class="n">len</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="mi">3</span><span class="p">);</span>
<span class="w">    </span><span class="k">try</span><span class="w"> </span><span class="n">expect</span><span class="p">(</span><span class="nb">@as</span><span class="p">(</span><span class="o">*</span><span class="kr">const</span><span class="w"> </span><span class="p">[</span><span class="mi">4</span><span class="p">]</span><span class="kt">u8</span><span class="p">,</span><span class="w"> </span><span class="nb">@ptrCast</span><span class="p">(</span><span class="o">&amp;</span><span class="n">terminated</span><span class="p">))[</span><span class="mi">3</span><span class="p">]</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="mi">0</span><span class="p">);</span>
<span class="p">}</span>
</code></pre></div>
<p>The types of string literals is <code>*const [N:0]u8</code>, where N is the length of the string. This allows string literals to coerce to sentinel terminated slices, and sentinel terminated many pointers. Note: string literals are UTF-8 encoded.</p>
<div class="highlight"><pre><span></span><code><span class="k">test</span><span class="w"> </span><span class="s">&quot;string literal&quot;</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="k">try</span><span class="w"> </span><span class="n">expect</span><span class="p">(</span><span class="nb">@TypeOf</span><span class="p">(</span><span class="s">&quot;hello&quot;</span><span class="p">)</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="o">*</span><span class="kr">const</span><span class="w"> </span><span class="p">[</span><span class="mi">5</span><span class="o">:</span><span class="mi">0</span><span class="p">]</span><span class="kt">u8</span><span class="p">);</span>
<span class="p">}</span>
</code></pre></div>
<p><code>[*:0]u8</code> and <code>[*:0]const u8</code> perfectly model C's strings.</p>
<div class="highlight"><pre><span></span><code><span class="k">test</span><span class="w"> </span><span class="s">&quot;C string&quot;</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="kr">const</span><span class="w"> </span><span class="n">c_string</span><span class="o">:</span><span class="w"> </span><span class="p">[</span><span class="o">*:</span><span class="mi">0</span><span class="p">]</span><span class="kr">const</span><span class="w"> </span><span class="kt">u8</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="s">&quot;hello&quot;</span><span class="p">;</span>
<span class="w">    </span><span class="kr">var</span><span class="w"> </span><span class="n">array</span><span class="o">:</span><span class="w"> </span><span class="p">[</span><span class="mi">5</span><span class="p">]</span><span class="kt">u8</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="kc">undefined</span><span class="p">;</span>

<span class="w">    </span><span class="kr">var</span><span class="w"> </span><span class="n">i</span><span class="o">:</span><span class="w"> </span><span class="kt">usize</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">0</span><span class="p">;</span>
<span class="w">    </span><span class="k">while</span><span class="w"> </span><span class="p">(</span><span class="n">c_string</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="w"> </span><span class="o">!=</span><span class="w"> </span><span class="mi">0</span><span class="p">)</span><span class="w"> </span><span class="o">:</span><span class="w"> </span><span class="p">(</span><span class="n">i</span><span class="w"> </span><span class="o">+=</span><span class="w"> </span><span class="mi">1</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">        </span><span class="n">array</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">c_string</span><span class="p">[</span><span class="n">i</span><span class="p">];</span>
<span class="w">    </span><span class="p">}</span>
<span class="p">}</span>
</code></pre></div>
<p>Sentinel terminated types coerce to their non-sentinel-terminated counterparts.</p>
<div class="highlight"><pre><span></span><code><span class="k">test</span><span class="w"> </span><span class="s">&quot;coercion&quot;</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="kr">var</span><span class="w"> </span><span class="n">a</span><span class="o">:</span><span class="w"> </span><span class="p">[</span><span class="o">*:</span><span class="mi">0</span><span class="p">]</span><span class="kt">u8</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="kc">undefined</span><span class="p">;</span>
<span class="w">    </span><span class="kr">const</span><span class="w"> </span><span class="n">b</span><span class="o">:</span><span class="w"> </span><span class="p">[</span><span class="o">*</span><span class="p">]</span><span class="kt">u8</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">a</span><span class="p">;</span>
<span class="w">    </span><span class="n">_</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">b</span><span class="p">;</span>

<span class="w">    </span><span class="kr">var</span><span class="w"> </span><span class="n">c</span><span class="o">:</span><span class="w"> </span><span class="p">[</span><span class="mi">5</span><span class="o">:</span><span class="mi">0</span><span class="p">]</span><span class="kt">u8</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="kc">undefined</span><span class="p">;</span>
<span class="w">    </span><span class="kr">const</span><span class="w"> </span><span class="n">d</span><span class="o">:</span><span class="w"> </span><span class="p">[</span><span class="mi">5</span><span class="p">]</span><span class="kt">u8</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">c</span><span class="p">;</span>
<span class="w">    </span><span class="n">_</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">d</span><span class="p">;</span>

<span class="w">    </span><span class="kr">var</span><span class="w"> </span><span class="n">e</span><span class="o">:</span><span class="w"> </span><span class="p">[</span><span class="o">:</span><span class="mi">10</span><span class="p">]</span><span class="kt">f32</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="kc">undefined</span><span class="p">;</span>
<span class="w">    </span><span class="kr">const</span><span class="w"> </span><span class="n">f</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">e</span><span class="p">;</span>
<span class="w">    </span><span class="n">_</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">f</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></div>
<p>Sentinel terminated slicing is provided which can be used to create a sentinel terminated slice with the syntax <code>x[n..m:t]</code>, where <code>t</code> is the terminator value. Doing this is an assertion from the programmer that the memory is terminated where it should be - getting this wrong is detectable illegal behaviour.</p>
<div class="highlight"><pre><span></span><code><span class="k">test</span><span class="w"> </span><span class="s">&quot;sentinel terminated slicing&quot;</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="kr">var</span><span class="w"> </span><span class="n">x</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">[</span><span class="n">_</span><span class="o">:</span><span class="mi">0</span><span class="p">]</span><span class="kt">u8</span><span class="p">{</span><span class="mi">255</span><span class="p">}</span><span class="w"> </span><span class="o">**</span><span class="w"> </span><span class="mi">3</span><span class="p">;</span>
<span class="w">    </span><span class="kr">const</span><span class="w"> </span><span class="n">y</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">x</span><span class="p">[</span><span class="mi">0</span><span class="p">..</span><span class="mi">3</span><span class="w"> </span><span class="o">:</span><span class="mi">0</span><span class="p">];</span>
<span class="w">    </span><span class="n">_</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">y</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></div>
<h2 id="vectors">Vectors<a class="headerlink" href="#vectors" title="Permanent link">§</a></h2>
<p>Zig provides vector types for SIMD. These are not to be conflated with vectors in a mathematical sense, or vectors like C++'s std::vector (for this, see "Arraylist" in chapter 2). Vector types are created with the builtin function <a href="https://ziglang.org/documentation/master/#Vector">@Vector</a>.</p>
<p>A vector is a group of booleans, <a href="https://ziglang.org/documentation/master/#Integers">Integers</a>, <a href="#floats">Floats</a>, or <a href="#pointers-t">Pointers</a> which are operated on in parallel, using SIMD instructions if possible.</p>
<p>Operations between vectors with the same child type and length can take place. These operations are performed on each of the values in the vector.<a href="https://ziglang.org/documentation/master/std/#A;std:meta.eql"><code>std.meta.eql</code></a> is used here to check for equality between two vectors (also useful for other types like structs).</p>
<div class="highlight"><pre><span></span><code><span class="kr">const</span><span class="w"> </span><span class="n">meta</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="nb">@import</span><span class="p">(</span><span class="s">&quot;std&quot;</span><span class="p">).</span><span class="n">meta</span><span class="p">;</span>

<span class="k">test</span><span class="w"> </span><span class="s">&quot;vector add&quot;</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="kr">const</span><span class="w"> </span><span class="n">x</span><span class="o">:</span><span class="w"> </span><span class="nb">@Vector</span><span class="p">(</span><span class="mi">4</span><span class="p">,</span><span class="w"> </span><span class="kt">f32</span><span class="p">)</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">.{</span><span class="w"> </span><span class="mi">1</span><span class="p">,</span><span class="w"> </span><span class="o">-</span><span class="mi">10</span><span class="p">,</span><span class="w"> </span><span class="mi">20</span><span class="p">,</span><span class="w"> </span><span class="o">-</span><span class="mi">1</span><span class="w"> </span><span class="p">};</span>
<span class="w">    </span><span class="kr">const</span><span class="w"> </span><span class="n">y</span><span class="o">:</span><span class="w"> </span><span class="nb">@Vector</span><span class="p">(</span><span class="mi">4</span><span class="p">,</span><span class="w"> </span><span class="kt">f32</span><span class="p">)</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">.{</span><span class="w"> </span><span class="mi">2</span><span class="p">,</span><span class="w"> </span><span class="mi">10</span><span class="p">,</span><span class="w"> </span><span class="mi">0</span><span class="p">,</span><span class="w"> </span><span class="mi">1</span><span class="w"> </span><span class="p">};</span>
<span class="w">    </span><span class="kr">const</span><span class="w"> </span><span class="n">z</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">x</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="n">y</span><span class="p">;</span>
<span class="w">    </span><span class="k">try</span><span class="w"> </span><span class="n">expect</span><span class="p">(</span><span class="n">meta</span><span class="p">.</span><span class="n">eql</span><span class="p">(</span><span class="n">z</span><span class="p">,</span><span class="w"> </span><span class="nb">@Vector</span><span class="p">(</span><span class="mi">4</span><span class="p">,</span><span class="w"> </span><span class="kt">f32</span><span class="p">){</span><span class="w"> </span><span class="mi">3</span><span class="p">,</span><span class="w"> </span><span class="mi">0</span><span class="p">,</span><span class="w"> </span><span class="mi">20</span><span class="p">,</span><span class="w"> </span><span class="mi">0</span><span class="w"> </span><span class="p">}));</span>
<span class="p">}</span>
</code></pre></div>
<p>Vectors are indexable.
<div class="highlight"><pre><span></span><code><span class="k">test</span><span class="w"> </span><span class="s">&quot;vector indexing&quot;</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="kr">const</span><span class="w"> </span><span class="n">x</span><span class="o">:</span><span class="w"> </span><span class="nb">@Vector</span><span class="p">(</span><span class="mi">4</span><span class="p">,</span><span class="w"> </span><span class="kt">u8</span><span class="p">)</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">.{</span><span class="w"> </span><span class="mi">255</span><span class="p">,</span><span class="w"> </span><span class="mi">0</span><span class="p">,</span><span class="w"> </span><span class="mi">255</span><span class="p">,</span><span class="w"> </span><span class="mi">0</span><span class="w"> </span><span class="p">};</span>
<span class="w">    </span><span class="k">try</span><span class="w"> </span><span class="n">expect</span><span class="p">(</span><span class="n">x</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="mi">255</span><span class="p">);</span>
<span class="p">}</span>
<span class="err">юю`</span>

<span class="n">The</span><span class="w"> </span><span class="n">built</span><span class="o">-</span><span class="n">in</span><span class="w"> </span><span class="n">function</span><span class="w"> </span><span class="p">[</span><span class="err">`</span><span class="nb">@splat</span><span class="err">`</span><span class="p">](</span><span class="n">https</span><span class="o">:</span><span class="c1">//ziglang.org/documentation/master/#splat) may be used to construct a vector where all of the values are the same. Here we use it to multiply a vector by a scalar.</span>

<span class="err">```</span><span class="n">zig</span>
<span class="k">test</span><span class="w"> </span><span class="s">&quot;vector * scalar&quot;</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="kr">const</span><span class="w"> </span><span class="n">x</span><span class="o">:</span><span class="w"> </span><span class="nb">@Vector</span><span class="p">(</span><span class="mi">3</span><span class="p">,</span><span class="w"> </span><span class="kt">f32</span><span class="p">)</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">.{</span><span class="w"> </span><span class="mf">12.5</span><span class="p">,</span><span class="w"> </span><span class="mf">37.5</span><span class="p">,</span><span class="w"> </span><span class="mf">2.5</span><span class="w"> </span><span class="p">};</span>
<span class="w">    </span><span class="kr">const</span><span class="w"> </span><span class="n">vec</span><span class="o">:</span><span class="w"> </span><span class="nb">@Vector</span><span class="p">(</span><span class="mi">3</span><span class="p">,</span><span class="w"> </span><span class="kt">f32</span><span class="p">)</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="nb">@splat</span><span class="p">(</span><span class="mi">2</span><span class="p">);</span>
<span class="w">    </span><span class="kr">const</span><span class="w"> </span><span class="n">y</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">x</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="n">vec</span><span class="p">;</span>
<span class="w">    </span><span class="k">try</span><span class="w"> </span><span class="n">expect</span><span class="p">(</span><span class="n">meta</span><span class="p">.</span><span class="n">eql</span><span class="p">(</span><span class="n">y</span><span class="p">,</span><span class="w"> </span><span class="nb">@Vector</span><span class="p">(</span><span class="mi">3</span><span class="p">,</span><span class="w"> </span><span class="kt">f32</span><span class="p">){</span><span class="w"> </span><span class="mi">25</span><span class="p">,</span><span class="w"> </span><span class="mi">75</span><span class="p">,</span><span class="w"> </span><span class="mi">5</span><span class="w"> </span><span class="p">}));</span>
<span class="p">}</span>
</code></pre></div></p>
<p>Vectors do not have a <code>len</code> field like arrays, but may still be looped over. Here, <a href="https://ziglang.org/documentation/master/std/#A;std:mem.len"><code>std.mem.len</code></a> is used as a shortcut for <code>@typeInfo(@TypeOf(x)).Vector.len</code>.</p>
<div class="highlight"><pre><span></span><code><span class="kr">const</span><span class="w"> </span><span class="n">len</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="nb">@import</span><span class="p">(</span><span class="s">&quot;std&quot;</span><span class="p">).</span><span class="n">mem</span><span class="p">.</span><span class="n">len</span><span class="p">;</span>

<span class="k">test</span><span class="w"> </span><span class="s">&quot;vector looping&quot;</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="kr">const</span><span class="w"> </span><span class="n">x</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="nb">@Vector</span><span class="p">(</span><span class="mi">4</span><span class="p">,</span><span class="w"> </span><span class="kt">u8</span><span class="p">){</span><span class="w"> </span><span class="mi">255</span><span class="p">,</span><span class="w"> </span><span class="mi">0</span><span class="p">,</span><span class="w"> </span><span class="mi">255</span><span class="p">,</span><span class="w"> </span><span class="mi">0</span><span class="w"> </span><span class="p">};</span>
<span class="w">    </span><span class="kr">var</span><span class="w"> </span><span class="n">sum</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">blk</span><span class="o">:</span><span class="w"> </span><span class="p">{</span>
<span class="w">        </span><span class="kr">var</span><span class="w"> </span><span class="n">tmp</span><span class="o">:</span><span class="w"> </span><span class="n">u10</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">0</span><span class="p">;</span>
<span class="w">        </span><span class="kr">var</span><span class="w"> </span><span class="n">i</span><span class="o">:</span><span class="w"> </span><span class="kt">u8</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">0</span><span class="p">;</span>
<span class="w">        </span><span class="k">while</span><span class="w"> </span><span class="p">(</span><span class="n">i</span><span class="w"> </span><span class="o">&lt;</span><span class="w"> </span><span class="mi">4</span><span class="p">)</span><span class="w"> </span><span class="o">:</span><span class="w"> </span><span class="p">(</span><span class="n">i</span><span class="w"> </span><span class="o">+=</span><span class="w"> </span><span class="mi">1</span><span class="p">)</span><span class="w"> </span><span class="n">tmp</span><span class="w"> </span><span class="o">+=</span><span class="w"> </span><span class="n">x</span><span class="p">[</span><span class="n">i</span><span class="p">];</span>
<span class="w">        </span><span class="k">break</span><span class="w"> </span><span class="o">:</span><span class="n">blk</span><span class="w"> </span><span class="n">tmp</span><span class="p">;</span>
<span class="w">    </span><span class="p">};</span>
<span class="w">    </span><span class="k">try</span><span class="w"> </span><span class="n">expect</span><span class="p">(</span><span class="n">sum</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="mi">510</span><span class="p">);</span>
<span class="p">}</span>
</code></pre></div>
<p>Vectors coerce to their respective arrays.</p>
<div class="highlight"><pre><span></span><code><span class="kr">const</span><span class="w"> </span><span class="n">arr</span><span class="o">:</span><span class="w"> </span><span class="p">[</span><span class="mi">4</span><span class="p">]</span><span class="kt">f32</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="nb">@Vector</span><span class="p">(</span><span class="mi">4</span><span class="p">,</span><span class="w"> </span><span class="kt">f32</span><span class="p">){</span><span class="w"> </span><span class="mi">1</span><span class="p">,</span><span class="w"> </span><span class="mi">2</span><span class="p">,</span><span class="w"> </span><span class="mi">3</span><span class="p">,</span><span class="w"> </span><span class="mi">4</span><span class="w"> </span><span class="p">};</span>
</code></pre></div>
<p>It is worth noting that using explicit vectors may result in slower software if you do not make the right decisions - the compiler's auto-vectorisation is fairly smart as-is.</p>
<h2 id="imports">Imports<a class="headerlink" href="#imports" title="Permanent link">§</a></h2>
<p>The built-in function <a href="https://ziglang.org/documentation/master/#import"><code>@import</code></a> takes in a file, and gives you a struct type based on that file. All declarations labelled as <code>pub</code> (for public) will end up in this struct type, ready for use.</p>
<p><code>@import("std")</code> is a special case in the compiler, and gives you access to the standard library. Other <a href="https://ziglang.org/documentation/master/#import"><code>@import</code></a>s will take in a file path, or a package name (more on packages in a later chapter).</p>
<p>We will explore more of the standard library in later chapters.</p>
<h2 id="end-of-chapter-1">End Of Chapter 1<a class="headerlink" href="#end-of-chapter-1" title="Permanent link">§</a></h2>
<p>In the next chapter we will cover standard patterns, including many useful areas of the standard library.</p>
<p>Feedback and PRs are welcome.</p>





                
              </article>
            </div>
          
          
        </div>
        
      </main>
      
        <footer class="md-footer">
  
    
      
      <nav class="md-footer__inner md-grid" aria-label="Нижний колонтитул" >
        
          
          <a href="../" class="md-footer__link md-footer__link--prev" aria-label="Назад: Глава 0 — Начало работы" rel="prev">
            <div class="md-footer__button md-icon">
              
              <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><path d="M20 11v2H8l5.5 5.5-1.42 1.42L4.16 12l7.92-7.92L13.5 5.5 8 11h12Z"/></svg>
            </div>
            <div class="md-footer__title">
              <span class="md-footer__direction">
                Назад
              </span>
              <div class="md-ellipsis">
                Глава 0 — Начало работы
              </div>
            </div>
          </a>
        
        
          
          <a href="../chapter-2/" class="md-footer__link md-footer__link--next" aria-label="Вперед: Chapter 2 - Standard Patterns" rel="next">
            <div class="md-footer__title">
              <span class="md-footer__direction">
                Вперед
              </span>
              <div class="md-ellipsis">
                Chapter 2 - Standard Patterns
              </div>
            </div>
            <div class="md-footer__button md-icon">
              
              <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><path d="M4 11v2h12l-5.5 5.5 1.42 1.42L19.84 12l-7.92-7.92L10.5 5.5 16 11H4Z"/></svg>
            </div>
          </a>
        
      </nav>
    
  
  <div class="md-footer-meta md-typeset">
    <div class="md-footer-meta__inner md-grid">
      <div class="md-copyright">
  
  
</div>
      
    </div>
  </div>
</footer>
      
    </div>
    <div class="md-dialog" data-md-component="dialog">
      <div class="md-dialog__inner md-typeset"></div>
    </div>
    
    <script id="__config" type="application/json">{"base": "../..", "features": ["navigation.instant", "navigation.tracking", "navigation.sections", "navigation.expand", "toc.follow", "toc.integrate", "navigation.footer", "content.action.edit", "content.action.view"], "search": "../../assets/javascripts/workers/search.dfff1995.min.js", "translations": {"clipboard.copied": "\u0421\u043a\u043e\u043f\u0438\u0440\u043e\u0432\u0430\u043d\u043e \u0432 \u0431\u0443\u0444\u0435\u0440", "clipboard.copy": "\u041a\u043e\u043f\u0438\u0440\u043e\u0432\u0430\u0442\u044c \u0432 \u0431\u0443\u0444\u0435\u0440", "search.result.more.one": "\u0415\u0449\u0451 1 \u043d\u0430 \u044d\u0442\u043e\u0439 \u0441\u0442\u0440\u0430\u043d\u0438\u0446\u0435", "search.result.more.other": "\u0415\u0449\u0451 # \u043d\u0430 \u044d\u0442\u043e\u0439 \u0441\u0442\u0440\u0430\u043d\u0438\u0446\u0435", "search.result.none": "\u0421\u043e\u0432\u043f\u0430\u0434\u0435\u043d\u0438\u0439 \u043d\u0435 \u043d\u0430\u0439\u0434\u0435\u043d\u043e", "search.result.one": "\u041d\u0430\u0439\u0434\u0435\u043d\u043e 1 \u0441\u043e\u0432\u043f\u0430\u0434\u0435\u043d\u0438\u0435", "search.result.other": "\u041d\u0430\u0439\u0434\u0435\u043d\u043e \u0441\u043e\u0432\u043f\u0430\u0434\u0435\u043d\u0438\u0439: #", "search.result.placeholder": "\u041d\u0430\u0447\u043d\u0438\u0442\u0435 \u043f\u0435\u0447\u0430\u0442\u0430\u0442\u044c \u0434\u043b\u044f \u043f\u043e\u0438\u0441\u043a\u0430", "search.result.term.missing": "\u041e\u0442\u0441\u0443\u0442\u0441\u0442\u0432\u0443\u0435\u0442", "select.version": "\u0412\u044b\u0431\u0435\u0440\u0438\u0442\u0435 \u0432\u0435\u0440\u0441\u0438\u044e"}}</script>
    
    
      <script src="../../assets/javascripts/bundle.78eede0e.min.js"></script>
      
    
  </body>
</html>